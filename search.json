[{"title":"攻防世界-eaasy-so","url":"%2F2020%2F05%2F26%2F%E9%80%86%E5%90%91%2FCTF%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%2Feasy-so%2F","content":"\n# easy-so\n\n附件地址：\n\nhttps://adworld.xctf.org.cn/media/task/attachments/456c1dab04b24036ba1d6e32a08dc882.apk\n\n## 分析\n\n安装apk文件，梳理逻辑，寻找flag隐藏方式，ddms 随时监听\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526101345.png)\n\n打开jadx 查看`验证失败` 是怎么出现的\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526101514.png)\n\n定位CheckString 函数，很明显 这是个so层的方法，那目的明确了 去so层找这个方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526102651.png)\n\n分析so层 搜索`Java_`关键字，找到checkstring ，跟进\n\n有个判断相等就返回1，那么回推v4 = f72c5a36569418a20907b55be5bf95ad\n\n`if ( !strcmp(v4, \"f72c5a36569418a20907b55be5bf95ad\") )`\n\nv4进行了一次`j_TestDec` ，那么可以判断\n\n跟进j_TestDec, 在TestDec 中有两个判断，第一个判断内做了一次前16位和后16位交换，第二个判断是两两之间做了一次交换。\n\n那逆推也就简单了。 和前面分析的几个题大致类似\n\n单独把TestDec拿出来 看看\n\n```\n  v1 = (char *)a1;\n  # 这里做了一个前16位和后16位的交换\n  if ( strlen(a1) >= 2 )\n  {\n    v2 = 0;\n    do\n    {\n      v3 = (int)&v1[v2];  v3 记录地址\n      v4 = v1[v2];\t\t\tv4 记录值\n      v1[v2] = v1[v2 + 16];  然后 str[0] = str[16] 此后 每次都是 str[v2] = str[v2+16]\n      ++v2; \n      *(_BYTE *)(v3 + 16) = v4;   str[v2+16] = v4\n    }\n    while ( v2 < strlen(v1) >> 1 );\n  }\n  result = (unsigned __int8)*v1;\n  # 这里做了一个两两交换\n  if ( *v1 )\n  {\n    *v1 = v1[1];   \n    v1[1] = result;\t\t\t\t\t\t\n    result = strlen(v1);\t\t\t\t\n    if ( result >= 3 )\n    {\n      v6 = 0;\n      do\n      {\n        v7 = (int)&v1[v6];   这里替换成熟悉的变量    \n        v8 = v1[v6 + 2];\tv8 用tmp表示\ttmp = v1[2]\t\t\t\n        *(_BYTE *)(v7 + 2) = v1[v6 + 3]; v1[2] = v1[3]\n        *(_BYTE *)(v7 + 3) = v8;\t\tv[3] = tmp\n        result = strlen(v1);\n        v9 = v6 + 4;\n        v6 += 2;\n      }\n      while ( v9 < result );\n    }\n  }\n```\n\n\n\n## 脚本\n\n```\nstr = list(\"f72c5a36569418a20907b55be5bf95ad\")\n\n# 反推\n# 做一次两两交换\nfor i in range(0, len(str), 2):\n    str[i], str[i + 1] = str[i + 1], str[i]\nprint(\"\".join(str))\n# 在做一次前16位和后16位的交换\nfor i in range(len(str) // 2):\n    str[i], str[i + 16] = str[i + 16], str[i]\nprint(\"\".join(str))\n# 记得加上flag{} 格式\n\n```\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"ctfhub-彩蛋","url":"%2F2020%2F05%2F26%2F%E9%80%86%E5%90%91%2FCTF%2Fctfhub%2F%E5%BD%A9%E8%9B%8B%2F","content":"\n# 彩蛋\n\n## 首页\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083224.png)\n\n\n\n`*.ctfhub.com` 不确定是那个域名的首页，那么先搜索一下子域名瞧瞧 \n\n使用工具：Turbolist3r\n\n```\n[-] Total Unique Subdomains Found: 4\napi.ctfhub.com\nctfhub.com<BR>www.ctfhub.com\nstatic.ctfhub.com\nwriteup.ctfhub.com\n```\n\n第一个就命中了，ctrl+u 查看源代码，找到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083437.png)\n\n## 公众号\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084053.png)\n\n看来不得不关注一波了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083746.png)\n\n每一位CTF选手都是在为flag冲击\n\n\n\n## 题目入口\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084116.png)\n\n那就找找题目的入口看看， 哈哈，找了个web题，\n\n打开正常 ，不存在flag， 然后经过。。。。。时间后，猜测可能报错会存在flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084927.png)\n\n删除域名其中的字符使其报错，拿到`flag`\n\n## Writeup\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085510.png)\n\n那就去writeup中找找，翻了好几个wp都没找到，还学习了很多知识，你确定是让我找flag，到处点点，最后在搜索处，以`flag`找到了flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085647.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085706.png)\n\n## 工具\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085859.png)\n\n在工具中翻一翻，没有什么本站链接，然后灵机一动，翻到最后一页，拿到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090010.png)\n\n奇怪打开是404， 试了好几遍，发现了猫腻，居然会跳转到404 ，手速要快，还有可以F12查找\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090121.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090229.png)\n\n## 赛事\n\n有没有做到后面得心应手的感觉，那都是幻觉 醒醒\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090333.png)\n\n和工具类似，直接翻到最后一页，拿到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090419.png)\n\n## 真题\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090506.png)\n\n直接翻到最后一页，没有啥大的变化了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090537.png)\n\n## 投稿提交\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090812.png)\n\n来到writeup投稿，拿到前半段 flag[6:12] = \"{029e0\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090742.png)\n\n然后在题目提交处，拿到感觉是中间一部分flag[12:18] = \"2eb3a1\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090909.png)\n\n在wp投稿 源代码中找到最后一串flag\n\n```\nZmxhZyU1QjE4JTNBMjQlNUQlMjAlM0QlMjAlMjJlOGM0OWIlMjI=、\nbase64 -> urldecode 后\nflag[18:24] = \"e8c49b\"\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091326.png)\n\n长记性了，再去题目提交出看看再次拿到一串字符串，这是16进制，转成字符串后得到24-30位的flag\n\n```\n666c61675b32343a33305d203d202231313332623522\n16进制转字符串\nflag[24:30] = \"1132b5\"\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091642.png)\n\n发现 flag长度还是不够，接下来继续翻\n\n在题目提交中图片中找到一串flag ： flag[36:42] = \"a5f3a8\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091952.png)\n\n在wp提交中图片中找到flag：flag[30:36] = \"15b652\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526092049.png)\n\n在下载demo中找到最后的flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526092234.png)\n\n6位字母混合是 26^6次方啊，爆破到啥时候了，百度了下，密码是ctfhub，那我也不写脚本爆破了，直接拿来获得正解。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526094003.png)\n\n\n\n\n\n最后的flag是：ctfhub{029e02eb3a1e8c49b}\n\n","tags":["CTF"],"categories":["Misc"]},{"title":"攻防世界-easyjni","url":"%2F2020%2F05%2F25%2F%E9%80%86%E5%90%91%2FCTF%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%2Feasyjni%2F","content":"\n# easyjni\n\n下载附件地址：https://adworld.xctf.org.cn/media/task/attachments/eb760e6a10ea4dcab700a6b7db948488.apk\n\n\n\n## 分析\n\n安装apk，先看看逻辑，打开后发现输入字符串，然后系统判断正确与否，那么就要自己去啃算法了\n\n打开jadx ，定位到oncrete处，`if`判断决定了是正确还是失败，跟进其中的方法查看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525180305.png)\n\n在a方法中，当`ncheck(new a().a(str.getBytes()))` 才能返回正确，那么继续跟进，看何时返回`True`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525180459.png)\n\n先分析一个`new a().a(str.getBytes())` 获得了什么\n\n输入一个a \n\na.getBytes(): [B@1540e19d\n\n输出 23==\n\n做了一个类似base64编码的算法\n\n下来看ncheck \n\n\n\n定位到如下，看来居然是在so层进行的判断。那么打开ida 查看，so文件在lib下\n\n`    private native boolean ncheck(String str);`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525183450.png)\n\n搜索Java下划线开头的方法，只有一个，那么就查看他了，进去后tab一下，查看伪代码\n\n从后往前分析， return=1  时  v12 为空，那么 memcmp 方法中s1 ==MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525184022.png)\n\n```\nv5 = (env->functions->GetStringUTFChars)(env, str, 0);\n  if ( strlen(v5) == 32 )\n  {\n    v6 = 0;\n    do\n    {\n      v7 = &s1[v6];\n      s1[v6] = v5[v6 + 16];\n      v8 = v5[v6++];\n      v7[16] = v8;\n    }// 前16位和后16位 交换\n    while ( v6 != 16 );\n    (env_1->functions->ReleaseStringUTFChars)(env_1, v4, v5);\n    v9 = 0;\n    do\n    {\n      v11 = __OFSUB__(v9, 30);\n      v10 = v9 - 30 < 0;\n      v15 = s1[v9];\n      s1[v9] = s1[v9 + 1];\n      s1[v9 + 1] = v15;\n      v9 += 2; \n    } // 两两之间交换\n    while ( v10 ^ v11 );\n    v12 = memcmp(s1, \"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\", ' ');\n```\n\n所以解密的方式也就清晰了，先解决so层，得到传入so层的值，然后解决java层 得到flag\n\n\n\n## 脚本\n\n脚本分为两个部分 so（）是解决so里面的两个加密， 一个是两两交换，一个是前16和后16交换，之后是java层的加密，是一个替换了base64表的加密，只需要更换base64 表，重新接码即可，\n\n```\ndef so():\n    str = list(\"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\")\n    print(len(str))\n    # 先两两交换\n    for i in range(0,len(str),2):\n        str[i],str[i+1] = str[i+1],str[i]\n    print(\"\".join(str))\n    # 然后将str 的前16位和后16位交换\n    for i in  range(len(str)//2):\n        str[i],str[i+16] = str[i+16],str[i]\n    print(\"\".join(str))\n    return \"\".join(str)\n# 之后就是java层的，和解码base64类似\n\n\ndef unbase(string:str)->str:\n    oldstr = ''\n    unbase = ''\n    base64_list = ['i', '5', 'j', 'L', 'W', '7', 'S', '0', 'G', 'X', '6',\n                    'u', 'f', '1', 'c', 'v', '3', 'n', 'y', '4', 'q', '8',\n                    'e', 's', '2', 'Q', '+', 'b', 'd', 'k', 'Y', 'g', 'K',\n                    'O', 'I', 'T', '/', 't', 'A', 'x', 'U', 'r', 'F', 'l',\n                    'V', 'P', 'z', 'h', 'm', 'o', 'w', '9', 'B', 'H', 'C',\n                    'M', 'D', 'p', 'E', 'a', 'J', 'R', 'Z', 'N']\n    for i in string.replace('=',''):\n        oldstr += '{:06}'.format(int(bin(base64_list.index(i)).replace('0b', '')))\n    newstr = ['{}'.format(oldstr[j:j + 8]) for j in range(0, len(oldstr), 8)]\n    for l in range(len(newstr)):\n        unbase += chr(int(newstr[l], 2))\n\n    print(unbase)\nif __name__ == \"__main__\":\n    unbase(so())\n\n\n# 参考 ： https://blog.csdn.net/Leeeey/article/details/89517254 找到一个base64 解码的python脚本\n\n结果：flag{just_ANot#er_@p3} \n\n```\n\n\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"攻防世界-easyjava","url":"%2F2020%2F05%2F25%2F%E9%80%86%E5%90%91%2FCTF%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%2Feasyjava%2F","content":"\n\n\n## 攻防世界题解easyjava\n\n好无聊啊，找个CTF做做，攻防世界有一栏Mobile的 正好适合\n\n下载文件地址： \n\nhttps://adworld.xctf.org.cn/media/task/attachments/3f06e60ded5e44e3b0f4c47020cbcb3c.apk\n\n\n\n\n\n## 分析\n\n使用`jadx`工具 反编译查看代码，先看看App 的oncreate方法\n\n有一个`if`判断，判断正确 返回`You are right` 否则 返回 `Your are wrong! Bye~`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523155923.png)\n\n\n\n```\nMainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()\n```\n\n大致意思是 传入了一个值，然后在b方法中调用 ，返回的结果转为bool类型，那么就是说这里的返回值要求为1 才能进入`if`判断\n\n看一下b方法 中的逻辑\n\n```\npublic static Boolean b(String str) { // 传入一个String类型\n        if (!str.startsWith(\"flag{\")) { // 判断是否以flag{ 开始  \n            return false;\n        }\n        if (!str.endsWith(\"}\")) { // 判断是否以} 结尾\n            return false;\n        }\n        String substring = str.substring(5, str.length() - 1); // 去除 flag{ 和} 之后的结果保存到substring中\n        b bVar = new b(2); // 这里我单独拉出来了 运行了一下，得到了结果\n        a aVar = new a(3);\n        // 这里就讲bvar 和aVar 写成明文\n        String bVar = \"ctf.demo.b@1540e19d\";\n        String aVar = \"ctf.demo.a@1540e19d\";\n        // 分析for循环\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        for (int i2 = 0; i2 < substring.length(); i2++) {\n            sb.append(a(substring.charAt(i2) + \"\", bVar, aVar));\n            Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25);\n            if (valueOf.intValue() > i && valueOf.intValue() >= 1) {\n                i++;\n            }\n        }\n        return Boolean.valueOf(sb.toString().equals(\"wigwrkaugala\"));\n    }\n\n```\n\nbVar: ctf.demo.b@1540e19d\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523162216.png)\n\naVar: ctf.demo.a@1540e19d\n\n通过加注释获得了了解到整个流程\n\n```\nflag{zdgd}\n-----------------------\nb->abcdefghijklmnopqrstuvwxyz\nb.a(String str) ->z\nInteger.valueOf(b.indexOf(str))->25\na->[17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]  因为每次判断都是长度减一  所以当判断25次就结束了 第一次给z 循环判断失败。i等于0\nb: i ->0\na.a a(Integer num)->0 将i 传入 aVar.a(i)\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16] 寻找0的位置 在第16次找到\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->16 a类中的b 是个固定的。所以最后得到的第16位就是q\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->q\n-----------------------\nb->bcdefghijklmnopqrstuvwxyza\nb.a(String str) ->d\nInteger.valueOf(b.indexOf(str))2\na->[23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17]\na.get(i2)->13\nb: i ->13\na.a a(Integer num)->13\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->10\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->k\n-----------------------\nb->cdefghijklmnopqrstuvwxyzab\nb.a(String str) ->g\nInteger.valueOf(b.indexOf(str))4\na->[7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17, 23]\na.get(i2)->14\nb: i ->14\na.a a(Integer num)->14\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->24\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->y\n-----------------------\nb->defghijklmnopqrstuvwxyzabc\nb.a(String str) ->d\nInteger.valueOf(b.indexOf(str))0\na->[22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17, 23, 7]\na.get(i2)->6\nb: i ->6\na.a a(Integer num)->6\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->9\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->j\nqkyj\n```\n\n所以逆推的方式：\n\n​\t第一次 b = “abcdefghijklmnopqrstuvwxyz”；\t之后每次都会做一次循环左移操作\n\n​\t第一次b 对应的序列[17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]  之后每次进行一次循环左移\n\n1. 获得`wigwrkaugala`每一位在字母表中的位置\n\n   比如 w 在字符表中的位置是22， \n\n2. 然后在a类中的a函数获取每一位位置对应的数num\n\n   然后在[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16] 找到22对应的数，  为8\n\n3. 之后将获得的数num找到a序列中第num位对应的数字\n\n   8 找到对应的数为 21\n\n   [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]\n\n4. 将拿到后的数字在b字符串中寻找对应的数，\n\n   然后在 abcdefghijklmnopqrstuvwxyz 找到21 对应的数字为 v\n\n\n\n## 脚本\n\n逻辑理清了 接下来写脚本\n\n```\n\nb = \"abcdefghijklmnopqrstuvwxyz\"\nresult = \"wigwrkaugala\"\nLa = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nLb = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]\n\nstr1 = []\nflag = \"\"\nfor i in result:\n    str1.append(La[b.index(i)])\n\nprint(str1)\n\nfor i in str1:\n    str2 = Lb[i]\n    flag += b[str2]\n    b = b[1:]+ b[:1]\n    Lb.insert(len(Lb), Lb[0])\n    Lb.remove(Lb[0])\nprint(flag)\n```\n\n[8, 17, 15, 8, 22, 13, 21, 23, 15, 21, 3, 21]\nvenividivkcr\n\n备注： 脚本 参考 西瓜西米露表姐。","tags":["CTF"],"categories":["Reverse"]},{"title":"小白学习--dalvik指令集","url":"%2F2020%2F05%2F23%2F%E9%80%86%E5%90%91%2F%E5%9F%BA%E7%A1%80%2Fdalvik%E6%8C%87%E4%BB%A4%E9%9B%86%2F","content":"\n为什么要写这个， 因为看的太枯燥了，自己手打一遍 加深记忆。\n\n# 1 dalvik 字节码\n\n在说指令集前 先简单的回忆一下dalvik字节码的相关知识。\n\n## 1.1 Dalvik 寄存器\n\n`Dalvik`寄存器分为32位和64位，小于等于32位的使用一个寄存器标识，64位使用两个相邻寄存器标识，\n\n## 1.2 寄存器的命名法\n\n寄存器有两种命名方式：v命名法和p命名法\n\n**v命名法**\n\n局部变量寄存器 v0-vn 表示，参数寄存器从vn - v(n+m)\n\n比如 在下图中，使用了v1,v2,v3,v4,v5,其中 v0,v1,v2 是局部变量，v3 和v4 是参数。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523110407.png)\n\n\n\n**p命名法**\n\n变量寄存器 v0-vn  参数寄存器 p0-pn\n\np命名法比v命名法容易辨识,参数和变量采用不同的字母表示，但两者表示的含义都是一样的，没有什么区别。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523110815.png)\n\n\n\n## 1.3 了解dex反编译工具\n\n**java 文件到smali文件的过程**\n\n`.java`编译成`.class`在线编译成`.dex`，最后反编译成`smali`文件 \n\n**class 文件打包成dex**\n\n> dx --dex --output=Decrypt.dex com/xiaomutou/demo/Decrypt.class\n\n**dex文件反编译成samli文件**\n\n> java -jar baksmali.jar -o smali_out/ classex.dex\n\n**smali 打包成dex**\n\n> java -jar smali.jar smali_out/ -o classes.dex\n\n## 1.4 Dalvik 字节码类型\n\n在Dalvik中有一种描述类型的方式和Java对应，下面给出具体规则\n\n| Dalvik | Java       |\n| ------ | ---------- |\n| B      | byte       |\n| C      | char       |\n| S      | short      |\n| I      | int        |\n| J      | long       |\n| F      | float      |\n| D      | double     |\n| Z      | boolean    |\n| V      | void       |\n| L      | Java类类型 |\n| [      | 数组类型   |\n\n## 1.5 字段\n\nLpackage/name/ObjectName;->FieldName:Ljava/lang/String;\n\n**字段格式：类型（包名＋类名）->*字段名称 :*****字段类型**\n\n举例：\n\n```\nDalvik: \n\tLcom/alipay/sdk/app/H5PayActivity;->b:Ljava/lang/String;\nJava:\n    import com.alipay.sdk.app;\n\n    public class H5PayActivity {\n\n        String b;\n\n    }\n```\n\n```\nDalvik:\n\tLcom/auth/third/accountlink/ui/WebViewActivity;->a:Z\nJava:\n\timport com.auth.third.accoutlink.ui;\n\tpublic class WebViewActivity{\n\t\tboolean a;\n\t}\n```\n\n```\nDalvik:\n \tLcom/alipay/sdk/authjs/a;->m:Lorg/json/JSONObject;\nJava:\n\timport com.alipay.sdk.authjs;\n\timport org.json.JSONObject;\n\tpublic class a{\n\t\tJSONObject m;\n\t}\n\n```\n\n例子解析不知道对不对， 如果有表哥看到了欢迎指正\n\n## 1.6 方法\n\n**Lpackage/name/ObjectName;->MethodName (III) Z**\n\n **(III) Z:**这部分表示的是方法的签名信息\n\n举例：\n\n```\nDalvik:\n\tLandroid/app/Activity;-><init>()V\nJava:\n\tpackage andorid.app.Activity;\n\t\n\tpublic class Activity{\n\t\tpublic void <init>(){\n\t\t\n\t\t}\n\t} \n```\n\n```\nDalvik:\n\tLcom/alipay/sdk/j/h;->b()Z\nJava:\n\timport com.alipay.sdk.j;\n\tpublic class h{\n\t\tpublic boolean b(){\n\t\t\n\t\t}\n\t} \n```\n\n```\nDalvik:\n\tLandroid/content/Intent;->getExtras()Landroid/os/Bundle;\nJava:\n\timport andorid.content\n\tpublic class Intent{\n\t\tpublic Bundle getExtras(){\n\t\t\n\t\t}\n\t}\n```\n\n```\nDalvik:\n\tLorg/cocos2dx/lua/LoadingAct;->setContentView(I)V\nJava:\n\timport org.cocos2dx.lua;\n\tpublic class LoadingAct{\n\t\tpublic void setContentView(int p1){\n\t\t\n\t\t}\n\t}\n```\n\n例子解析不知道对不对， 如果有表哥看到了欢迎指正\n\n# 2 Dalvik 指令集\n\n## 2.1 Dalvik 指令格式\n\n推荐一篇文章：[Android 逆向笔记](https://www.zhihu.com/column/c_1115022200100511744)\n\n**基础字节码 - 名称后缀/字节码后缀 目的寄存器** **源寄存**\n\nmove-wide/from16 vAA,vBBBB\n\nmove 为基础字节码，即opcode\n\nwide 为名称后缀，标识指令操作的数据宽度为64位\n\nfrom16 为字节码后缀 ，标识源为一个16位的寄存器引用变量\n\nvAA 为目的寄存器，它始终在源寄存器的前面 一个A代表4位 两个A为8位 取值范围为V0-V(2^8)\n\nvBBBB 为源寄存器， 取值 v0 - v 65535\n\n\n\n## 常见Dalvik 指令的使用\n\n1. 空操作指令\n\n   nop  值为00 通常被用来做代码对齐，无实际操作\n\n2. 数据操作指令\n\n   move 作用：将源寄存器的值赋值给目的寄存器\n\n   move vA,vB ：将vB寄存器的值赋给vA寄存器，源寄存器与目的寄存器都为4位\n\n   move/form16 vAA,vBBBB：将vBBBB寄存器的值赋给vAA寄存器，源寄存器为16位，目的寄存器为8位。\n\n   move-wide vA, vB：为4位的寄存器对赋值。源寄存器与目的寄存器都为4位\n\n   move-object vA, vB：object是对象的意思，出现这个词即为对象。那这里就是为对象赋值。源寄存器与目的寄存器都为4位。\n\n   move-object/from16 vAA, vBBBB：为对象赋值。源寄存器为16位，目的寄存器为8位。\n\n   move-object/16 vAA, vBBBB：为对象赋值。源寄存器与目的寄存器都为16位。\n\n   move-result vAA：将上一个invoke类型指令操作的单字非对象结果赋给vAA寄存器。\n\n   move-result-wide vAA：将上一个invoke类型指令操作的双字非对象结果赋给vAA寄存器。\n\n   move-result-object vAA：将上一个invoke类型指令操作的对象结果赋给vAA寄存器。\n\n   move-exception vAA：保存运行时发生的异常到vAA寄存器。\n\n   move作用：\n\n   1. 赋值操作\n   2. move-result 接收方法返回值操作\n   3. 处理异常的操作\n\n3. 返回指令\n\n   **return**就是返回的意思，大家根据这个英文就可以理解啦。\n\n    \n\n   return-void：表示函数从一个void方法返回，返回值为空。\n\n    return vAA：表示函数返回一个32位**非对象**类型的值，返回值寄存器为8位的寄存器vAA。\n\n    return-wide vAA：表示函数返回一个64位**非对象**类型的值，返回值为8位的寄存器对vAA。\n\n    return-object vAA：这里面出现了object,表示函数返回一个**对象**类型的值。返回值为8位的寄存器vAA。\n\n4. 数据定义指令\n\n   **数据定义指令用来定义程序中用到的常量，字符串，类等数据。**\n\n   \n\n   const/4 vA, #+B：将数值符号扩展为32位后赋给寄存器vA。\n\n   “const/16 vAA, #+BBBB：将数据符号扩展为32位后赋给寄存器vAA。这里的#+BBBB表示 0x12344等\n\n   const vAA, #+BBBBBBBB：将数值赋给寄存器vAA。\n\n   const/high16 vAA, #+BBBB0000“：将数值右边零扩展为32位后赋给寄存器vAA。\n\n   const-wide/16 vAA, #+BBBB：将数值符号扩展为64位后赋给寄存器对vAA。 \n\n   const-wide/32 vAA, #+BBBBBBBB：将数值符号扩展为64位后赋给寄存器vAA。\n\n    const-wide vAA, #+BBBBBBBBBBBBBBBB：将数值赋给寄存器vAA。\n\n    const-wide/high16 vAA, #+BBBB000000000000：将数值右边零扩展为64位后赋给寄存器vAA。\n\n   const-string vAA, string@BBBB：通过字符串索引构造一个字符串并赋给寄存器vAA。\n\n    const-string/jumbo vAA, string@BBBBBBBB：通过字符串索引（较大）构造一个字符串并赋给寄存器vAA。\n\n    const-class vAA, type@BBBB：通过类型索引获取一个类引用并赋给寄存器vAA。\n\n    const-class/jumbo vAAAA, type@BBBBBBBB：通过给定的类型索引获取一个类引用并赋给寄存器vAAAA。\n\n   这条指令占用两个字节，值为0xooff（Android4.0中新增的指令）。\n\n5. 实例操作指令\n\n   “check-cast vAA, type@BBBB”：check-cast v0 ,\n\n   将vAA寄存器中的对象引用转换成指定的类型。如果失败会报出ClassCastException异常。\n\n   如果类型B指定的是基本类型，对于非基本类型的A来说，运行时始终会失败。\n\n    \n\n   “instance-of vA, vB, ”：\n\n   判断vB寄存器中的对象引用是否可以转换成指定的类型。如果可以vA寄存器赋值为1，否则vA寄存器赋值为0。\n\n    \n\n   “new-instance vAA, type@BBBB”：\n\n   构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器。类型符type指定的类型不能是数组类。\n\n6. 数组操作指令\n\n   数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。\n\n    \n\n   “array-length vA, vB”：\n\n   获取给定vB寄存器中数组的长度并将值赋给vA寄存器。\n\n   数组长度指的是数组的条目个数。\n\n    \n\n   “new-array vA, vB, type@CCCC”：\n\n   构造指定类型（type@CCCC）与大小（vB）的数组，并将值赋给vA寄存器。\n\n    \n\n    “filled-new-array {vC, vD, vE, vF, vG},type@BBBB”： \n\n   构造指定类型（type@BBBB）与大小（vA）的数组并填充数组内容。vA寄存器是隐含使用的，除指定数组的大小外还指定了参数的个数，vC~vG是使用到的参数寄存序列。\n\n    \n\n    “filled-new-array/range {vCCCC ..vNNNN}, type@BBBB”：\n\n   指令功能与“filled-new-array {vC,vD,vE,vF,vG},type@BBBB”相同，只是参数寄存器使用range字节码后缀指定了取值范围 ，vC是第一个参数寄存器，N = A +C -1。\n\n    \n\n   fill-array-data vAA, +BBBBBBBB：\n\n   用指定的数据来填充数组，vAA寄存器为数组引用，引用必须为基础类型的数组，在指令后面会紧跟一个数据表。\n\n7. *异常指令*\n\n   “throw vAA” : 抛出vAA寄存器中指定类型的异常。\n\n8. **跳转指令(重点)**\n\n   跳转指令用于从当前地址跳转到指定的偏移处。\n\n   **Dalvik****指令集中有三种跳转指令**：\n\n   1. goto：无条件跳转\n\n   2. switch：分支跳转\n\n      ​    packed-switch：有规律跳转\n\n      ​\tsparse-switch: 无规律跳转\n\t3.  if：条件跳转    \n\n   ​    if-eq：等于**/**if-ne：不等于\n\n   ​    if-lt：小于**/**if-le：小于等于\n\n   ​    if-gt：大于**/**if-ge：大于等于\n\n   ​    if-eqz：等于0**/**if-nez：不等于0\n\n   ​    if-ltz：小于0**/**if-lez：小于等于0\n\n   ​    if-gtz：大于0**/**if-gez：大于等于0\n\n9. 比较指令(cmp)\n\n    **比较指令用于对两个寄存器的值（浮点型或长整型）进行比较。**\n\n    **大于(1)/等于(0)/小于(-1)=>cmpg、cmp**\n\n    **大于(-1)/等于(0)/小于(1)=>cmpl**\n\n    \n\n    例如：cmp-long vAA, vBB, vCC\n\n   ​    比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小则结果为-1。\n\n    \n\n    例如：cmpl-float vAA, vBB, vCC\n\n   ​      比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n    \n\n    例如：cmpl-double vAA, vBB, vCC\n\n   ​    比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n   \n\n    例如：cmpg-float vAA, vBB, vCC\n\n      比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n    \n\n   例如：cmpg-double vAA, vBB, vCC\n\n   ​    比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n10. 字段操作指令\n\n     普通字段 => iget读 / iput 写\n\n     静态字段 => sget读 / sput 写\n\n11. 方法调用指令(重点)\n\n    **根据方法类型不同，共有5条方法调用指令**\n\n    \n\n     invoke-virtual ：调用实例的虚方法\n\n     invoke-super ：调用实例的父类/基类方法\n\n     invoke-direct ：调用实例的直接方法\n\n     invoke-static ：调用实例的静态方法\n\n     invoke-interface ：调用实例的接口方法\n\n12. 数据转换指令\n\n    **数据转换指令用于将一种类型的数值转换成另一种类型。**\n\n    **它的格式为“opcode vA, vB”，vB寄存器存放需要转换的数据，转换后的结果保存在vA寄存器中。**\n\n     \n\n     neg-数据类型 **=>** 求补\n\n     not-数据类型 **=>** 求反\n\n     数据类型1-to-数据类型2 **=>** 将数据类型1转换为数据类型2\n\n13. 数据运算指令\n\n     add/sub/mul/div/rem  加/减/乘/除/模\n\n     and/or/xor 与/或/异或\n\n     shl/shr/ushr  有符号左移/有符号右移/无符号右移\n\n# 参考文献\n\n[深入理解Dalvik字节码指令及Smali文件](https://blog.csdn.net/dd864140130/article/details/52076515)","tags":["逆向"],"categories":["Reverse"]},{"title":"人人登录协议分析","url":"%2F2020%2F05%2F18%2F%E9%80%86%E5%90%91%2F%E5%8D%8F%E8%AE%AE%2F%E4%BA%BA%E4%BA%BA%E5%8D%8F%E8%AE%AE%2F","content":"\n# 人人登录协议分析\n\n拿到一个app 首先是要熟悉他的保护，然后在一步一步攻克。\n\n\n\n这次分析的app 没有加壳，所以直接进入分析阶段。\n\n\n\n1. 查看登录流程\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115359.png)\n\n   \n\n   可以看到 ajax 请求，在登录前请求了一个加密key，之后有个login请求，请求中密码加密了，还有sig等等，这次就只分析密码加密过程\n\n2. 打开ddms 方法剖析\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115623.png)\n\n   查看renren相关的方法， 发现一个特别的方法，追进去查看\n\n3. 打开jadx 搜索具体方法\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115757.png)\n\n   图中可以看到有个登录请求，看来方向正确，D函数应该是RSA加密方法，那么确定好后进行hook\n\n4. xposed模块编写\n\n   具体创建之类就不写了，附上代码\n\n   ```\n   public class renren implements IXposedHookLoadPackage {\n       public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {\n           Log.d(\"xiaomutou\", \"进入hook函数......\");\n   \n   \n           if (lpparam.packageName.equals(\"com.renren.mobile.android\")) {\n               Log.d(\"xiaomutou\", \"app包名：\" + lpparam.packageName);\n   \n               final Class clazz = XposedHelpers.findClass(\"com.renren.mobile.utils.RSA\", lpparam.classLoader);\n   \n               XposedHelpers.findAndHookMethod(clazz,\n                      \"D\",\n                       String.class,\n                       String.class,\n                       String.class,\n                       new XC_MethodHook(){\n   \n                           protected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n                               super.beforeHookedMethod(param);\n   \n                               Log.d(\"xiaomutou\", \"打印hook参数前变量\");\n                               Log.d(\"xiaomutou\", \"第一个参数\"+param.args[0]);\n                               Log.d(\"xiaomutou\", \"第二个参数\"+param.args[1]);\n                               Log.d(\"xiaomutou\", \"第三个参数\"+param.args[2]);\n                           }\n   \n                           protected void afterHookedMethod(MethodHookParam param) throws Throwable {\n                               super.afterHookedMethod(param);\n   \n                               Log.d(\"xiaomutou\", \"返回加密后的pwd\");\n   \n                               param.getResult();\n                               Log.d(\"xiaomutou\",\"返回值\"+param.getResult());\n   \n                           }\n                       }\n               );\n           }\n       }\n   }\n   ```\n\n   在方法执行前打印 调用的参数， 在方法执行后打印密码加密后的值，并输出\n\n5. 结果\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518120148.png)","tags":["逆向"],"categories":["Reverse"]},{"title":"shuqi小说去除签名校验","url":"%2F2020%2F05%2F02%2F%E9%80%86%E5%90%91%2F%E7%A0%B4%E8%A7%A3%2Fxx%E5%B0%8F%E8%AF%B4%E5%8E%BB%E9%99%A4%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%2F","content":"\n# 书旗小说去除签名校验\n\n# shuqi小说去除签名校验\n\n## 使用工具\n\nandorid killer 、 jadx 、雷电模拟器\n\n## 去除过程\n\n1. 老规矩，重签名打包 顺便打开ddms 随时关注报错信息\n\n   发现打开了activity 之后就自动关闭了，这里呢就考虑到了入口页面和入口点， apk进行到了入口页面处了，之后才关闭，那就不需要动态调试了，定位到oncreate处\n\n2. 关键字搜索（尝试新方法搜索）\n\n   先换个思路，这里试试关键字搜索，看能找到有用的信息不：方法是逐个加log输出，看看那个调用后就崩溃了\n\n   打开android killer 搜索Signatures，然后逐个加log ，很多明显不是自己的可以忽略\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502095534676.png)\n\n3. 之后编译 安装，ddms捕获消息\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104723497.png)\n\n4. 回到andoridkiller中搜索这个字符串\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104737122.png)\n\n5. 看到了签名三兄弟出没，那么这块肯定有签名了，\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104944334.png)\n\n6. 这里就很明显了，看到了killprocess，绕过方式： 使得if判断为真，将eq改为ne 成功绕过\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502105402616.png)\n\n7. 成功绕过签名校验\n\n   \n\n","tags":["破解"],"categories":["Reverse"]},{"title":"霸哥磁力搜索去签名校验","url":"%2F2020%2F05%2F01%2F%E9%80%86%E5%90%91%2F%E7%A0%B4%E8%A7%A3%2F%E9%9C%B8%E5%93%A5%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2%E5%8E%BB%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%2F","content":"\n\n\n## 案例1 霸哥磁力搜索\n\n首先 签名校验不止一个，所以会经历无数次安装， \n\n1. 重签名打包，安装查看是否有签名校验（这里可以通过启动界面返回的信息查看）\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501192911937.png)\n\n   \n\n   安装 如果有检测 进入第二步\n\n   比如 下面的情况\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193008226.png)\n\n2. 检测是否有加固 \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193159772.png)\n\n   有加固进入第三步\n\n   没有加固进入第四步\n\n3. 有加固 ，先脱壳修复\n\n4. 查看处理的地方，干掉存在签名校验的地方\n\n   ok 接下来分析他在哪校验的\n\n   工具的话： andorid killer 、 jadx 、ida、ddms\n\n   \n\n   先看看刚才程序崩溃是什么情况导致的\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193504305.png)\n\n   使用android killer 加载apk，同时使用jadx 加载，配合查看函数\n\n   根据崩溃原因，判断检测应该是在刚开始打开apk就执行的，所以第一步找到MainActivity.smail\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193941917.png)\n\n   接下来逐个阅读逻辑，配合jadx 查看方法是否有检测校验，（存在getPackageManager、PackageManager、getPackageInfo称为签名三兄弟，如果出现这三个函数就肯定有签名校验 ）\n\n   发现存在方法\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194338764.png)\n\n   在qian()方法中找到熟悉的内容 刚刚我提到的签名三兄弟\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194550120.png)\n\n   绕过方法： 注释\n\n   回到刚才调用的位置 \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194636111.png)\n\n   打包签名安装，之后测试（记得 保存）\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194832345.png)\n\n   发现崩溃在了JNI_onload处  调用了libbug.so 那么猜测这里可能存在so层的校验,找一下是否有这个调用so的操作\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195203094.png)\n\n   继续往下看的时候发现有个调用bug()的方法，找不到bug方法的函数\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195231400.png)\n\n   看到这个就知道方法定义在so层，将so文件拖入ida中，先看看jni_onload 发现没有，那么就是静态注册了，\n\n   找找Java下划线开头的方法，只有一个Java_ xxx _bug 那么肯定就是这个了\n\n   大概意思就是在搜索前会获取一个sign值，之后返回结果，跟进getSignHashCode 看看\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195549371.png)\n\n   这个是getSignHashCode  方法的内容， 看到了三兄弟那就没跑了，这里还存在一个校验。最后会判断一个result的值，然后如果判断成功 也就是result 不等于226776851 就会exit(0) 退出\n\n   \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195758064.png)\n\n   绕过方法： 使得判断为假，或者使得exit（0）不执行 将判断改成不等于\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501201706668.png)\n\n   之后保存即可 保存方式：edit->patch program-> apply patches to input file...\t\n\n   ok 修改成功。\t\t\t\t\t\t\t \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501203303590.png)","tags":["破解"],"categories":["Reverse"]},{"title":"去某游戏app广告","url":"%2F2020%2F03%2F31%2F%E9%80%86%E5%90%91%2F%E7%A0%B4%E8%A7%A3%2F%E5%8E%BB%E6%9F%90app%E5%B9%BF%E5%91%8A%2F","content":"\n\n\n# 去某app广告\n\n刚开始学逆向，难度大的不好掌握，找一些难度较小的先来学习\n\n今天的目标就是去广告\n\n这款app每次开启都会有一个5秒的广告 特别烦人，为了享受游戏带来的乐趣，我要修改某些参数使这个广告消失\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331155910290.png)\n\n## 环境\n\n手机或者模拟器（用来检验成果）\n\nAndroidKiller\n\nadb\n\n## 正文\n\n首先 这里说明一个命令 `adb shell dumpsys activity top` 获取当前界面的activity\n\n这块圈出来的就是调用app的广告activity\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331160858079.png)\n\n打开`AndroidKiller`查看当前获取到的activity，定位到`com.mosads.adslib.Splash.MosSplashActivity`处,\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161253393.png)\n\n我把这段activity copy出来了，看到在他的activity中包含了Main 和Launcher 两个东东，他表示的时开始界面，那么就清楚了，每次启动都会从这广告界面开始\n\n```\n<activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"com.mosads.adslib.Splash.MosSplashActivity\" android:screenOrientation=\"landscape\" android:theme=\"@style/AppTheme.NoActionBar\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n```\n\n接下来是我们去广告的重点了，找到程序真正的主界面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161644990.png)\n\n定位到主界面的activity处\n\n```\n</intent-filter>\n        </activity>\n        <activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"org.cocos2dx.lua.AppActivity\" android:screenOrientation=\"landscape\" android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <action android:name=\"MosSplashActivityToTarget\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n            </intent-filter>\n\n```\n\n可以看到只有Main 而没有Launcher 这时候就可以将刚才的Launcher 复制到真正的主界面中，并且删除广告里面的main和Launcher就可以毁掉广告页面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161959616.png)\n\n\n\n还有一种去广告的方法， 可以通过删除网络权限去广告，这个后面遇到会提出来。\n\n---\n\n今天的去广告就结束了，如果想要尝试的话，可以私我要app\n\n\n\n\n\n","tags":["破解"],"categories":["Reverse"]},{"title":"CTF-androideasy","url":"%2F2020%2F03%2F25%2F%E9%80%86%E5%90%91%2FCTF%2Fandroideasy%2F","content":"\n\n\n# 题目：androideasy\n\n最近刚学了点逆向技能，找一些简单的ctf 题目来验证一下效果\n\n下载地址：[androideasy](https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy)\n\n## 解题思路\n\n首先拿到的是个zip文件，打开是个普通的apk目录\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160159860.png)\n\n也不知道做逆向的和做安全的看到他的感觉是否一样，\n\n修改后缀为`apk` 后扔到jadx中，然后在往模拟器中扔一份\n\n模拟器中可以看到 很简单的功能，输入字符 。点击check 判断是否输入正确\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160654280.png)\n\n之后查看jadx\n\n大概确定一下，就是需要输入一个字符串在check判断通过即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160744208.png)\n\n\n\n定位到check，输入的字符串必须让if判断为真，也就是进入到check的true\n\n```\nprivate byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};\n\npublic boolean check() {\n        byte[] chars = this.editText.getText().toString().getBytes();\n        if (chars.length != this.f21s.length) {\n            return false;\n        }\n        int i = 0;\n        while (i < this.f21s.length && i < chars.length) {\n            if (this.f21s[i] != (chars[i] ^ 23)) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n```\n\n接下来写firda 代码\n\n```\nfunction flag() {\n    Java.perform(function () {\n        var flag1 = Java.use(\"com.a.sample.androidtest.MainActivity\");\n        flag1.check.implementation = function () {\n             var retval = this.check();\n             console.log(retval)\n             return true;\n        }\n    })\n}\n\n\nfunction main() {\n    flag()\n}\n\nsetImmediate(main);\n```\n\n这样就可以保证返回为真了\n\n回到正题，前台返回为真对flag没有帮助，\n\n所以还是得得到`f21s` ,写个脚本 获得下面的字符串\n\n`private byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};`\n\n最后的脚本\n\n```python\nf21s = [113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106]\nprint(len(f21s))\nflag = \"\"\n\nfor  i in range(0,len(f21s)):  # 判断每一位，一共判断f21s 长度次\n    for j in range(0,127):\n        if (f21s[i] == (j ^ 23)):\n            flag += chr(j)\n\nprint(flag)py\n```\n\n```\n31\nflag{It_1S_@N_3asY_@nDr0)I)1|d}\n```\n\n","tags":["CTF"],"categories":["Reverse"]},{"url":"%2F2020%2F03%2F24%2F%E9%80%86%E5%90%91%2FXposedFridaHook%E7%B3%BB%E5%88%97%2FHook%E5%BC%80%E5%A7%8B%2F","content":"# Hook 通杀\n\n## Hook 普通方法和修改函数参数返回值\n\nfradaserver 是手机端的，\n\n1. android低版本 frida 尽量低版本\n2. fridaserver版本要与frida库版本一致\n3. 不同平台用不同fridaserver\n4. 不要和xposed装一起，新疆模拟器，刷机\n\n设备要求:\n\n​\troot\n\n \t调试\n\n下载frida-server push到手机中 (注意查看手机是86的还是64的)\n\n` adb push .\\frida-server-12.8.14-android-x86 /data/local/tmp/fsx86`\n\n![image-20200319214805400](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200319214805400.png)\n\n之后cd到tmp目录下\n\n先给fsx86 赋权  `chmod 777 fsx86`\n\n之后执行即可。 `./fsx86`\n\n执行后有一个报错，这里是版本出现的问题，会有一些小bug ，不影响使用，最好还是在真机中调试\n\n`WARNING: linker: ./fsx86: unused DT entry: type 0x6ffffef5 arg 0x1c24`\n\n## 插入一个学习\n\n![image-20200320103048870](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320103048870.png)\n\nHook 构造方法\n\n​\t绕过一些验证\n\n​\t构造方法\n\n​\t`money.$init.implementation = function(){}`\n\nHook 重载方法\n\n![image-20200320105658343](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320105658343.png)\n\nHook 重载方法\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test();\n        console.log(a, retval);\n        return retval;\n    };\n    utils.test.overload().implementation = function () {\n        var retval = this.test();\n        console.log(retval);\n        return retval;\n    };\n    utils.test.overload('com.xiaojianbang.app.Money').implementation = function (a) {\n        var retval = this.test(a);\n        console.log(retval);\n        return retval;\n    }\n}\n\n```\n\nHook 所有重载方法\n\n```\nfunction hookTest3() {\n    // hook 方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length);\n    for (var i = 0; i < utils.test.overloads.length; i++) {\n        utils.test.overloads[i].implementation = function () {\n            // console.log(JSON.stringify(arguments));\n\n            if (arguments.length == 0) {\n                return \"调用没有参数的\";\n            } else if (arguments.length == 1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1){\n                    return \"调用了Money参数的\";\n                }else{\n                    return \"调用了Int 类型的\";\n                }\n            }\n\n                arguments[0] = 1000;\n            // console.log(arguments.length);\n            // apply 改变所属\n            return this.test.apply(this, arguments);\n        }\n    }\n}\n```\n\nHook 构造参数与对象实例化\n\n![image-20200321172539738](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321172539738.png)\n\n![image-20200321173626852](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321173626852.png)\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test(money.$new(\"日元\", 1000000)); // 对象实例化\n        console.log(a, retval);\n        return retval;\n    };\n```\n\n\n\n\n\nhook 实例化\n\n\n\n![image-20200321174929718](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321174929718.png)\n\n```\nfunction hookTest5() {\n    Java.perform(function () {\n        //静态字段的修改\n        var money = Java.use(\"com.xiaojianbang.app.Money\");\n        //send(JSON.stringify(money.flag));\n        money.flag.value = \"ceshi\";\n        console.log('log', money.flag.value);\n        // 非静态字段的修改\n        Java.choose(\"com.xiaojianbang.app.Money\", {\n            onMatch: function (obj) {\n                obj._name.value = \"ouyuan\"; // 字段与函数名相同， 前面加下划线\n                obj.num.value = 15254131;\n            },\n            onComplete: function () {\n\n            },\n        });\n    });\n}\n```\n\n\n\n 获取所有的类\n\n```\nfunction hookTest7() {\n    Java.perform(function () {\n        Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) {\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name);\n                    var clazz = Java.use(name);\n                    var methods = clazz.class.getDeclaredMethods();\n                    console.log(methods)\n                    for (var i = 0 ; i< methods.length;i++){\n                        console.log(methods[i]);\n                    }\n                }\n            },\n            onComplete:function () {\n\n            },\n        });\n\n```\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0 ; i < classes.length ; i++){\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1){\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0 ;j < methods.length ;j++){\n            console.log(methods[j]);\n        }\n    }\n\n\n}\n```\n\n# Hook 回笼重造\n\n<img src=\"E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324171350015.png\" alt=\"image-20200324171350015\" style=\"zoom:50%;\" />\n\n> xposed 框架替换了很多文件，如果要从xposed转frida 需要刷机\n\n修改debuggable 参考：https://www.bodkin.ren/index.php/archives/533/\n\n```\n[Go0s]: ~/Security/_Tools/Android/mprop/armeabi-v7a ✗ master*\n➜  adb push mprop /data/local/tmp              \nmprop: 1 file pushed. 1.6 MB/s (17712 bytes in 0.011s)\n[Go0s]: ~ \n➜  adb shell\nshell@hammerhead:/ $ cat default.prop | grep debug                             \nro.debuggable=0\nshell@hammerhead:/ $ getprop ro.debuggable\n0\nshell@hammerhead:/ $ cd /data/local/tmp\nshell@hammerhead:/data/local/tmp $ su\nroot@hammerhead:/data/local/tmp # ./mprop ro.debuggable 1   \nproperties map area: b6f7a000-b6f9a000\n00000000  08 8d 00 00 19 01 00 00 50 52 4f 50 ab d0 6e fc  ........PROP??n?\n00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n……\nroot@hammerhead:/ # cat default.prop | grep debug                              \nro.debuggable=0\nroot@hammerhead:/ # getprop ro.debuggable                                      \n1\n```\n\n版本太高导致的问题，问题不会大\n\n![image-20200324192712444](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324192712444.png)\n\n配置代码提示\n\n```npm i @types/frida-gum```\n\n\n\nhook步骤\n\n1. 进入手机终端 启动 fsx86\n2. 端口转发\n3. 使用命令开始hook吧 `frida -U 包名 -l hook代码`\n\n### 逻辑分析\n\n要hook getCalc 方法，定位到函数声明\n\n![image-20200324201846328](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201846328.png)\n\n定位到getCalc  方法有两个参数 a,b \n\n![image-20200324201919870](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201919870.png)\n\n### Hook普通方法\n\n接下来根据这个函数开始hook\n\n​\t`var utils = Java.use(\"com.xiaojianbang.app.Utils\");` 定位函数\n\n​\t重写方法 implementation \n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n\t// 先打印一下a,b 参数和返回的参数\n    var retval = this.getCalc(a,b); \n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n​\t点击普通方法，即可在frida中看到获取的参数\n\n![image-20200324202244461](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324202244461.png)\n\n之后修改a ，b 参数\n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n    a = 123;\n    b = 345;\n\n    var retval = this.getCalc(a,b);\n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n![image-20200324203353529](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324203353529.png)\n\n\n\n### Hook 重载方法和重载方法的Hook\n\n重载方法和一般普通方法区别不大\n\n![image-20200324205305292](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205305292.png)\n\n当使用之前的方法 去hook重载方法\n\n![image-20200324205229878](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205229878.png)\n\n需要使用overload 去指定参数\n\n```\n    utils.test.overload('int').implementation = function (a, b) { // implementation 是重写方法， js中不需要函数类型\n\n```\n\n最后hook所有的重载方法\n\n只要符合返回值，可以随意改的，即使调用其他的重载函数也是可以执行\n\n```\nutils.test.overload('int').implementation = function (a) { // implementation 是重写方法， js中不需要函数类型\n    a = 888888888;\n    var retval = this.test(a);\n    console.log(a, retval);\n    return retval;\n};\nutils.test.overload().implementation = function () {\n    var retval = this.test();\n    console.log(\"无参：\",retval);\n    return retval;\n};\nutils.test.overload(\"com.xiaojianbang.app.Money\").implementation = function (a) {\n    var retval = this.test(a);\n    console.log(a,retval);\n    return retval;\n};\n```\n\nHook所有重载函数\n\n```\nfor (var i = 0 ;i < utils.test.overloads.length;i++){ // 通过for 循环去获取每一个\n    utils.test.overloads[i].implementation = function () {\n        console.log(arguments); // arguments 是一个数组\n    }\n}\n```\n\n通过apply 可以避免每次返回需要改变返回参数的问题\n\n```\nthis.test.apply(this,arguments) // apply 是改变函数所属\n```\n\n>  在frida 中，在同位置下多个钩子 最后一个会生效，因为他的代码会覆盖之前的代码。\n\n返回hook每个重载函数 参数长度\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n返回结果\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324213234513.png)\n\n如果需要修改其中的某个重载函数 则需要在这里做一个判断\n\n```\nif (arguments.length == 0){\n    return \"xiaojianbang\";\n}\n```\n\n\n\nhook 完整代码\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n            if (arguments.length == 0){\n                return \"xiaojianbang\";\n            }else if (arguments.length ==  1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1 ){\n                    return \"调用了Money参数\";\n                } else{\n                    return \" 调用了int参数的\";\n                }\n            }\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n## Hook 构造函数与对象实例化\n\n这里的`Money` 是我们的构造函数 函数与类型一致 \n\n![image-20200324215249350](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215249350.png)\n\n也需要指明\n\n![image-20200324215639928](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215639928.png)\n\n构造函数和重载只是多了个 $init\n\n```\nfunction hookTest4() {\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n    // 函数名与方法名一致\n    money.$init.overload('java.lang.String','int').implementation = function (str,num) {\n        console.log(str,num);\n        this.$init(str,num);\n    }\n}\n```\n\n在上一节重载函数，我们调用了money ，但是当我们要修改其中的值时 需要调用money的包\n\n![image-20200324220110549](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220110549.png)\n\n在函数开始位置添加\n\n![image-20200324220151168](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220151168.png)\n\n这就完成了一个实例化\n\n![image-20200324220241983](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220241983.png)\n\n## 修改类的字段\n\n先尝试hook一下静态资源\n\n```\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nconsole.log(JSON.stringify(money.flag.value));\n```\n\n> 多个对象就会有多个字段，所以要修改 必须找到对应的字段\n\n修改字段\n\n```\n// 静态字段\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nmoney.flag.value = \"xiaojianbang\";\n\nconsole.log(JSON.stringify(money.flag.value));\n```\n\nhook 修改非静态字段\n\n> 正常的每次修改都会new一个对象，所以看不到返回的值\n\n![image-20200324222948009](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324222948009.png)\n\n```\nJava.choose(\"com.xiaojianbang.app.Money\", {\n    onMatch: function (obj) { // 每次遍历对象都会调用一次onMatch\n        // 修改对象参数，如果修改单个 价格判断即可\n        obj._name.value = \"ouyuan\"; // 这块注意字段名与函数名是否相同\n        obj.num.value = 15000000;\n    },\n    onComplete: function () {\n\n    }\n});  // cakkbacks指的是对象\n```\n\n> 这块注意 当字段名与函数名相同 要加`_`来区分\n\n## hook 内部类和匿名类\n\n当hook 类下的类 hook方法\n\n可以通过jeb smail 去看 \n\n![image-20200324230631123](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324230631123.png)\n\nmoney 只是一个父类，匿名类是getInfo 这里实现了一次， 匿名类一般都是$1 这种形式\n\n![image-20200324231541211](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324231541211.png)\n\n## 枚举所有的类和所有的方法\n\n```\nJava.enumerateLoadedClasses() //枚举类 只能加载 已经被加载的类\n```\n\njava反射获取方法\n\n```\nvar methods = clazz.class.getDeclaredMethods();\n```\n\n获取所有的类\n\n```\nJava.enumerateLoadedClasses({\n    onMatch:function (name,handle) { // 代码都是写在这里的\n        if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n            console.log(name) \n        }\n    },\n    onComplete:function () { // 这里只会使用一次\n\n    }\n})\n```\n\n获取类下的方法\n\n```\n Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) { // 代码都是写在这里的\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name) // 类和地址  打印好多系统类，这里就要做个过滤\n                    // 遍历类下的所有的方法 java 反射 有个getDeclaredMethods\n                    var clazz = Java.use(name);\n                    console.log(clazz);\n                    var methods = clazz.class.getDeclaredMethods(); // 得到的是一个对象，这里要通过class转\n                    //console.log(methods);  // 直接打印输出较乱 做一个整理\n\n                    if (var i = 0; i < methods[i].length;i++){\n                        console.log(methods[i]);\n                    }\n                    console.log()\n\n\n\n                }\n            },\n            onComplete:function () { // 这里只会使用一次\n\n            }\n        })\n```\n\n异步方式获取类和类的方法\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0; i < classes.length; i++) {\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1) {\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0; j < methods.length; j++) {\n            console.log(methods[j]);\n        }\n    }\n}\n```\n\n## hook类的所有方法\n\n首先确定hook那个类， 比如md5，之后通过java反射 获取类下的方法\n\n```\nvar md5 = Java.use(\"com.xiaojianbang.app.MD5\");\nvar methods= md5.class.getDeclaredMethods();\n```\n\n之后通过循环返回打印\n\n```\nfunction hookTest8() {\n    Java.perform(function () {\n        var md5 = Java.use(\"com.xiaojianbang.app.MD5\");\n        var methods = md5.class.getDeclaredMethods();\n        for (var i = 0; i < methods.length; i++) {\n            var methodName = methods[i].getName();\n            console.log(methodName);\n            for (var k = 0; k < md5[methodName].overloads.length; k++) {\n                md5[methodName].overloads[k].implementation = function () {\n                    for (var j = 0; j < arguments.length; j++) {\n                        console.log(arguments[j]);\n                    }\n                    return this[methodName].apply(this, arguments) // 不知道返回的对象\n                }\n            }\n\n        }\n    })\n}\n```\n\n## 动态加载dex\n\n遇到问题： 在调用函数后，有些dex 是通过动态加载调用的，反编译并不会反编译到所有的dex\n\n一般可以通过DexClassLoader动态加载，或者通过so层 或者内存中去加载\n\n这里通过DexClassLoader去加载，文件放在apk的目录中\n\n![image-20200325214341078](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214341078.png)\n\n当直接调用就会报错\n\n```\nfunction hookTest9() {\n    Java.perform(function () {\n        var dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n        console.log(dynamic);\n    })\n}\n```\n\n![image-20200325214906826](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214906826.png)\n\n这里就要找到对应的classloader  \n\n> 注意：这个api是要在7版本以上使用，用android5 可能会报错\n\n```\nfunction hookTest9(){\n    Java.perform(function(){\n\n        Java.enumerateClassLoaders({\n            onMatch: function(loader){\n                try {\n                    if(loader.loadClass(\"com.xiaojianbang.app.Dynamic\")){\n                        Java.classFactory.loader = loader;\n                        var Dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n                        console.log(Dynamic);\n                        Dynamic.sayHello.implementation = function(){\n                            return \"xiaojianbang\";\n                        }\n                    }\n                } catch (error) {\n\n                }\n            }\n            ,\n            onComplete: function(){\n\n            }\n        });\n    });\n}\n```\n\n![image-20200326091943750](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200326091943750.png)\n\n\n\n> Java.classFactory.loader = loader; 这里的loader 可能会报错 不影响正确性\n\n\n\n## Java 里特殊类型的遍历与修改\n\nHook map 或者修改其中的某些值\n\n\n\n![image-20200329001310423](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001310423.png)\n\n![image-20200329001325832](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001325832.png)\n\n这块可以使用show（java的代码） 去hook\n\n可以将show方法 直接copy过去，但是要注意里面的函数要遵守js的语法\n\n这块要使用迭代器去获取map\n\n```\n不要调用伪代码的方法，而是去自写\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n\n            var key = map.keySet();\n            var it = key.iterator();\n            var result = \"\";\n            while (it.hasNext()) {\n                var keystr = it.next();\n                var valuestr = map.get(keystr);\n                result += valuestr;\n            }\n        console.log(result);\n        return result;\n\n        }\n    })\n}\n```\n\n之后是java 特殊类型的修改\n\n```\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n        // 2 修改特殊方法\n            map.put(\"pass\",\"zygx8\");\n            map.put(\"xxxx\",\"www.zygx8.com\");\n            var retval = this.show(map);\n            console.log(retval);\n            return retval;\n\n        }\n    })\n}\n```\n\n## Java 层主动调用函数\n\n只有当函数被触发才会被执行，那么当我们需要解密一个比较复杂的算法，是可以通过主动调用函数去获取的\n\n静态主动调用\n\n```\n调用rsa方法\nfunction hookTest11() {\n    Java.perform(function () {\n        var rsa = Java.use(\"com.xiaojianbang.app.RSA\");\n        var str = Java.use(\"java.lang.String\");\n        var base64 = Java.use(\"android.util.Base64\");\n        var bytes = str.$new(\"xioajianbang\").getBytes();\n        console.log(bytes);\n        var retval = rsa.encrypt(bytes);\n        console.log(retval);\n        var result = base64.encodeToString(retval,0);\n        console.log(result);\n    })\n}\n```\n\n非静态方法的主动调用 调用getinfo\n\n```\n Java.use(\"com.xiaojianbang.Money\").$new(\"欧元\",3000000).getInfo();\n```\n\n\n\n## Java 打印函数堆栈\n\n之前使用Log.d 来打印信息\n\n![image-20200330115446399](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200330115446399.png)\n\n推荐： 使用`Log.getStack.TrachString(new Throwable())` 或``Log.getStack.TrachString(new exception())``\n\n```\nfunction hookTest12() {\n    // 写一个函数堆栈\n    function showStacks(){\n        console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n        //console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    }\n    Java.perform(function () {\n        //Java.cast();\n        //Java.openClassFile();\n        var MessageDigest =  Java.use(\"java.security.MessageDigest\");\n        MessageDigest.digest.overload().implementation = function () {\n            showStacks();\n            return this.digest();\n\n        }\n    })\n}\n```"},{"title":"Andorid Studio 安装报错 解决","url":"%2F2020%2F03%2F10%2F%E9%80%86%E5%90%91%2Fandroidstudio%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%2F","content":"\n\n\n# Andorid Studio 安装报错 解决\n\n\n\n## 小记\n\n安装了一下午的AndroidStudio 一直报错，安装不上sdk 实在头疼，查到资料改个hosts就搞定了，舒服\n\n\n\n将这两个写入`c:\\users\\你电脑的名字\\drivers\\etc\\hosts`中 即可解决 不挂代理轻松安装sdk\n\n```\n203.208.43.101 dl-ssl.google.com\n203.208.43.101 dl.google.com\n```\n\n\n\n","tags":["逆向"],"categories":["Reverse"]},{"title":"python第一课 数据结构和算法","url":"%2F2020%2F02%2F27%2F%E7%BC%96%E7%A8%8B%2Fpython%2Fpython%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F","content":"\n# python第一课 数据结构和算法\n\n> 注： 本文是对照https://python3-cookbook.readthedocs.io/ 学习 总结笔记 \n\n\n\n## 1.1  解压序列复制给多个变量\n\n**问题**\n\n现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？\n\n**解决方案**\n\n**元组**：元组使用小括号与列表非常相似，创建元组只需要 `tup = (1,2,3,4,5,6)`,通过逗隔开即可；查看当前变量是否属于元组可以通过`type(tup)` 来获取变量类型；并且 元组也可以通过 tup = \"a\",\"b\",\"c\" 这样来实现；元组只包含一个元素，需要在元素后面添加逗号，否则会被当做运算符使用。\n\n**序列**：python中的序列一般指 字符串，列表，元组。python在序列中可以进行索引、切片、加、乘、检查成员、确定最大最小元素，\n\n**字符串**： python的字符串我在介绍中也说了， 通过 变量 等于 用引号包括的值即可，例如：\n\nvar = \"St0n5\"\n\n**列表**： 和元组类似，千万不要混淆了， 通过 list = ['ceshi1','ceshi2'] 来创建\n\n\n\n接下来开始解决问题\n\n```\n# 将p赋值给变量，注意变量的数量要和序列的数量相同\n# python 可以通过多变量赋值实现 同时对多个变量的赋值\n>>> p =(4,5)\n>>> x,y=p\n>>> x\n4\n>>> y\n5\n# 接下来 放一个列表试试\n>>> data = ['python','C','中国加油',52.0,(2020,2,26)]\t\t    \n>>> code1,code2,num1,num2,data1=data\t\t    \n>>> code1\t\t    \n'python'\n>>> code2\t\t    \n'C'\n>>> num1\t\t    \n'中国加油'\n>>> num2\t\t\t    \n52.0\n>>> data1\t\t    \n(2020, 2, 26)\n```\n\n**讨论**\n\n上面展示了都是序列元素和元素一样的情况，那如果只需要其中的一部分元素 应该怎么去做，\n\n文章中提供了一种方法是使用任意变量名占位，之后丢掉就好，\n\n还可以通过下标来输入某个元素 也可以达到解压一部分的目的。\n\n## 1.2 解压可迭代对象赋值给多个变量\n\n**问题**\n\n如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 `ValueError` 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？\n\n**解决方案**\n\n**容器**: 把多个元素组织在一起的数据结构，当它可以用来询问某个元素是否包含在其中时，就可以理解为这是一个容器\n\n**迭代对象**：很多容器都是可迭代对象，但凡是可以返回一个迭代器的对象都可称之为可迭代对象\n\n**迭代器**： 它是一种带状态的对象，通过`next()`方法调用返回容器的下一个值，迭代器就是工厂模式的对象。\n\n**生成器**： 生成器是一种特殊的迭代器，生成器可以用更少的中间变量些流式代码，此外，相比于其他容器，它能更节省内存和`cpu`，没有返回值，通过`yield`来返回\n\n解决问题\n\n```\n# 解决可迭代对象的元素超过变量个数 ，可以用 * 来解决问题\n>>> record = ('xss','sql','upload','xxe','download')      \n>>> first,*middle,last = record      \n>>> first\t      \n'xss'\n>>> middle      \n['sql', 'upload', 'xxe']\n>>> last      \n'download'\n# middle 永远都是列表类型，元素为空也是如此， 并且 * 表达式 可以用在任何位置。\n```\n\n扩展的迭代语法是为了解压不确定个数或者任意个数的元素的可迭代对象设计的，通常可迭代对象都是有一定规律的， 有时 `*`表达式也可以用来做字符串的分割，\n\n```\n>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'\n>>> uname, *fields, homedir, sh = line.split(':')\n>>> uname\n'nobody'\n>>> homedir\n'/var/empty'\n>>> sh\n'/usr/bin/false'\n>>>\n```\n\n当然，如果你想要的解压一些元素并丢弃他们，你可以用`*_`这样来表示废弃\n\n\n\n\n\n未完待续 ...\n\n\n\n\n\n---\n\n参考链接：\n\nhttps://foofish.net/iterators-vs-generators.html\n\nhttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html\n\n","tags":["python"],"categories":["Code"]},{"title":"python 入门简介","url":"%2F2020%2F02%2F26%2F%E7%BC%96%E7%A8%8B%2Fpython%2Fpython%E4%BB%8B%E7%BB%8D%2F","content":"\n# python 简介\n\n\n\n为了完成毕设 努力学习python\n\n\n\n* python 是一种解释型语言\n* pyhton 是交互式语言\n* python是面向对象语言\n* python是初学者语言 很简单\n\n\n\n## 0x01 python区分\n\n只要有python2 和python3 之分\n\n\n\n## 0x02 python的特点\n\n这就不提了 全是优点\n\npython大法好\n\n## 0x03 python 变量类型\n\n### 字符串\n\n一般由数字、字母、下划线组成\n\n```\nstr = 'xxxx'\n```\n\n**方法**\n\n\n\n## 列表\n\n支持字符、数字、字符串 甚至可以包含列表（嵌套）\n\n```\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n```\n\npython中支持数据类型和类型的`连接`和`重复`操作\n\n## 元组\n\n元组用`()`标识，内部元素用逗号隔开。但是元组不能二次赋值，\n\n元组不能通过修改\n\n```\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n```\n\n## 字典\n\n字典也是经常要使用的数据类型之一，和列表相比，列表是有序的对象集合，字典是无需的对象集合，列表是通过偏移存取，而字典是通过键来存取的\n\n```\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'john','code':6734, 'dept': 'sales'}\n```\n\n\n\n\n\n# PythonTip \n\n## 每日一练\n\n**结尾为0的个数**\n\n```\n给你一个正整数列表 L, 输出L内所有数字的乘积末尾0的个数。(提示:不要直接相乘,数字很多,相乘得到的结果可能会很大)。例如： L=[2,8,3,50],则输出：2\n```\n\n我拿到题第以想法就是乘，但无疑会增加算法的时间复杂度，所以，接下来就是分析如何更加简洁的利用\n\n需要的是末尾0的个数，而数字中任何可以得到末尾为0的个数的值都可以化为2x5x某个值\n\n所以接下来只要对每一位数字化一下是否可以通过2或者 5 得到\n\n最后求一下2和5分别有多少个，取最小的那个就可以了 因为2和5都是素数，所以不存在取得的数重复现象\n\n总结一下：求每一个数可以得到几个2和几个5\n\n```\nL =[2,8,3,50]\n\ncount_2 ,count_5= 0,0\n\ndef count_2_5(i,n):\n    num = 0\n    while i % n == 0:\n        i  = i / 2\n        num += 1\n    return num\n\nfor i in L:\n    count_2 += count_2_5(i,2)\n    count_5 += count_2_5(i,5)\n\nprint(min(count_2,count_5))\n```\n\n\n\n\n\n\n\n","tags":["python"],"categories":["Code"]},{"title":"android 安全之环境搭建（一）","url":"%2F2020%2F02%2F05%2F%E9%80%86%E5%90%91%2Fandroid%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F","content":"\n[TOC]\n\n# android 安全（一）\n\n简单的学习做笔记\n\nandroid 现在基本都是以逆向脱壳为主，为了能够更加了解渗透测试，特地学习了一下逆向的基础知识。\n\n# 0x00 环境搭建\n\n不论从事那一方面的研究，第一件事都是搭建一个满意的环境，不然满是bug的环境会让你望而却步。\n\n**硬件要求**\n\n逆向需要的环境对系统要求不高，我自己是个游戏本，完全满足要求，就不需要在硬件上破费了。你只需要一个功能齐全的电脑都可以满足基本的学习要求。\n\n## 必备的一些软件安装\n\n推荐一个android下载站： https://www.androiddevtools.cn/#\n\n1. `jdk` ：这是android开发必备环境之一，由于一些软件限制，我准备的是`jdk-8u121-windows-x64`和`jdk-8u121-windows-i586`,当然也可以下载最新的，但有时会在安装某个软件的时候出现莫名其妙的问题。\n\n2. `android sdk`: （由于已经没有了单独的下载包，所以可以通过下载包含有android sdk 的android studio: 另一种是网上提供下载的链接，这个倒是蛮多的  下载链接：[android studio](https://developer.android.com/studio)）\n\n> 这里说一下android sdk 和android studio的区别\n>\n> Android SDK 是一个开发包。类似于JAVA SDK。里面包含了Android开发的各式各样的库文件。\n> Android studio是一个IDE（可视化开发工具）跟eclipse一样的东西。用来开发Android的工具。(studio 包含有sdk)\n\n3. `android NDK`:`Android NDK` 是一个工具集，可让您使用 C 和 C++ 等语言以原生代码实现应用的各个部分。对于特定类型的应用，这可以帮助您重复使用以这些语言编写的代码库[NDK](https://developer.android.com/ndk/downloads)   之后将ndk 安装的路径添加到`path` 环境变量中即可\n\n4. 开发环境安装 ，这里我安装的是`android studio` 因为`eclipse for Android Developers ` 已经不在维护了。\n\n   \n\n---\n\n刚开始学逆向，好多东西都是一知半解，如果有什么问题或者错误， 还望各位大佬狠狠的批评。","tags":["逆向"],"categories":["Reverse"]}]