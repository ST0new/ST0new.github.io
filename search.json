[{"title":"霸哥磁力搜索去签名校验","url":"%2F2020%2F05%2F01%2F%E9%80%86%E5%90%91%2F%E7%A0%B4%E8%A7%A3%2F%E9%9C%B8%E5%93%A5%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2%E5%8E%BB%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C%2F","content":"\n\n\n## 案例1 霸哥磁力搜索\n\n首先 签名校验不止一个，所以会经历无数次安装， \n\n1. 重签名打包，安装查看是否有签名校验（这里可以通过启动界面返回的信息查看）\n\n   ![image-20200501192911937](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501192911937.png)\n\n   \n\n   安装 如果有检测 进入第二步\n\n   比如 下面的情况\n\n   ![image-20200501193008226](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501193008226.png)\n\n2. 检测是否有加固 \n\n   ![image-20200501193159772](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501193159772.png)\n\n   有加固进入第三步\n\n   没有加固进入第四步\n\n3. 有加固 ，先脱壳修复\n\n4. 查看处理的地方，干掉存在签名校验的地方\n\n   ok 接下来分析他在哪校验的\n\n   工具的话： andorid killer 、 jadx 、ida、ddms\n\n   \n\n   先看看刚才程序崩溃是什么情况导致的\n\n   ![image-20200501193504305](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501193504305.png)\n\n   使用android killer 加载apk，同时使用jadx 加载，配合查看函数\n\n   根据崩溃原因，判断检测应该是在刚开始打开apk就执行的，所以第一步找到MainActivity.smail\n\n   ![image-20200501193941917](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501193941917.png)\n\n   接下来逐个阅读逻辑，配合jadx 查看方法是否有检测校验，（存在getPackageManager、PackageManager、getPackageInfo称为签名三兄弟，如果出现这三个函数就肯定有签名校验 ）\n\n   发现存在方法\n\n   ![image-20200501194338764](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501194338764.png)\n\n   在qian()方法中找到熟悉的内容 刚刚我提到的签名三兄弟\n\n   ![image-20200501194550120](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501194550120.png)\n\n   绕过方法： 注释\n\n   回到刚才调用的位置 \n\n   ![image-20200501194636111](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501194636111.png)\n\n   打包签名安装，之后测试（记得 保存）\n\n   ![image-20200501194832345](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501194832345.png)\n\n   发现崩溃在了JNI_onload处  调用了libbug.so 那么猜测这里可能存在so层的校验,找一下是否有这个调用so的操作\n\n   ![image-20200501195203094](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501195203094.png)\n\n   继续往下看的时候发现有个调用bug()的方法，找不到bug方法的函数\n\n   ![image-20200501195231400](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501195231400.png)\n\n   看到这个就知道方法定义在so层，将so文件拖入ida中，先看看jni_onload 发现没有，那么就是静态注册了，\n\n   找找Java下划线开头的方法，只有一个Java_ xxx _bug 那么肯定就是这个了\n\n   大概意思就是在搜索前会获取一个sign值，之后返回结果，跟进getSignHashCode 看看\n\n   ![image-20200501195549371](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501195549371.png)\n\n   这个是getSignHashCode  方法的内容， 看到了三兄弟那就没跑了，这里还存在一个校验。最后会判断一个result的值，然后如果判断成功 也就是result 不等于226776851 就会exit(0) 退出\n\n   \n\n   ![image-20200501195758064](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501195758064.png)\n\n   绕过方法： 使得判断为假，或者使得exit（0）不执行 将判断改成不等于\n\n   ![image-20200501201706668](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501201706668.png)\n\n   之后保存即可 保存方式：edit->patch program-> apply patches to input file...\t\n\n   ok 修改成功。\t\t\t\t\t\t\t \n\n   ![image-20200501203303590](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\破解\\photo\\image-20200501203303590.png)","tags":["破解"],"categories":["Reverse"]},{"title":"去某游戏app广告","url":"%2F2020%2F03%2F31%2F%E9%80%86%E5%90%91%2F%E7%A0%B4%E8%A7%A3%2F%E5%8E%BB%E6%9F%90app%E5%B9%BF%E5%91%8A%2F","content":"\n\n\n# 去某app广告\n\n刚开始学逆向，难度大的不好掌握，找一些难度较小的先来学习\n\n今天的目标就是去广告\n\n这款app每次开启都会有一个5秒的广告 特别烦人，为了享受游戏带来的乐趣，我要修改某些参数使这个广告消失\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331155910290.png)\n\n## 环境\n\n手机或者模拟器（用来检验成果）\n\nAndroidKiller\n\nadb\n\n## 正文\n\n首先 这里说明一个命令 `adb shell dumpsys activity top` 获取当前界面的activity\n\n这块圈出来的就是调用app的广告activity\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331160858079.png)\n\n打开`AndroidKiller`查看当前获取到的activity，定位到`com.mosads.adslib.Splash.MosSplashActivity`处,\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161253393.png)\n\n我把这段activity copy出来了，看到在他的activity中包含了Main 和Launcher 两个东东，他表示的时开始界面，那么就清楚了，每次启动都会从这广告界面开始\n\n```\n<activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"com.mosads.adslib.Splash.MosSplashActivity\" android:screenOrientation=\"landscape\" android:theme=\"@style/AppTheme.NoActionBar\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <category android:name=\"android.intent.category.LAUNCHER\"/>\n            </intent-filter>\n        </activity>\n```\n\n接下来是我们去广告的重点了，找到程序真正的主界面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161644990.png)\n\n定位到主界面的activity处\n\n```\n</intent-filter>\n        </activity>\n        <activity android:configChanges=\"keyboardHidden|orientation|screenSize\" android:label=\"@string/app_name\" android:name=\"org.cocos2dx.lua.AppActivity\" android:screenOrientation=\"landscape\" android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"/>\n                <action android:name=\"MosSplashActivityToTarget\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n            </intent-filter>\n\n```\n\n可以看到只有Main 而没有Launcher 这时候就可以将刚才的Launcher 复制到真正的主界面中，并且删除广告里面的main和Launcher就可以毁掉广告页面，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200331161959616.png)\n\n\n\n还有一种去广告的方法， 可以通过删除网络权限去广告，这个后面遇到会提出来。\n\n---\n\n今天的去广告就结束了，如果想要尝试的话，可以私我要app\n\n\n\n\n\n","tags":["破解"],"categories":["Reverse"]},{"title":"CTF-androideasy","url":"%2F2020%2F03%2F25%2F%E9%80%86%E5%90%91%2FCTF%2Fandroideasy%2F","content":"\n\n\n# 题目：androideasy\n\n最近刚学了点逆向技能，找一些简单的ctf 题目来验证一下效果\n\n下载地址：[androideasy](https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy)\n\n## 解题思路\n\n首先拿到的是个zip文件，打开是个普通的apk目录\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160159860.png)\n\n也不知道做逆向的和做安全的看到他的感觉是否一样，\n\n修改后缀为`apk` 后扔到jadx中，然后在往模拟器中扔一份\n\n模拟器中可以看到 很简单的功能，输入字符 。点击check 判断是否输入正确\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160654280.png)\n\n之后查看jadx\n\n大概确定一下，就是需要输入一个字符串在check判断通过即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160744208.png)\n\n\n\n定位到check，输入的字符串必须让if判断为真，也就是进入到check的true\n\n```\nprivate byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};\n\npublic boolean check() {\n        byte[] chars = this.editText.getText().toString().getBytes();\n        if (chars.length != this.f21s.length) {\n            return false;\n        }\n        int i = 0;\n        while (i < this.f21s.length && i < chars.length) {\n            if (this.f21s[i] != (chars[i] ^ 23)) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n```\n\n接下来写firda 代码\n\n```\nfunction flag() {\n    Java.perform(function () {\n        var flag1 = Java.use(\"com.a.sample.androidtest.MainActivity\");\n        flag1.check.implementation = function () {\n             var retval = this.check();\n             console.log(retval)\n             return true;\n        }\n    })\n}\n\n\nfunction main() {\n    flag()\n}\n\nsetImmediate(main);\n```\n\n这样就可以保证返回为真了\n\n回到正题，前台返回为真对flag没有帮助，\n\n所以还是得得到`f21s` ,写个脚本 获得下面的字符串\n\n`private byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};`\n\n最后的脚本\n\n```python\nf21s = [113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106]\nprint(len(f21s))\nflag = \"\"\n\nfor  i in range(0,len(f21s)):  # 判断每一位，一共判断f21s 长度次\n    for j in range(0,127):\n        if (f21s[i] == (j ^ 23)):\n            flag += chr(j)\n\nprint(flag)py\n```\n\n```\n31\nflag{It_1S_@N_3asY_@nDr0)I)1|d}\n```\n\n","tags":["CTF"],"categories":["Reverse"]},{"url":"%2F2020%2F03%2F24%2F%E9%80%86%E5%90%91%2FXposedFridaHook%E7%B3%BB%E5%88%97%2FHook%E5%BC%80%E5%A7%8B%2F","content":"# Hook 通杀\n\n## Hook 普通方法和修改函数参数返回值\n\nfradaserver 是手机端的，\n\n1. android低版本 frida 尽量低版本\n2. fridaserver版本要与frida库版本一致\n3. 不同平台用不同fridaserver\n4. 不要和xposed装一起，新疆模拟器，刷机\n\n设备要求:\n\n​\troot\n\n \t调试\n\n下载frida-server push到手机中 (注意查看手机是86的还是64的)\n\n` adb push .\\frida-server-12.8.14-android-x86 /data/local/tmp/fsx86`\n\n![image-20200319214805400](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200319214805400.png)\n\n之后cd到tmp目录下\n\n先给fsx86 赋权  `chmod 777 fsx86`\n\n之后执行即可。 `./fsx86`\n\n执行后有一个报错，这里是版本出现的问题，会有一些小bug ，不影响使用，最好还是在真机中调试\n\n`WARNING: linker: ./fsx86: unused DT entry: type 0x6ffffef5 arg 0x1c24`\n\n## 插入一个学习\n\n![image-20200320103048870](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320103048870.png)\n\nHook 构造方法\n\n​\t绕过一些验证\n\n​\t构造方法\n\n​\t`money.$init.implementation = function(){}`\n\nHook 重载方法\n\n![image-20200320105658343](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200320105658343.png)\n\nHook 重载方法\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test();\n        console.log(a, retval);\n        return retval;\n    };\n    utils.test.overload().implementation = function () {\n        var retval = this.test();\n        console.log(retval);\n        return retval;\n    };\n    utils.test.overload('com.xiaojianbang.app.Money').implementation = function (a) {\n        var retval = this.test(a);\n        console.log(retval);\n        return retval;\n    }\n}\n\n```\n\nHook 所有重载方法\n\n```\nfunction hookTest3() {\n    // hook 方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length);\n    for (var i = 0; i < utils.test.overloads.length; i++) {\n        utils.test.overloads[i].implementation = function () {\n            // console.log(JSON.stringify(arguments));\n\n            if (arguments.length == 0) {\n                return \"调用没有参数的\";\n            } else if (arguments.length == 1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1){\n                    return \"调用了Money参数的\";\n                }else{\n                    return \"调用了Int 类型的\";\n                }\n            }\n\n                arguments[0] = 1000;\n            // console.log(arguments.length);\n            // apply 改变所属\n            return this.test.apply(this, arguments);\n        }\n    }\n}\n```\n\nHook 构造参数与对象实例化\n\n![image-20200321172539738](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321172539738.png)\n\n![image-20200321173626852](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321173626852.png)\n\n```\nfunction hooktest2() {\n    //Error: test(): has more than one overload, use .overload(<signature>)\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n\n    utils.test.overload('int').implementation = function (a) {\n        a = 888;\n        var retval = this.test(money.$new(\"日元\", 1000000)); // 对象实例化\n        console.log(a, retval);\n        return retval;\n    };\n```\n\n\n\n\n\nhook 实例化\n\n\n\n![image-20200321174929718](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200321174929718.png)\n\n```\nfunction hookTest5() {\n    Java.perform(function () {\n        //静态字段的修改\n        var money = Java.use(\"com.xiaojianbang.app.Money\");\n        //send(JSON.stringify(money.flag));\n        money.flag.value = \"ceshi\";\n        console.log('log', money.flag.value);\n        // 非静态字段的修改\n        Java.choose(\"com.xiaojianbang.app.Money\", {\n            onMatch: function (obj) {\n                obj._name.value = \"ouyuan\"; // 字段与函数名相同， 前面加下划线\n                obj.num.value = 15254131;\n            },\n            onComplete: function () {\n\n            },\n        });\n    });\n}\n```\n\n\n\n 获取所有的类\n\n```\nfunction hookTest7() {\n    Java.perform(function () {\n        Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) {\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name);\n                    var clazz = Java.use(name);\n                    var methods = clazz.class.getDeclaredMethods();\n                    console.log(methods)\n                    for (var i = 0 ; i< methods.length;i++){\n                        console.log(methods[i]);\n                    }\n                }\n            },\n            onComplete:function () {\n\n            },\n        });\n\n```\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0 ; i < classes.length ; i++){\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1){\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0 ;j < methods.length ;j++){\n            console.log(methods[j]);\n        }\n    }\n\n\n}\n```\n\n# Hook 回笼重造\n\n<img src=\"E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324171350015.png\" alt=\"image-20200324171350015\" style=\"zoom:50%;\" />\n\n> xposed 框架替换了很多文件，如果要从xposed转frida 需要刷机\n\n修改debuggable 参考：https://www.bodkin.ren/index.php/archives/533/\n\n```\n[Go0s]: ~/Security/_Tools/Android/mprop/armeabi-v7a ✗ master*\n➜  adb push mprop /data/local/tmp              \nmprop: 1 file pushed. 1.6 MB/s (17712 bytes in 0.011s)\n[Go0s]: ~ \n➜  adb shell\nshell@hammerhead:/ $ cat default.prop | grep debug                             \nro.debuggable=0\nshell@hammerhead:/ $ getprop ro.debuggable\n0\nshell@hammerhead:/ $ cd /data/local/tmp\nshell@hammerhead:/data/local/tmp $ su\nroot@hammerhead:/data/local/tmp # ./mprop ro.debuggable 1   \nproperties map area: b6f7a000-b6f9a000\n00000000  08 8d 00 00 19 01 00 00 50 52 4f 50 ab d0 6e fc  ........PROP??n?\n00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n……\nroot@hammerhead:/ # cat default.prop | grep debug                              \nro.debuggable=0\nroot@hammerhead:/ # getprop ro.debuggable                                      \n1\n```\n\n版本太高导致的问题，问题不会大\n\n![image-20200324192712444](E:\\博客\\andorid逆向\\Frida学习\\Hook开始.assets\\image-20200324192712444.png)\n\n配置代码提示\n\n```npm i @types/frida-gum```\n\n\n\nhook步骤\n\n1. 进入手机终端 启动 fsx86\n2. 端口转发\n3. 使用命令开始hook吧 `frida -U 包名 -l hook代码`\n\n### 逻辑分析\n\n要hook getCalc 方法，定位到函数声明\n\n![image-20200324201846328](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201846328.png)\n\n定位到getCalc  方法有两个参数 a,b \n\n![image-20200324201919870](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324201919870.png)\n\n### Hook普通方法\n\n接下来根据这个函数开始hook\n\n​\t`var utils = Java.use(\"com.xiaojianbang.app.Utils\");` 定位函数\n\n​\t重写方法 implementation \n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n\t// 先打印一下a,b 参数和返回的参数\n    var retval = this.getCalc(a,b); \n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n​\t点击普通方法，即可在frida中看到获取的参数\n\n![image-20200324202244461](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324202244461.png)\n\n之后修改a ，b 参数\n\n```\nvar utils = Java.use(\"com.xiaojianbang.app.Utils\");\nutils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型\n    a = 123;\n    b = 345;\n\n    var retval = this.getCalc(a,b);\n\n    console.log(a,b,retval);\n    return retval;\n}\n```\n\n![image-20200324203353529](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324203353529.png)\n\n\n\n### Hook 重载方法和重载方法的Hook\n\n重载方法和一般普通方法区别不大\n\n![image-20200324205305292](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205305292.png)\n\n当使用之前的方法 去hook重载方法\n\n![image-20200324205229878](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324205229878.png)\n\n需要使用overload 去指定参数\n\n```\n    utils.test.overload('int').implementation = function (a, b) { // implementation 是重写方法， js中不需要函数类型\n\n```\n\n最后hook所有的重载方法\n\n只要符合返回值，可以随意改的，即使调用其他的重载函数也是可以执行\n\n```\nutils.test.overload('int').implementation = function (a) { // implementation 是重写方法， js中不需要函数类型\n    a = 888888888;\n    var retval = this.test(a);\n    console.log(a, retval);\n    return retval;\n};\nutils.test.overload().implementation = function () {\n    var retval = this.test();\n    console.log(\"无参：\",retval);\n    return retval;\n};\nutils.test.overload(\"com.xiaojianbang.app.Money\").implementation = function (a) {\n    var retval = this.test(a);\n    console.log(a,retval);\n    return retval;\n};\n```\n\nHook所有重载函数\n\n```\nfor (var i = 0 ;i < utils.test.overloads.length;i++){ // 通过for 循环去获取每一个\n    utils.test.overloads[i].implementation = function () {\n        console.log(arguments); // arguments 是一个数组\n    }\n}\n```\n\n通过apply 可以避免每次返回需要改变返回参数的问题\n\n```\nthis.test.apply(this,arguments) // apply 是改变函数所属\n```\n\n>  在frida 中，在同位置下多个钩子 最后一个会生效，因为他的代码会覆盖之前的代码。\n\n返回hook每个重载函数 参数长度\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n返回结果\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324213234513.png)\n\n如果需要修改其中的某个重载函数 则需要在这里做一个判断\n\n```\nif (arguments.length == 0){\n    return \"xiaojianbang\";\n}\n```\n\n\n\nhook 完整代码\n\n```\nfunction hookTest3() {\n    // hook方法的所有重载\n    var utils = Java.use(\"com.xiaojianbang.app.Utils\");\n    console.log(utils.test.overloads.length)\n    // 之后遍历参数\n    for (var i = 0 ;i < utils.test.overloads.length;i++){\n        utils.test.overloads[i].implementation = function () {\n            //console.log(arguments);\n            if (arguments.length == 0){\n                return \"xiaojianbang\";\n            }else if (arguments.length ==  1){\n                if (JSON.stringify(arguments).indexOf(\"Money\") != -1 ){\n                    return \"调用了Money参数\";\n                } else{\n                    return \" 调用了int参数的\";\n                }\n            }\n            return this.test.apply(this,arguments) // apply 是改变函数所属\n        }\n    }\n}\n```\n\n## Hook 构造函数与对象实例化\n\n这里的`Money` 是我们的构造函数 函数与类型一致 \n\n![image-20200324215249350](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215249350.png)\n\n也需要指明\n\n![image-20200324215639928](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324215639928.png)\n\n构造函数和重载只是多了个 $init\n\n```\nfunction hookTest4() {\n    var money = Java.use(\"com.xiaojianbang.app.Money\");\n    // 函数名与方法名一致\n    money.$init.overload('java.lang.String','int').implementation = function (str,num) {\n        console.log(str,num);\n        this.$init(str,num);\n    }\n}\n```\n\n在上一节重载函数，我们调用了money ，但是当我们要修改其中的值时 需要调用money的包\n\n![image-20200324220110549](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220110549.png)\n\n在函数开始位置添加\n\n![image-20200324220151168](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220151168.png)\n\n这就完成了一个实例化\n\n![image-20200324220241983](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324220241983.png)\n\n## 修改类的字段\n\n先尝试hook一下静态资源\n\n```\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nconsole.log(JSON.stringify(money.flag.value));\n```\n\n> 多个对象就会有多个字段，所以要修改 必须找到对应的字段\n\n修改字段\n\n```\n// 静态字段\nvar money = Java.use(\"com.xiaojianbang.app.Money\");\n//send(money.flag)\nmoney.flag.value = \"xiaojianbang\";\n\nconsole.log(JSON.stringify(money.flag.value));\n```\n\nhook 修改非静态字段\n\n> 正常的每次修改都会new一个对象，所以看不到返回的值\n\n![image-20200324222948009](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324222948009.png)\n\n```\nJava.choose(\"com.xiaojianbang.app.Money\", {\n    onMatch: function (obj) { // 每次遍历对象都会调用一次onMatch\n        // 修改对象参数，如果修改单个 价格判断即可\n        obj._name.value = \"ouyuan\"; // 这块注意字段名与函数名是否相同\n        obj.num.value = 15000000;\n    },\n    onComplete: function () {\n\n    }\n});  // cakkbacks指的是对象\n```\n\n> 这块注意 当字段名与函数名相同 要加`_`来区分\n\n## hook 内部类和匿名类\n\n当hook 类下的类 hook方法\n\n可以通过jeb smail 去看 \n\n![image-20200324230631123](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324230631123.png)\n\nmoney 只是一个父类，匿名类是getInfo 这里实现了一次， 匿名类一般都是$1 这种形式\n\n![image-20200324231541211](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200324231541211.png)\n\n## 枚举所有的类和所有的方法\n\n```\nJava.enumerateLoadedClasses() //枚举类 只能加载 已经被加载的类\n```\n\njava反射获取方法\n\n```\nvar methods = clazz.class.getDeclaredMethods();\n```\n\n获取所有的类\n\n```\nJava.enumerateLoadedClasses({\n    onMatch:function (name,handle) { // 代码都是写在这里的\n        if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n            console.log(name) \n        }\n    },\n    onComplete:function () { // 这里只会使用一次\n\n    }\n})\n```\n\n获取类下的方法\n\n```\n Java.enumerateLoadedClasses({\n            onMatch:function (name,handle) { // 代码都是写在这里的\n                if (name.indexOf(\"com.xiaojianbang.app\") != -1){\n                    console.log(name) // 类和地址  打印好多系统类，这里就要做个过滤\n                    // 遍历类下的所有的方法 java 反射 有个getDeclaredMethods\n                    var clazz = Java.use(name);\n                    console.log(clazz);\n                    var methods = clazz.class.getDeclaredMethods(); // 得到的是一个对象，这里要通过class转\n                    //console.log(methods);  // 直接打印输出较乱 做一个整理\n\n                    if (var i = 0; i < methods[i].length;i++){\n                        console.log(methods[i]);\n                    }\n                    console.log()\n\n\n\n                }\n            },\n            onComplete:function () { // 这里只会使用一次\n\n            }\n        })\n```\n\n异步方式获取类和类的方法\n\n```\nvar classes = Java.enumerateLoadedClassesSync();\nfor (var i = 0; i < classes.length; i++) {\n    if (classes[i].indexOf(\"com.xiaojianbang.app\") != -1) {\n        console.log(classes[i]);\n        var clazz = Java.use(classes[i]);\n        var methods = clazz.class.getDeclaredMethods();\n        for (var j = 0; j < methods.length; j++) {\n            console.log(methods[j]);\n        }\n    }\n}\n```\n\n## hook类的所有方法\n\n首先确定hook那个类， 比如md5，之后通过java反射 获取类下的方法\n\n```\nvar md5 = Java.use(\"com.xiaojianbang.app.MD5\");\nvar methods= md5.class.getDeclaredMethods();\n```\n\n之后通过循环返回打印\n\n```\nfunction hookTest8() {\n    Java.perform(function () {\n        var md5 = Java.use(\"com.xiaojianbang.app.MD5\");\n        var methods = md5.class.getDeclaredMethods();\n        for (var i = 0; i < methods.length; i++) {\n            var methodName = methods[i].getName();\n            console.log(methodName);\n            for (var k = 0; k < md5[methodName].overloads.length; k++) {\n                md5[methodName].overloads[k].implementation = function () {\n                    for (var j = 0; j < arguments.length; j++) {\n                        console.log(arguments[j]);\n                    }\n                    return this[methodName].apply(this, arguments) // 不知道返回的对象\n                }\n            }\n\n        }\n    })\n}\n```\n\n## 动态加载dex\n\n遇到问题： 在调用函数后，有些dex 是通过动态加载调用的，反编译并不会反编译到所有的dex\n\n一般可以通过DexClassLoader动态加载，或者通过so层 或者内存中去加载\n\n这里通过DexClassLoader去加载，文件放在apk的目录中\n\n![image-20200325214341078](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214341078.png)\n\n当直接调用就会报错\n\n```\nfunction hookTest9() {\n    Java.perform(function () {\n        var dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n        console.log(dynamic);\n    })\n}\n```\n\n![image-20200325214906826](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200325214906826.png)\n\n这里就要找到对应的classloader  \n\n> 注意：这个api是要在7版本以上使用，用android5 可能会报错\n\n```\nfunction hookTest9(){\n    Java.perform(function(){\n\n        Java.enumerateClassLoaders({\n            onMatch: function(loader){\n                try {\n                    if(loader.loadClass(\"com.xiaojianbang.app.Dynamic\")){\n                        Java.classFactory.loader = loader;\n                        var Dynamic = Java.use(\"com.xiaojianbang.app.Dynamic\");\n                        console.log(Dynamic);\n                        Dynamic.sayHello.implementation = function(){\n                            return \"xiaojianbang\";\n                        }\n                    }\n                } catch (error) {\n\n                }\n            }\n            ,\n            onComplete: function(){\n\n            }\n        });\n    });\n}\n```\n\n![image-20200326091943750](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200326091943750.png)\n\n\n\n> Java.classFactory.loader = loader; 这里的loader 可能会报错 不影响正确性\n\n\n\n## Java 里特殊类型的遍历与修改\n\nHook map 或者修改其中的某些值\n\n\n\n![image-20200329001310423](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001310423.png)\n\n![image-20200329001325832](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200329001325832.png)\n\n这块可以使用show（java的代码） 去hook\n\n可以将show方法 直接copy过去，但是要注意里面的函数要遵守js的语法\n\n这块要使用迭代器去获取map\n\n```\n不要调用伪代码的方法，而是去自写\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n\n            var key = map.keySet();\n            var it = key.iterator();\n            var result = \"\";\n            while (it.hasNext()) {\n                var keystr = it.next();\n                var valuestr = map.get(keystr);\n                result += valuestr;\n            }\n        console.log(result);\n        return result;\n\n        }\n    })\n}\n```\n\n之后是java 特殊类型的修改\n\n```\nfunction hookTest10(){\n    Java.perform(function () {\n        var ShufferMap = Java.use(\"com.xiaojianbang.app.ShufferMap\")\n        console.log(ShufferMap);\n        ShufferMap.show.implementation = function (map) {\n            console.log(JSON.stringify(map));\n        // 2 修改特殊方法\n            map.put(\"pass\",\"zygx8\");\n            map.put(\"xxxx\",\"www.zygx8.com\");\n            var retval = this.show(map);\n            console.log(retval);\n            return retval;\n\n        }\n    })\n}\n```\n\n## Java 层主动调用函数\n\n只有当函数被触发才会被执行，那么当我们需要解密一个比较复杂的算法，是可以通过主动调用函数去获取的\n\n静态主动调用\n\n```\n调用rsa方法\nfunction hookTest11() {\n    Java.perform(function () {\n        var rsa = Java.use(\"com.xiaojianbang.app.RSA\");\n        var str = Java.use(\"java.lang.String\");\n        var base64 = Java.use(\"android.util.Base64\");\n        var bytes = str.$new(\"xioajianbang\").getBytes();\n        console.log(bytes);\n        var retval = rsa.encrypt(bytes);\n        console.log(retval);\n        var result = base64.encodeToString(retval,0);\n        console.log(result);\n    })\n}\n```\n\n非静态方法的主动调用 调用getinfo\n\n```\n Java.use(\"com.xiaojianbang.Money\").$new(\"欧元\",3000000).getInfo();\n```\n\n\n\n## Java 打印函数堆栈\n\n之前使用Log.d 来打印信息\n\n![image-20200330115446399](D:\\Blog\\ST0new.github.io\\source\\_posts\\逆向\\XposedFridaHook系列\\Hook开始.assets\\image-20200330115446399.png)\n\n推荐： 使用`Log.getStack.TrachString(new Throwable())` 或``Log.getStack.TrachString(new exception())``\n\n```\nfunction hookTest12() {\n    // 写一个函数堆栈\n    function showStacks(){\n        console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n        //console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()));\n    }\n    Java.perform(function () {\n        //Java.cast();\n        //Java.openClassFile();\n        var MessageDigest =  Java.use(\"java.security.MessageDigest\");\n        MessageDigest.digest.overload().implementation = function () {\n            showStacks();\n            return this.digest();\n\n        }\n    })\n}\n```"},{"title":"Andorid Studio 安装报错 解决","url":"%2F2020%2F03%2F10%2F%E9%80%86%E5%90%91%2Fandroidstudio%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%2F","content":"\n\n\n# Andorid Studio 安装报错 解决\n\n\n\n## 小记\n\n安装了一下午的AndroidStudio 一直报错，安装不上sdk 实在头疼，查到资料改个hosts就搞定了，舒服\n\n\n\n将这两个写入`c:\\users\\你电脑的名字\\drivers\\etc\\hosts`中 即可解决 不挂代理轻松安装sdk\n\n```\n203.208.43.101 dl-ssl.google.com\n203.208.43.101 dl.google.com\n```\n\n\n\n","tags":["逆向"],"categories":["Reverse"]},{"title":"python第一课 数据结构和算法","url":"%2F2020%2F02%2F27%2F%E7%BC%96%E7%A8%8B%2Fpython%2Fpython%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F","content":"\n# python第一课 数据结构和算法\n\n> 注： 本文是对照https://python3-cookbook.readthedocs.io/ 学习 总结笔记 \n\n\n\n## 1.1  解压序列复制给多个变量\n\n**问题**\n\n现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？\n\n**解决方案**\n\n**元组**：元组使用小括号与列表非常相似，创建元组只需要 `tup = (1,2,3,4,5,6)`,通过逗隔开即可；查看当前变量是否属于元组可以通过`type(tup)` 来获取变量类型；并且 元组也可以通过 tup = \"a\",\"b\",\"c\" 这样来实现；元组只包含一个元素，需要在元素后面添加逗号，否则会被当做运算符使用。\n\n**序列**：python中的序列一般指 字符串，列表，元组。python在序列中可以进行索引、切片、加、乘、检查成员、确定最大最小元素，\n\n**字符串**： python的字符串我在介绍中也说了， 通过 变量 等于 用引号包括的值即可，例如：\n\nvar = \"St0n5\"\n\n**列表**： 和元组类似，千万不要混淆了， 通过 list = ['ceshi1','ceshi2'] 来创建\n\n\n\n接下来开始解决问题\n\n```\n# 将p赋值给变量，注意变量的数量要和序列的数量相同\n# python 可以通过多变量赋值实现 同时对多个变量的赋值\n>>> p =(4,5)\n>>> x,y=p\n>>> x\n4\n>>> y\n5\n# 接下来 放一个列表试试\n>>> data = ['python','C','中国加油',52.0,(2020,2,26)]\t\t    \n>>> code1,code2,num1,num2,data1=data\t\t    \n>>> code1\t\t    \n'python'\n>>> code2\t\t    \n'C'\n>>> num1\t\t    \n'中国加油'\n>>> num2\t\t\t    \n52.0\n>>> data1\t\t    \n(2020, 2, 26)\n```\n\n**讨论**\n\n上面展示了都是序列元素和元素一样的情况，那如果只需要其中的一部分元素 应该怎么去做，\n\n文章中提供了一种方法是使用任意变量名占位，之后丢掉就好，\n\n还可以通过下标来输入某个元素 也可以达到解压一部分的目的。\n\n## 1.2 解压可迭代对象赋值给多个变量\n\n**问题**\n\n如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 `ValueError` 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？\n\n**解决方案**\n\n**容器**: 把多个元素组织在一起的数据结构，当它可以用来询问某个元素是否包含在其中时，就可以理解为这是一个容器\n\n**迭代对象**：很多容器都是可迭代对象，但凡是可以返回一个迭代器的对象都可称之为可迭代对象\n\n**迭代器**： 它是一种带状态的对象，通过`next()`方法调用返回容器的下一个值，迭代器就是工厂模式的对象。\n\n**生成器**： 生成器是一种特殊的迭代器，生成器可以用更少的中间变量些流式代码，此外，相比于其他容器，它能更节省内存和`cpu`，没有返回值，通过`yield`来返回\n\n解决问题\n\n```\n# 解决可迭代对象的元素超过变量个数 ，可以用 * 来解决问题\n>>> record = ('xss','sql','upload','xxe','download')      \n>>> first,*middle,last = record      \n>>> first\t      \n'xss'\n>>> middle      \n['sql', 'upload', 'xxe']\n>>> last      \n'download'\n# middle 永远都是列表类型，元素为空也是如此， 并且 * 表达式 可以用在任何位置。\n```\n\n扩展的迭代语法是为了解压不确定个数或者任意个数的元素的可迭代对象设计的，通常可迭代对象都是有一定规律的， 有时 `*`表达式也可以用来做字符串的分割，\n\n```\n>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'\n>>> uname, *fields, homedir, sh = line.split(':')\n>>> uname\n'nobody'\n>>> homedir\n'/var/empty'\n>>> sh\n'/usr/bin/false'\n>>>\n```\n\n当然，如果你想要的解压一些元素并丢弃他们，你可以用`*_`这样来表示废弃\n\n\n\n\n\n未完待续 ...\n\n\n\n\n\n---\n\n参考链接：\n\nhttps://foofish.net/iterators-vs-generators.html\n\nhttps://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html\n\n","tags":["python"],"categories":["Code"]},{"title":"python 入门简介","url":"%2F2020%2F02%2F26%2F%E7%BC%96%E7%A8%8B%2Fpython%2Fpython%E4%BB%8B%E7%BB%8D%2F","content":"\n# python 简介\n\n\n\n为了完成毕设 努力学习python\n\n\n\n* python 是一种解释型语言\n* pyhton 是交互式语言\n* python是面向对象语言\n* python是初学者语言 很简单\n\n\n\n## 0x01 python区分\n\n只要有python2 和python3 之分\n\n\n\n## 0x02 python的特点\n\n这就不提了 全是优点\n\npython大法好\n\n## 0x03 python 变量类型\n\n### 字符串\n\n一般由数字、字母、下划线组成\n\n```\nstr = 'xxxx'\n```\n\n**方法**\n\n\n\n## 列表\n\n支持字符、数字、字符串 甚至可以包含列表（嵌套）\n\n```\nlist = [ 'runoob', 786 , 2.23, 'john', 70.2 ]\ntinylist = [123, 'john']\n```\n\npython中支持数据类型和类型的`连接`和`重复`操作\n\n## 元组\n\n元组用`()`标识，内部元素用逗号隔开。但是元组不能二次赋值，\n\n元组不能通过修改\n\n```\ntuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )\ntinytuple = (123, 'john')\n```\n\n## 字典\n\n字典也是经常要使用的数据类型之一，和列表相比，列表是有序的对象集合，字典是无需的对象集合，列表是通过偏移存取，而字典是通过键来存取的\n\n```\ndict = {}\ndict['one'] = \"This is one\"\ndict[2] = \"This is two\"\n \ntinydict = {'name': 'john','code':6734, 'dept': 'sales'}\n```\n\n\n\n\n\n# PythonTip \n\n## 每日一练\n\n**结尾为0的个数**\n\n```\n给你一个正整数列表 L, 输出L内所有数字的乘积末尾0的个数。(提示:不要直接相乘,数字很多,相乘得到的结果可能会很大)。例如： L=[2,8,3,50],则输出：2\n```\n\n我拿到题第以想法就是乘，但无疑会增加算法的时间复杂度，所以，接下来就是分析如何更加简洁的利用\n\n需要的是末尾0的个数，而数字中任何可以得到末尾为0的个数的值都可以化为2x5x某个值\n\n所以接下来只要对每一位数字化一下是否可以通过2或者 5 得到\n\n最后求一下2和5分别有多少个，取最小的那个就可以了 因为2和5都是素数，所以不存在取得的数重复现象\n\n总结一下：求每一个数可以得到几个2和几个5\n\n```\nL =[2,8,3,50]\n\ncount_2 ,count_5= 0,0\n\ndef count_2_5(i,n):\n    num = 0\n    while i % n == 0:\n        i  = i / 2\n        num += 1\n    return num\n\nfor i in L:\n    count_2 += count_2_5(i,2)\n    count_5 += count_2_5(i,5)\n\nprint(min(count_2,count_5))\n```\n\n\n\n\n\n\n\n","tags":["python"],"categories":["Code"]},{"title":"android 安全之环境搭建（一）","url":"%2F2020%2F02%2F05%2F%E9%80%86%E5%90%91%2Fandroid%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F","content":"\n[TOC]\n\n# android 安全（一）\n\n简单的学习做笔记\n\nandroid 现在基本都是以逆向脱壳为主，为了能够更加了解渗透测试，特地学习了一下逆向的基础知识。\n\n# 0x00 环境搭建\n\n不论从事那一方面的研究，第一件事都是搭建一个满意的环境，不然满是bug的环境会让你望而却步。\n\n**硬件要求**\n\n逆向需要的环境对系统要求不高，我自己是个游戏本，完全满足要求，就不需要在硬件上破费了。你只需要一个功能齐全的电脑都可以满足基本的学习要求。\n\n## 必备的一些软件安装\n\n推荐一个android下载站： https://www.androiddevtools.cn/#\n\n1. `jdk` ：这是android开发必备环境之一，由于一些软件限制，我准备的是`jdk-8u121-windows-x64`和`jdk-8u121-windows-i586`,当然也可以下载最新的，但有时会在安装某个软件的时候出现莫名其妙的问题。\n\n2. `android sdk`: （由于已经没有了单独的下载包，所以可以通过下载包含有android sdk 的android studio: 另一种是网上提供下载的链接，这个倒是蛮多的  下载链接：[android studio](https://developer.android.com/studio)）\n\n> 这里说一下android sdk 和android studio的区别\n>\n> Android SDK 是一个开发包。类似于JAVA SDK。里面包含了Android开发的各式各样的库文件。\n> Android studio是一个IDE（可视化开发工具）跟eclipse一样的东西。用来开发Android的工具。(studio 包含有sdk)\n\n3. `android NDK`:`Android NDK` 是一个工具集，可让您使用 C 和 C++ 等语言以原生代码实现应用的各个部分。对于特定类型的应用，这可以帮助您重复使用以这些语言编写的代码库[NDK](https://developer.android.com/ndk/downloads)   之后将ndk 安装的路径添加到`path` 环境变量中即可\n\n4. 开发环境安装 ，这里我安装的是`android studio` 因为`eclipse for Android Developers ` 已经不在维护了。\n\n   \n\n---\n\n刚开始学逆向，好多东西都是一知半解，如果有什么问题或者错误， 还望各位大佬狠狠的批评。","tags":["逆向"],"categories":["Reverse"]},{"title":"�嵥�ļ�Ȩ��","url":"%2F2020%2F02%2F05%2F%E9%80%86%E5%90%91%2F%E6%B8%85%E5%8D%95%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F","content":"\n\n\n## �嵥�ļ�Ȩ��\n\n```xml\n��������\nandroid.permission.INTERNET�������������ӣ����ܲ���GPRS����\nandroid.permission.CHANGE_WIFI_STATE  Wifi �ı�״̬\nandroid.permission.ACCESS_WIFI_STATE WiFi ״̬\nandroid.permission.ACCESS_NETWORK_STATE ����״̬\n¼����Ƶ\nandroid.permission.CAMERA\nandroid.permission.RECORD_AUDIO\nandroid.permission.WRITE_EXTERNAL_STORAGE\n�ײ����Ȩ��\nandroid.permission.CWJ_GROUP������CWJ�˻�����ʵײ���Ϣ\n�ֻ��Ż���ʦ��չȨ��\nandroid.permission.CELL_PHONE_MASTER_EX���ֻ��Ż���ʦ��չȨ��\n���ƶ�λ����\nandroid.permission.CONTROL_LOCATION_UPDATES����������ƶ����綨λ��Ϣ�ı�\nɾ�������ļ�\nandroid.permission.DELETE_CACHE_FILES������Ӧ��ɾ�������ļ�\nɾ��Ӧ��\nandroid.permission.DELETE_PACKAGES����������ɾ��Ӧ��\n��Դ����\nandroid.permission.DEVICE_POWER���������ʵײ��Դ����\nӦ�����\nandroid.permission.DIAGNOSTIC����������RW�������Դ\n���ü�����\nandroid.permission.DISABLE_KEYGUARD������������ü�����\nת��ϵͳ��Ϣ\nandroid.permission.DUMP�����������ȡϵͳdump��Ϣ��ϵͳ����\n״̬������\nandroid.permission.EXPAND_STATUS_BAR������������չ������״̬��\n��������ģʽ\nandroid.permission.FACTORY_TEST�������������й�������ģʽ\nʹ�������\nandroid.permission.FLASHLIGHT���������������\nǿ�ƺ���\nandroid.permission.FORCE_BACK����������ǿ��ʹ��back���˰���������Activity�Ƿ��ڶ���\n�����˻�Gmail�б�\nandroid.permission.GET_ACCOUNTS������GMail�˻��б�\n��ȡӦ�ô�С\nandroid.permission.GET_PACKAGE_SIZE����ȡӦ�õ��ļ���С\n��ȡ������Ϣ\nandroid.permission.GET_TASKS�����������ȡ��ǰ��������е�Ӧ��\n����ȫ������\nandroid.permission.GLOBAL_SEARCH����������ʹ��ȫ����������\nӲ������\nandroid.permission.HARDWARE_TEST������Ӳ�������豸������Ӳ������\nע���¼�\nandroid.permission.INJECT_EVENTS���������ʱ�����ĵײ��¼�����ȡ�������켣����¼���\n��װ��λ�ṩ\nandroid.permission.INSTALL_LOCATION_PROVIDER����װ��λ�ṩ\n��װӦ�ó���\nandroid.permission.INSTALL_PACKAGES����������װӦ��\n�ڲ�ϵͳ����\nandroid.permission.INTERNAL_SYSTEM_WINDOW������������ڲ����ڣ����Ե�����Ӧ�ó��򿪷Ŵ�Ȩ��\n������̨����\nandroid.permission.KILL_BACKGROUND_PROCESSES�������������killBackgroundProcesses(String).����������̨����\n�����˻�\nandroid.permission.MANAGE_ACCOUNTS�������������AccountManager�е��˻��б�\n������������\nandroid.permission.MANAGE_APP_TOKENS�������������ݻ١�Z��˳�򣬽�����ϵͳ\n�߼�Ȩ��\nandroid.permission.MTWEAK_USER������mTweak�û����ʸ߼�ϵͳȨ��\n����Ȩ��\nandroid.permission.MTWEAK_FORUM������ʹ��mTweak����Ȩ��\n����ʽ��\nandroid.permission.MASTER_CLEAR����������ִ������ʽ����ɾ��ϵͳ������Ϣ\n�޸���������\nandroid.permission.MODIFY_AUDIO_SETTINGS���޸�����������Ϣ\n�޸ĵ绰״̬\nandroid.permission.MODIFY_PHONE_STATE���޸ĵ绰״̬�������ģʽ�����������滻ϵͳ����������\n��ʽ���ļ�ϵͳ\nandroid.permission.MOUNT_FORMAT_FILESYSTEMS����ʽ�����ƶ��ļ�ϵͳ�������ʽ�����SD��\n�����ļ�ϵͳ\nandroid.permission.MOUNT_UNMOUNT_FILESYSTEMS�����ء��������ⲿ�ļ�ϵͳ\n����NFCͨѶ\nandroid.permission.NFC����������ִ��NFC������ͨѶ�����������ƶ�֧��\n����Activity\nandroid.permission.PERSISTENT_ACTIVITY������һ�����õ�Activity���ù��ܱ��Ϊ���������Ƴ�\n���������绰\nandroid.permission.PROCESS_OUTGOING_CALLS������������ӣ��޸Ļ���������绰\n��ȡ�ճ�����\nandroid.permission.READ_CALENDAR�����������ȡ�û����ճ���Ϣ\n��ȡ��ϵ��\nandroid.permission.READ_CONTACTS������Ӧ�÷�����ϵ��ͨѶ¼��Ϣ\n��Ļ��ͼ\nandroid.permission.READ_FRAME_BUFFER����ȡ֡����������Ļ��ͼ\n��ȡ�ղؼк���ʷ��¼\ncom.android.browser.permission.READ_HISTORY_BOOKMARKS����ȡ������ղؼк���ʷ��¼\n��ȡ����״̬\nandroid.permission.READ_INPUT_STATE����ȡ��ǰ��������״̬��������ϵͳ\n��ȡϵͳ��־\nandroid.permission.READ_LOGS����ȡϵͳ�ײ���־\n��ȡ�绰״̬\nandroid.permission.READ_PHONE_STATE�����ʵ绰״̬\n��ȡ��������\nandroid.permission.READ_SMS����ȡ��������\n��ȡͬ������\nandroid.permission.READ_SYNC_SETTINGS����ȡͬ�����ã���ȡGoogle����ͬ������\n��ȡͬ��״̬\nandroid.permission.READ_SYNC_STATS����ȡͬ��״̬�����Google����ͬ��״̬\n�����豸\nandroid.permission.REBOOT�������������������豸\n�����Զ�����\nandroid.permission.RECEIVE_BOOT_COMPLETED���������򿪻��Զ�����\n���ղ���\nandroid.permission.RECEIVE_MMS�����ղ���\n���ն���\nandroid.permission.RECEIVE_SMS�����ն���\n����Wap Push\nandroid.permission.RECEIVE_WAP_PUSH������WAP PUSH��Ϣ\n¼��\nandroid.permission.RECORD_AUDIO��¼������ͨ���ֻ�����������\n����ϵͳ����\nandroid.permission.REORDER_TASKS����������ϵͳZ�������е�����\n����ϵͳ����\nandroid.permission.RESTART_PACKAGES����������ͨ��restartPackage(String)�������÷�ʽ������������\n���Ͷ���\nandroid.permission.SEND_SMS�����Ͷ���\n����Activity�۲���\nandroid.permission.SET_ACTIVITY_WATCHER������Activity�۲���һ������monkey����\n������������\ncom.android.alarm.permission.SET_ALARM��������������\n���������˳�\nandroid.permission.SET_ALWAYS_FINISH�����ó����ں�̨�Ƿ������˳�\n���ö�������\nandroid.permission.SET_ANIMATION_SCALE������ȫ�ֶ�������\n���õ��Գ���\nandroid.permission.SET_DEBUG_APP�����õ��Գ���һ�����ڿ���\n������Ļ����\nandroid.permission.SET_ORIENTATION��������Ļ����Ϊ�������׼��ʽ��ʾ����������ͨӦ��\n����Ӧ�ò���\nandroid.permission.SET_PREFERRED_APPLICATIONS������Ӧ�õĲ������Ѳ��ٹ�������鿴addPackageToPreferred(String)����\n���ý�������\nandroid.permission.SET_PROCESS_LIMIT�����������������Ľ�������������\n����ϵͳʱ��\nandroid.permission.SET_TIME������ϵͳʱ��\n����ϵͳʱ��\nandroid.permission.SET_TIME_ZONE������ϵͳʱ��\n���������ֽ\nandroid.permission.SET_WALLPAPER�����������ֽ\n���ñ�ֽ����\nandroid.permission.SET_WALLPAPER_HINTS�����ñ�ֽ����\n�������ý����ź�\nandroid.permission.SIGNAL_PERSISTENT_PROCESSES������һ�����õĽ����ź�\n״̬������\nandroid.permission.STATUS_BAR����������򿪡��رա�����״̬��\n���ʶ�������\nandroid.permission.SUBSCRIBED_FEEDS_READ�����ʶ�����Ϣ�����ݿ�\nд�붩������\nandroid.permission.SUBSCRIBED_FEEDS_WRITE��д����޸Ķ������ݵ����ݿ�\n��ʾϵͳ����\nandroid.permission.SYSTEM_ALERT_WINDOW����ʾϵͳ����\n�����豸״̬\nandroid.permission.UPDATE_DEVICE_STATS�������豸״̬\nʹ��֤��\nandroid.permission.USE_CREDENTIALS����������������֤��AccountManager\nʹ��SIP��Ƶ\nandroid.permission.USE_SIP����������ʹ��SIP��Ƶ����\nʹ����\nandroid.permission.VIBRATE��������\n��������\nandroid.permission.WAKE_LOCK�������������ֻ���Ļ�رպ��̨������Ȼ����\nд��GPRS���������\nandroid.permission.WRITE_APN_SETTINGS��д������GPRS���������\nд���ճ�����\nandroid.permission.WRITE_CALENDAR��д���ճ̣������ɶ�ȡ\nд����ϵ��\nandroid.permission.WRITE_CONTACTS��д����ϵ�ˣ������ɶ�ȡ\nд���ⲿ�洢\nandroid.permission.WRITE_EXTERNAL_STORAGE����������д���ⲿ�洢����SD����д�ļ�\nд��Google��ͼ����\nandroid.permission.WRITE_GSERVICES����������д��Google Map��������\nд���ղؼк���ʷ��¼\ncom.android.browser.permission.WRITE_HISTORY_BOOKMARKS��д���������ʷ��¼���ղؼУ������ɶ�ȡ\n��дϵͳ��������\nandroid.permission.WRITE_SECURE_SETTINGS�����������дϵͳ��ȫ���е�������\n��дϵͳ����\nandroid.permission.WRITE_SETTINGS��������дϵͳ������\n��д����\nandroid.permission.WRITE_SMS��������д����\nд������ͬ������\nandroid.permission.WRITE_SYNC_SETTINGS��д��Google����ͬ������\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/>\n���ʵǼ�����\nandroid.permission.ACCESS_CHECKIN_PROPERTIES ����ȡ��д��Ǽ�check-in���ݿ����Ա���Ȩ��\n��ȡ����λ��\nandroid.permission.ACCESS_COARSE_LOCATION��ͨ��WiFi���ƶ���վ�ķ�ʽ��ȡ�û����Եľ�γ����Ϣ����λ���ȴ�������30~1500��\n��ȡ��ȷλ��\nandroid.permission.ACCESS_FINE_LOCATION��ͨ��GPSоƬ�������ǵĶ�λ��Ϣ����λ���ȴ�10������\n���ʶ�λ��������\nandroid.permission.ACCESS_LOCATION_EXTRA_COMMANDS������������ʶ���Ķ�λ�ṩ��ָ��\nGPS��λ��ȡģ�ⶨλ��Ϣ\nandroid.permission.ACCESS_MOCK_LOCATION����ȡģ�ⶨλ��Ϣ��һ�����ڰ��������ߵ���Ӧ��\n��ȡ����״̬\n\n\n\n\nandroid.permission.ACCESS_NETWORK_STATE����ȡ������Ϣ״̬���統ǰ�����������Ƿ���Ч\n����Surface Flinger\nandroid.permission.ACCESS_SURFACE_FLINGER��Androidƽ̨�ϵײ��ͼ����ʾ֧�֣�һ��������Ϸ�������Ԥ������͵ײ�ģʽ����Ļ��ͼ\n��ȡWiFi״̬\nandroid.permission.ACCESS_WIFI_STATE����ȡ��ǰWiFi�����״̬�Լ�WLAN�ȵ����Ϣ\n�˻�����\nandroid.permission.ACCOUNT_MANAGER����ȡ�˻���֤��Ϣ����ҪΪGMail�˻���Ϣ��ֻ��ϵͳ�����̲��ܷ��ʵ�Ȩ��\n��֤�˻�\nandroid.permission.AUTHENTICATE_ACCOUNTS������һ������ͨ���˻���֤��ʽ�����˻�����ACCOUNT_MANAGER�����Ϣ\n����ͳ��\nandroid.permission.BATTERY_STATS����ȡ��ص���ͳ����Ϣ\n��С���\nandroid.permission.BIND_APPWIDGET������һ���������appWidget������Ҫ����С��������ݿ⣬ֻ�зǳ��ٵ�Ӧ�ò��õ���Ȩ��\n���豸����\nandroid.permission.BIND_DEVICE_ADMIN������ϵͳ����Ա������receiver��ֻ��ϵͳ����ʹ��\n�����뷨\nandroid.permission.BIND_INPUT_METHOD ������InputMethodService����ֻ��ϵͳ����ʹ��\n��RemoteView\nandroid.permission.BIND_REMOTEVIEWS������ͨ��RemoteViewsService����������ֻ��ϵͳ������\n�󶨱�ֽ\nandroid.permission.BIND_WALLPAPER������ͨ��WallpaperService����������ֻ��ϵͳ������\nʹ������\nandroid.permission.BLUETOOTH����������������Թ��������豸\n��������\nandroid.permission.BLUETOOTH_ADMIN������������з��ֺ�����µ������豸\n���שͷ\nandroid.permission.BRICK���ܹ������ֻ����ǳ�Σ�գ�����˼��������ֻ����שͷ\nӦ��ɾ��ʱ�㲥\nandroid.permission.BROADCAST_PACKAGE_REMOVED����һ��Ӧ����ɾ��ʱ����һ���㲥\n�յ�����ʱ�㲥\nandroid.permission.BROADCAST_SMS�����յ�����ʱ����һ���㲥\n�����㲥\nandroid.permission.BROADCAST_STICKY������һ�������յ��㲥������յ���һ���㲥\nWAP PUSH�㲥\nandroid.permission.BROADCAST_WAP_PUSH��WAP PUSH�����յ��󴥷�һ���㲥\n����绰\nandroid.permission.CALL_PHONE����������ӷ�ϵͳ������������绰����\nͨ��Ȩ��\nandroid.permission.CALL_PRIVILEGED���������򲦴�绰���滻ϵͳ�Ĳ���������\n����Ȩ��\nandroid.permission.CAMERA��������������ͷ��������\n�ı����״̬\nandroid.permission.CHANGE_COMPONENT_ENABLED_STATE���ı�����Ƿ�����״̬\n�ı�����\nandroid.permission.CHANGE_CONFIGURATION��������ǰӦ�øı����ã��綨λ\n�ı�����״̬\nandroid.permission.CHANGE_NETWORK_STATE���ı�����״̬���Ƿ�������\n�ı�WiFi�ಥ״̬\nandroid.permission.CHANGE_WIFI_MULTICAST_STATE���ı�WiFi�ಥ״̬\n�ı�WiFi״̬\nandroid.permission.CHANGE_WIFI_STATE���ı�WiFi״̬\n���Ӧ�û���\nandroid.permission.CLEAR_APP_CACHE�����Ӧ�û���\n����û�����\nandroid.permission.CLEAR_APP_USER_DATA�����Ӧ�õ��û�����\n```\n\n","tags":["����"],"categories":["Reverse"]}]