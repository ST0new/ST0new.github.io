<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ST0new Blog</title>
  
  <subtitle>博观而约取，厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-25T08:39:11.069Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ST0new</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTF-androideasy</title>
    <link href="http://yoursite.com/2020/03/25/%E9%80%86%E5%90%91/CTF/androideasy/"/>
    <id>http://yoursite.com/2020/03/25/逆向/CTF/androideasy/</id>
    <published>2020-03-25T08:35:34.000Z</published>
    <updated>2020-03-25T08:39:11.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：androideasy"><a href="#题目：androideasy" class="headerlink" title="题目：androideasy"></a>题目：androideasy</h1><p>最近刚学了点逆向技能，找一些简单的ctf 题目来验证一下效果</p><p>下载地址：<a href="https://github.com/ThunderJie/CTF-Practice/tree/master/CTF-Andorid%20Reverse/androideasy" target="_blank" rel="noopener">androideasy</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先拿到的是个zip文件，打开是个普通的apk目录</p><p><img src="https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160159860.png" alt></p><p>也不知道做逆向的和做安全的看到他的感觉是否一样，</p><p>修改后缀为<code>apk</code> 后扔到jadx中，然后在往模拟器中扔一份</p><p>模拟器中可以看到 很简单的功能，输入字符 。点击check 判断是否输入正确</p><p><img src="https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160654280.png" alt></p><p>之后查看jadx</p><p>大概确定一下，就是需要输入一个字符串在check判断通过即可</p><p><img src="https://raw.githubusercontent.com/ST0new/picture/master/2020/2/image-20200325160744208.png" alt></p><p>定位到check，输入的字符串必须让if判断为真，也就是进入到check的true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private byte[] f21s = &#123;113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106&#125;;</span><br><span class="line"></span><br><span class="line">public boolean check() &#123;</span><br><span class="line">        byte[] chars = this.editText.getText().toString().getBytes();</span><br><span class="line">        if (chars.length != this.f21s.length) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; this.f21s.length &amp;&amp; i &lt; chars.length) &#123;</span><br><span class="line">            if (this.f21s[i] != (chars[i] ^ 23)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来写firda 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function flag() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        var flag1 = Java.use(&quot;com.a.sample.androidtest.MainActivity&quot;);</span><br><span class="line">        flag1.check.implementation = function () &#123;</span><br><span class="line">             var retval = this.check();</span><br><span class="line">             console.log(retval)</span><br><span class="line">             return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">    flag()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>这样就可以保证返回为真了</p><p>回到正题，前台返回为真对flag没有帮助，</p><p>所以还是得得到<code>f21s</code> ,写个脚本 获得下面的字符串</p><p><code>private byte[] f21s = {113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106};</code></p><p>最后的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f21s = [<span class="number">113</span>, <span class="number">123</span>, <span class="number">118</span>, <span class="number">112</span>, <span class="number">108</span>, <span class="number">94</span>, <span class="number">99</span>, <span class="number">72</span>, <span class="number">38</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">87</span>, <span class="number">89</span>, <span class="number">72</span>, <span class="number">36</span>, <span class="number">118</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">72</span>, <span class="number">87</span>, <span class="number">121</span>, <span class="number">83</span>, <span class="number">101</span>, <span class="number">39</span>, <span class="number">62</span>, <span class="number">94</span>, <span class="number">62</span>, <span class="number">38</span>, <span class="number">107</span>, <span class="number">115</span>, <span class="number">106</span>]</span><br><span class="line">print(len(f21s))</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  i <span class="keyword">in</span> range(<span class="number">0</span>,len(f21s)):  <span class="comment"># 判断每一位，一共判断f21s 长度次</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> (f21s[i] == (j ^ <span class="number">23</span>)):</span><br><span class="line">            flag += chr(j)</span><br><span class="line"></span><br><span class="line">print(flag)py</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">31</span><br><span class="line">flag&#123;It_1S_@N_3asY_@nDr0)I)1|d&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目：androideasy&quot;&gt;&lt;a href=&quot;#题目：androideasy&quot; class=&quot;headerlink&quot; title=&quot;题目：androideasy&quot;&gt;&lt;/a&gt;题目：androideasy&lt;/h1&gt;&lt;p&gt;最近刚学了点逆向技能，找一些简单的ctf 题
      
    
    </summary>
    
    
      <category term="Reverse" scheme="http://yoursite.com/categories/Reverse/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/03/24/%E9%80%86%E5%90%91/XposedFridaHook%E7%B3%BB%E5%88%97/Hook%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2020/03/24/逆向/XposedFridaHook系列/Hook开始/</id>
    <published>2020-03-24T12:19:59.397Z</published>
    <updated>2020-03-30T06:30:40.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook-通杀"><a href="#Hook-通杀" class="headerlink" title="Hook 通杀"></a>Hook 通杀</h1><h2 id="Hook-普通方法和修改函数参数返回值"><a href="#Hook-普通方法和修改函数参数返回值" class="headerlink" title="Hook 普通方法和修改函数参数返回值"></a>Hook 普通方法和修改函数参数返回值</h2><p>fradaserver 是手机端的，</p><ol><li>android低版本 frida 尽量低版本</li><li>fridaserver版本要与frida库版本一致</li><li>不同平台用不同fridaserver</li><li>不要和xposed装一起，新疆模拟器，刷机</li></ol><p>设备要求:</p><p>​    root</p><pre><code>调试</code></pre><p>下载frida-server push到手机中 (注意查看手机是86的还是64的)</p><p><code>adb push .\frida-server-12.8.14-android-x86 /data/local/tmp/fsx86</code></p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200319214805400.png" alt="image-20200319214805400"></p><p>之后cd到tmp目录下</p><p>先给fsx86 赋权  <code>chmod 777 fsx86</code></p><p>之后执行即可。 <code>./fsx86</code></p><p>执行后有一个报错，这里是版本出现的问题，会有一些小bug ，不影响使用，最好还是在真机中调试</p><p><code>WARNING: linker: ./fsx86: unused DT entry: type 0x6ffffef5 arg 0x1c24</code></p><h2 id="插入一个学习"><a href="#插入一个学习" class="headerlink" title="插入一个学习"></a>插入一个学习</h2><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200320103048870.png" alt="image-20200320103048870"></p><p>Hook 构造方法</p><p>​    绕过一些验证</p><p>​    构造方法</p><p>​    <code>money.$init.implementation = function(){}</code></p><p>Hook 重载方法</p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200320105658343.png" alt="image-20200320105658343"></p><p>Hook 重载方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function hooktest2() &#123;</span><br><span class="line">    //Error: test(): has more than one overload, use .overload(&lt;signature&gt;)</span><br><span class="line">    var utils = Java.use(&quot;com.xiaojianbang.app.Utils&quot;);</span><br><span class="line">    utils.test.overload(&apos;int&apos;).implementation = function (a) &#123;</span><br><span class="line">        a = 888;</span><br><span class="line">        var retval = this.test();</span><br><span class="line">        console.log(a, retval);</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;;</span><br><span class="line">    utils.test.overload().implementation = function () &#123;</span><br><span class="line">        var retval = this.test();</span><br><span class="line">        console.log(retval);</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;;</span><br><span class="line">    utils.test.overload(&apos;com.xiaojianbang.app.Money&apos;).implementation = function (a) &#123;</span><br><span class="line">        var retval = this.test(a);</span><br><span class="line">        console.log(retval);</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook 所有重载方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function hookTest3() &#123;</span><br><span class="line">    // hook 方法的所有重载</span><br><span class="line">    var utils = Java.use(&quot;com.xiaojianbang.app.Utils&quot;);</span><br><span class="line">    console.log(utils.test.overloads.length);</span><br><span class="line">    for (var i = 0; i &lt; utils.test.overloads.length; i++) &#123;</span><br><span class="line">        utils.test.overloads[i].implementation = function () &#123;</span><br><span class="line">            // console.log(JSON.stringify(arguments));</span><br><span class="line"></span><br><span class="line">            if (arguments.length == 0) &#123;</span><br><span class="line">                return &quot;调用没有参数的&quot;;</span><br><span class="line">            &#125; else if (arguments.length == 1)&#123;</span><br><span class="line">                if (JSON.stringify(arguments).indexOf(&quot;Money&quot;) != -1)&#123;</span><br><span class="line">                    return &quot;调用了Money参数的&quot;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return &quot;调用了Int 类型的&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                arguments[0] = 1000;</span><br><span class="line">            // console.log(arguments.length);</span><br><span class="line">            // apply 改变所属</span><br><span class="line">            return this.test.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook 构造参数与对象实例化</p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200321172539738.png" alt="image-20200321172539738"></p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200321173626852.png" alt="image-20200321173626852"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function hooktest2() &#123;</span><br><span class="line">    //Error: test(): has more than one overload, use .overload(&lt;signature&gt;)</span><br><span class="line">    var utils = Java.use(&quot;com.xiaojianbang.app.Utils&quot;);</span><br><span class="line">    var money = Java.use(&quot;com.xiaojianbang.app.Money&quot;);</span><br><span class="line"></span><br><span class="line">    utils.test.overload(&apos;int&apos;).implementation = function (a) &#123;</span><br><span class="line">        a = 888;</span><br><span class="line">        var retval = this.test(money.$new(&quot;日元&quot;, 1000000)); // 对象实例化</span><br><span class="line">        console.log(a, retval);</span><br><span class="line">        return retval;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>hook 实例化</p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200321174929718.png" alt="image-20200321174929718"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function hookTest5() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        //静态字段的修改</span><br><span class="line">        var money = Java.use(&quot;com.xiaojianbang.app.Money&quot;);</span><br><span class="line">        //send(JSON.stringify(money.flag));</span><br><span class="line">        money.flag.value = &quot;ceshi&quot;;</span><br><span class="line">        console.log(&apos;log&apos;, money.flag.value);</span><br><span class="line">        // 非静态字段的修改</span><br><span class="line">        Java.choose(&quot;com.xiaojianbang.app.Money&quot;, &#123;</span><br><span class="line">            onMatch: function (obj) &#123;</span><br><span class="line">                obj._name.value = &quot;ouyuan&quot;; // 字段与函数名相同， 前面加下划线</span><br><span class="line">                obj.num.value = 15254131;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete: function () &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 获取所有的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function hookTest7() &#123;</span><br><span class="line">    Java.perform(function () &#123;</span><br><span class="line">        Java.enumerateLoadedClasses(&#123;</span><br><span class="line">            onMatch:function (name,handle) &#123;</span><br><span class="line">                if (name.indexOf(&quot;com.xiaojianbang.app&quot;) != -1)&#123;</span><br><span class="line">                    console.log(name);</span><br><span class="line">                    var clazz = Java.use(name);</span><br><span class="line">                    var methods = clazz.class.getDeclaredMethods();</span><br><span class="line">                    console.log(methods)</span><br><span class="line">                    for (var i = 0 ; i&lt; methods.length;i++)&#123;</span><br><span class="line">                        console.log(methods[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function () &#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var classes = Java.enumerateLoadedClassesSync();</span><br><span class="line">for (var i = 0 ; i &lt; classes.length ; i++)&#123;</span><br><span class="line">    if (classes[i].indexOf(&quot;com.xiaojianbang.app&quot;) != -1)&#123;</span><br><span class="line">        console.log(classes[i]);</span><br><span class="line">        var clazz = Java.use(classes[i]);</span><br><span class="line">        var methods = clazz.class.getDeclaredMethods();</span><br><span class="line">        for (var j = 0 ;j &lt; methods.length ;j++)&#123;</span><br><span class="line">            console.log(methods[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Hook-回笼重造"><a href="#Hook-回笼重造" class="headerlink" title="Hook 回笼重造"></a>Hook 回笼重造</h1><img src="E:\博客\andorid逆向\Frida学习\Hook开始.assets\image-20200324171350015.png" alt="image-20200324171350015" style="zoom:50%;"><blockquote><p>xposed 框架替换了很多文件，如果要从xposed转frida 需要刷机</p></blockquote><p>修改debuggable 参考：<a href="https://www.bodkin.ren/index.php/archives/533/" target="_blank" rel="noopener">https://www.bodkin.ren/index.php/archives/533/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Go0s]: ~/Security/_Tools/Android/mprop/armeabi-v7a ✗ master*</span><br><span class="line">➜  adb push mprop /data/local/tmp              </span><br><span class="line">mprop: 1 file pushed. 1.6 MB/s (17712 bytes in 0.011s)</span><br><span class="line">[Go0s]: ~ </span><br><span class="line">➜  adb shell</span><br><span class="line">shell@hammerhead:/ $ cat default.prop | grep debug                             </span><br><span class="line">ro.debuggable=0</span><br><span class="line">shell@hammerhead:/ $ getprop ro.debuggable</span><br><span class="line">0</span><br><span class="line">shell@hammerhead:/ $ cd /data/local/tmp</span><br><span class="line">shell@hammerhead:/data/local/tmp $ su</span><br><span class="line">root@hammerhead:/data/local/tmp # ./mprop ro.debuggable 1   </span><br><span class="line">properties map area: b6f7a000-b6f9a000</span><br><span class="line">00000000  08 8d 00 00 19 01 00 00 50 52 4f 50 ab d0 6e fc  ........PROP??n?</span><br><span class="line">00000010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">……</span><br><span class="line">root@hammerhead:/ # cat default.prop | grep debug                              </span><br><span class="line">ro.debuggable=0</span><br><span class="line">root@hammerhead:/ # getprop ro.debuggable                                      </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>版本太高导致的问题，问题不会大</p><p><img src="E:%5C%E5%8D%9A%E5%AE%A2%5Candorid%E9%80%86%E5%90%91%5CFrida%E5%AD%A6%E4%B9%A0%5CHook%E5%BC%80%E5%A7%8B.assets%5Cimage-20200324192712444.png" alt="image-20200324192712444"></p><p>配置代码提示</p><figure class="highlight plain"><figcaption><span>i @types/frida-gum```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hook步骤</span><br><span class="line"></span><br><span class="line">1. 进入手机终端 启动 fsx86</span><br><span class="line">2. 端口转发</span><br><span class="line">3. 使用命令开始hook吧 `frida -U 包名 -l hook代码`</span><br><span class="line"></span><br><span class="line">### 逻辑分析</span><br><span class="line"></span><br><span class="line">要hook getCalc 方法，定位到函数声明</span><br><span class="line"></span><br><span class="line">![image-20200324201846328](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324201846328.png)</span><br><span class="line"></span><br><span class="line">定位到getCalc  方法有两个参数 a,b </span><br><span class="line"></span><br><span class="line">![image-20200324201919870](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324201919870.png)</span><br><span class="line"></span><br><span class="line">### Hook普通方法</span><br><span class="line"></span><br><span class="line">接下来根据这个函数开始hook</span><br><span class="line"></span><br><span class="line">​`var utils = Java.use(&quot;com.xiaojianbang.app.Utils&quot;);` 定位函数</span><br><span class="line"></span><br><span class="line">​重写方法 implementation</span><br></pre></td></tr></table></figure><p>var utils = Java.use(“com.xiaojianbang.app.Utils”);<br>utils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型<br>    // 先打印一下a,b 参数和返回的参数<br>    var retval = this.getCalc(a,b); </p><pre><code>console.log(a,b,retval);return retval;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">​点击普通方法，即可在frida中看到获取的参数</span><br><span class="line"></span><br><span class="line">![image-20200324202244461](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324202244461.png)</span><br><span class="line"></span><br><span class="line">之后修改a ，b 参数</span><br></pre></td></tr></table></figure><p>var utils = Java.use(“com.xiaojianbang.app.Utils”);<br>utils.getCalc.implementation = function (a,b) { // implementation 是重写方法， js中不需要函数类型<br>    a = 123;<br>    b = 345;</p><pre><code>var retval = this.getCalc(a,b);console.log(a,b,retval);return retval;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20200324203353529](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324203353529.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Hook 重载方法和重载方法的Hook</span><br><span class="line"></span><br><span class="line">重载方法和一般普通方法区别不大</span><br><span class="line"></span><br><span class="line">![image-20200324205305292](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324205305292.png)</span><br><span class="line"></span><br><span class="line">当使用之前的方法 去hook重载方法</span><br><span class="line"></span><br><span class="line">![image-20200324205229878](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324205229878.png)</span><br><span class="line"></span><br><span class="line">需要使用overload 去指定参数</span><br></pre></td></tr></table></figure><pre><code>utils.test.overload(&apos;int&apos;).implementation = function (a, b) { // implementation 是重写方法， js中不需要函数类型</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后hook所有的重载方法</span><br><span class="line"></span><br><span class="line">只要符合返回值，可以随意改的，即使调用其他的重载函数也是可以执行</span><br></pre></td></tr></table></figure><p>utils.test.overload(‘int’).implementation = function (a) { // implementation 是重写方法， js中不需要函数类型<br>    a = 888888888;<br>    var retval = this.test(a);<br>    console.log(a, retval);<br>    return retval;<br>};<br>utils.test.overload().implementation = function () {<br>    var retval = this.test();<br>    console.log(“无参：”,retval);<br>    return retval;<br>};<br>utils.test.overload(“com.xiaojianbang.app.Money”).implementation = function (a) {<br>    var retval = this.test(a);<br>    console.log(a,retval);<br>    return retval;<br>};</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hook所有重载函数</span><br></pre></td></tr></table></figure><p>for (var i = 0 ;i &lt; utils.test.overloads.length;i++){ // 通过for 循环去获取每一个<br>    utils.test.overloads[i].implementation = function () {<br>        console.log(arguments); // arguments 是一个数组<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过apply 可以避免每次返回需要改变返回参数的问题</span><br></pre></td></tr></table></figure><p>this.test.apply(this,arguments) // apply 是改变函数所属</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;  在frida 中，在同位置下多个钩子 最后一个会生效，因为他的代码会覆盖之前的代码。</span><br><span class="line"></span><br><span class="line">返回hook每个重载函数 参数长度</span><br></pre></td></tr></table></figure><p>function hookTest3() {<br>    // hook方法的所有重载<br>    var utils = Java.use(“com.xiaojianbang.app.Utils”);<br>    console.log(utils.test.overloads.length)<br>    // 之后遍历参数<br>    for (var i = 0 ;i &lt; utils.test.overloads.length;i++){<br>        utils.test.overloads[i].implementation = function () {<br>            //console.log(arguments);</p><pre><code>        return this.test.apply(this,arguments) // apply 是改变函数所属    }}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">返回结果</span><br><span class="line"></span><br><span class="line">![](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324213234513.png)</span><br><span class="line"></span><br><span class="line">如果需要修改其中的某个重载函数 则需要在这里做一个判断</span><br></pre></td></tr></table></figure><p>if (arguments.length == 0){<br>    return “xiaojianbang”;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hook 完整代码</span><br></pre></td></tr></table></figure><p>function hookTest3() {<br>    // hook方法的所有重载<br>    var utils = Java.use(“com.xiaojianbang.app.Utils”);<br>    console.log(utils.test.overloads.length)<br>    // 之后遍历参数<br>    for (var i = 0 ;i &lt; utils.test.overloads.length;i++){<br>        utils.test.overloads[i].implementation = function () {<br>            //console.log(arguments);<br>            if (arguments.length == 0){<br>                return “xiaojianbang”;<br>            }else if (arguments.length ==  1){<br>                if (JSON.stringify(arguments).indexOf(“Money”) != -1 ){<br>                    return “调用了Money参数”;<br>                } else{<br>                    return “ 调用了int参数的”;<br>                }<br>            }<br>            return this.test.apply(this,arguments) // apply 是改变函数所属<br>        }<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Hook 构造函数与对象实例化</span><br><span class="line"></span><br><span class="line">这里的`Money` 是我们的构造函数 函数与类型一致 </span><br><span class="line"></span><br><span class="line">![image-20200324215249350](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324215249350.png)</span><br><span class="line"></span><br><span class="line">也需要指明</span><br><span class="line"></span><br><span class="line">![image-20200324215639928](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324215639928.png)</span><br><span class="line"></span><br><span class="line">构造函数和重载只是多了个 $init</span><br></pre></td></tr></table></figure><p>function hookTest4() {<br>    var money = Java.use(“com.xiaojianbang.app.Money”);<br>    // 函数名与方法名一致<br>    money.$init.overload(‘java.lang.String’,’int’).implementation = function (str,num) {<br>        console.log(str,num);<br>        this.$init(str,num);<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上一节重载函数，我们调用了money ，但是当我们要修改其中的值时 需要调用money的包</span><br><span class="line"></span><br><span class="line">![image-20200324220110549](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324220110549.png)</span><br><span class="line"></span><br><span class="line">在函数开始位置添加</span><br><span class="line"></span><br><span class="line">![image-20200324220151168](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324220151168.png)</span><br><span class="line"></span><br><span class="line">这就完成了一个实例化</span><br><span class="line"></span><br><span class="line">![image-20200324220241983](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324220241983.png)</span><br><span class="line"></span><br><span class="line">## 修改类的字段</span><br><span class="line"></span><br><span class="line">先尝试hook一下静态资源</span><br></pre></td></tr></table></figure><p>var money = Java.use(“com.xiaojianbang.app.Money”);<br>//send(money.flag)<br>console.log(JSON.stringify(money.flag.value));</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 多个对象就会有多个字段，所以要修改 必须找到对应的字段</span><br><span class="line"></span><br><span class="line">修改字段</span><br></pre></td></tr></table></figure><p>// 静态字段<br>var money = Java.use(“com.xiaojianbang.app.Money”);<br>//send(money.flag)<br>money.flag.value = “xiaojianbang”;</p><p>console.log(JSON.stringify(money.flag.value));</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hook 修改非静态字段</span><br><span class="line"></span><br><span class="line">&gt; 正常的每次修改都会new一个对象，所以看不到返回的值</span><br><span class="line"></span><br><span class="line">![image-20200324222948009](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324222948009.png)</span><br></pre></td></tr></table></figure><p>Java.choose(“com.xiaojianbang.app.Money”, {<br>    onMatch: function (obj) { // 每次遍历对象都会调用一次onMatch<br>        // 修改对象参数，如果修改单个 价格判断即可<br>        obj._name.value = “ouyuan”; // 这块注意字段名与函数名是否相同<br>        obj.num.value = 15000000;<br>    },<br>    onComplete: function () {</p><pre><code>}</code></pre><p>});  // cakkbacks指的是对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 这块注意 当字段名与函数名相同 要加`_`来区分</span><br><span class="line"></span><br><span class="line">## hook 内部类和匿名类</span><br><span class="line"></span><br><span class="line">当hook 类下的类 hook方法</span><br><span class="line"></span><br><span class="line">可以通过jeb smail 去看 </span><br><span class="line"></span><br><span class="line">![image-20200324230631123](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324230631123.png)</span><br><span class="line"></span><br><span class="line">money 只是一个父类，匿名类是getInfo 这里实现了一次， 匿名类一般都是$1 这种形式</span><br><span class="line"></span><br><span class="line">![image-20200324231541211](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200324231541211.png)</span><br><span class="line"></span><br><span class="line">## 枚举所有的类和所有的方法</span><br></pre></td></tr></table></figure><p>Java.enumerateLoadedClasses() //枚举类 只能加载 已经被加载的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">java反射获取方法</span><br></pre></td></tr></table></figure><p>var methods = clazz.class.getDeclaredMethods();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取所有的类</span><br></pre></td></tr></table></figure><p>Java.enumerateLoadedClasses({<br>    onMatch:function (name,handle) { // 代码都是写在这里的<br>        if (name.indexOf(“com.xiaojianbang.app”) != -1){<br>            console.log(name)<br>        }<br>    },<br>    onComplete:function () { // 这里只会使用一次</p><pre><code>}</code></pre><p>})</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">获取类下的方法</span><br></pre></td></tr></table></figure><p> Java.enumerateLoadedClasses({<br>            onMatch:function (name,handle) { // 代码都是写在这里的<br>                if (name.indexOf(“com.xiaojianbang.app”) != -1){<br>                    console.log(name) // 类和地址  打印好多系统类，这里就要做个过滤<br>                    // 遍历类下的所有的方法 java 反射 有个getDeclaredMethods<br>                    var clazz = Java.use(name);<br>                    console.log(clazz);<br>                    var methods = clazz.class.getDeclaredMethods(); // 得到的是一个对象，这里要通过class转<br>                    //console.log(methods);  // 直接打印输出较乱 做一个整理</p><pre><code>            if (var i = 0; i &lt; methods[i].length;i++){                console.log(methods[i]);            }            console.log()        }    },    onComplete:function () { // 这里只会使用一次    }})</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">异步方式获取类和类的方法</span><br></pre></td></tr></table></figure><p>var classes = Java.enumerateLoadedClassesSync();<br>for (var i = 0; i &lt; classes.length; i++) {<br>    if (classes[i].indexOf(“com.xiaojianbang.app”) != -1) {<br>        console.log(classes[i]);<br>        var clazz = Java.use(classes[i]);<br>        var methods = clazz.class.getDeclaredMethods();<br>        for (var j = 0; j &lt; methods.length; j++) {<br>            console.log(methods[j]);<br>        }<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## hook类的所有方法</span><br><span class="line"></span><br><span class="line">首先确定hook那个类， 比如md5，之后通过java反射 获取类下的方法</span><br></pre></td></tr></table></figure><p>var md5 = Java.use(“com.xiaojianbang.app.MD5”);<br>var methods= md5.class.getDeclaredMethods();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">之后通过循环返回打印</span><br></pre></td></tr></table></figure><p>function hookTest8() {<br>    Java.perform(function () {<br>        var md5 = Java.use(“com.xiaojianbang.app.MD5”);<br>        var methods = md5.class.getDeclaredMethods();<br>        for (var i = 0; i &lt; methods.length; i++) {<br>            var methodName = methods[i].getName();<br>            console.log(methodName);<br>            for (var k = 0; k &lt; md5[methodName].overloads.length; k++) {<br>                md5[methodName].overloads[k].implementation = function () {<br>                    for (var j = 0; j &lt; arguments.length; j++) {<br>                        console.log(arguments[j]);<br>                    }<br>                    return this[methodName].apply(this, arguments) // 不知道返回的对象<br>                }<br>            }</p><pre><code>    }})</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 动态加载dex</span><br><span class="line"></span><br><span class="line">遇到问题： 在调用函数后，有些dex 是通过动态加载调用的，反编译并不会反编译到所有的dex</span><br><span class="line"></span><br><span class="line">一般可以通过DexClassLoader动态加载，或者通过so层 或者内存中去加载</span><br><span class="line"></span><br><span class="line">这里通过DexClassLoader去加载，文件放在apk的目录中</span><br><span class="line"></span><br><span class="line">![image-20200325214341078](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200325214341078.png)</span><br><span class="line"></span><br><span class="line">当直接调用就会报错</span><br></pre></td></tr></table></figure><p>function hookTest9() {<br>    Java.perform(function () {<br>        var dynamic = Java.use(“com.xiaojianbang.app.Dynamic”);<br>        console.log(dynamic);<br>    })<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20200325214906826](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200325214906826.png)</span><br><span class="line"></span><br><span class="line">这里就要找到对应的classloader  </span><br><span class="line"></span><br><span class="line">&gt; 注意：这个api是要在7版本以上使用，用android5 可能会报错</span><br></pre></td></tr></table></figure><p>function hookTest9(){<br>    Java.perform(function(){</p><pre><code>    Java.enumerateClassLoaders({        onMatch: function(loader){            try {                if(loader.loadClass(&quot;com.xiaojianbang.app.Dynamic&quot;)){                    Java.classFactory.loader = loader;                    var Dynamic = Java.use(&quot;com.xiaojianbang.app.Dynamic&quot;);                    console.log(Dynamic);                    Dynamic.sayHello.implementation = function(){                        return &quot;xiaojianbang&quot;;                    }                }            } catch (error) {            }        }        ,        onComplete: function(){        }    });});</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![image-20200326091943750](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200326091943750.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Java.classFactory.loader = loader; 这里的loader 可能会报错 不影响正确性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Java 里特殊类型的遍历与修改</span><br><span class="line"></span><br><span class="line">Hook map 或者修改其中的某些值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20200329001310423](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200329001310423.png)</span><br><span class="line"></span><br><span class="line">![image-20200329001325832](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200329001325832.png)</span><br><span class="line"></span><br><span class="line">这块可以使用show（java的代码） 去hook</span><br><span class="line"></span><br><span class="line">可以将show方法 直接copy过去，但是要注意里面的函数要遵守js的语法</span><br><span class="line"></span><br><span class="line">这块要使用迭代器去获取map</span><br></pre></td></tr></table></figure><p>不要调用伪代码的方法，而是去自写<br>function hookTest10(){<br>    Java.perform(function () {<br>        var ShufferMap = Java.use(“com.xiaojianbang.app.ShufferMap”)<br>        console.log(ShufferMap);<br>        ShufferMap.show.implementation = function (map) {<br>            console.log(JSON.stringify(map));</p><pre><code>        var key = map.keySet();        var it = key.iterator();        var result = &quot;&quot;;        while (it.hasNext()) {            var keystr = it.next();            var valuestr = map.get(keystr);            result += valuestr;        }    console.log(result);    return result;    }})</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">之后是java 特殊类型的修改</span><br></pre></td></tr></table></figure><p>function hookTest10(){<br>    Java.perform(function () {<br>        var ShufferMap = Java.use(“com.xiaojianbang.app.ShufferMap”)<br>        console.log(ShufferMap);<br>        ShufferMap.show.implementation = function (map) {<br>            console.log(JSON.stringify(map));<br>        // 2 修改特殊方法<br>            map.put(“pass”,”zygx8”);<br>            map.put(“xxxx”,”<a href="http://www.zygx8.com&quot;" target="_blank" rel="noopener">www.zygx8.com&quot;</a>);<br>            var retval = this.show(map);<br>            console.log(retval);<br>            return retval;</p><pre><code>    }})</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Java 层主动调用函数</span><br><span class="line"></span><br><span class="line">只有当函数被触发才会被执行，那么当我们需要解密一个比较复杂的算法，是可以通过主动调用函数去获取的</span><br><span class="line"></span><br><span class="line">静态主动调用</span><br></pre></td></tr></table></figure><p>调用rsa方法<br>function hookTest11() {<br>    Java.perform(function () {<br>        var rsa = Java.use(“com.xiaojianbang.app.RSA”);<br>        var str = Java.use(“java.lang.String”);<br>        var base64 = Java.use(“android.util.Base64”);<br>        var bytes = str.$new(“xioajianbang”).getBytes();<br>        console.log(bytes);<br>        var retval = rsa.encrypt(bytes);<br>        console.log(retval);<br>        var result = base64.encodeToString(retval,0);<br>        console.log(result);<br>    })<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">非静态方法的主动调用 调用getinfo</span><br></pre></td></tr></table></figure><p> Java.use(“com.xiaojianbang.Money”).$new(“欧元”,3000000).getInfo();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Java 打印函数堆栈</span><br><span class="line"></span><br><span class="line">之前使用Log.d 来打印信息</span><br><span class="line"></span><br><span class="line">![image-20200330115446399](D:\Blog\ST0new.github.io\source\_posts\逆向\XposedFridaHook系列\Hook开始.assets\image-20200330115446399.png)</span><br><span class="line"></span><br><span class="line">推荐： 使用`Log.getStack.TrachString(new Throwable())` 或``Log.getStack.TrachString(new exception())``</span><br></pre></td></tr></table></figure><p>function hookTest12() {<br>    // 写一个函数堆栈<br>    function showStacks(){<br>        console.log(Java.use(“android.util.Log”).getStackTraceString(Java.use(“java.lang.Exception”).$new()));<br>        //console.log(Java.use(“android.util.Log”).getStackTraceString(Java.use(“java.lang.Exception”).$new()));<br>    }<br>    Java.perform(function () {<br>        //Java.cast();<br>        //Java.openClassFile();<br>        var MessageDigest =  Java.use(“java.security.MessageDigest”);<br>        MessageDigest.digest.overload().implementation = function () {<br>            showStacks();<br>            return this.digest();</p><pre><code>    }})</code></pre><p>}<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hook-通杀&quot;&gt;&lt;a href=&quot;#Hook-通杀&quot; class=&quot;headerlink&quot; title=&quot;Hook 通杀&quot;&gt;&lt;/a&gt;Hook 通杀&lt;/h1&gt;&lt;h2 id=&quot;Hook-普通方法和修改函数参数返回值&quot;&gt;&lt;a href=&quot;#Hook-普通方法和修改函数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Andorid Studio 安装报错 解决</title>
    <link href="http://yoursite.com/2020/03/10/%E9%80%86%E5%90%91/androidstudio%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/03/10/逆向/androidstudio安装报错/</id>
    <published>2020-03-10T12:44:24.000Z</published>
    <updated>2020-03-10T12:44:28.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Andorid-Studio-安装报错-解决"><a href="#Andorid-Studio-安装报错-解决" class="headerlink" title="Andorid Studio 安装报错 解决"></a>Andorid Studio 安装报错 解决</h1><h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p>安装了一下午的AndroidStudio 一直报错，安装不上sdk 实在头疼，查到资料改个hosts就搞定了，舒服</p><p>将这两个写入<code>c:\users\你电脑的名字\drivers\etc\hosts</code>中 即可解决 不挂代理轻松安装sdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">203.208.43.101 dl-ssl.google.com</span><br><span class="line">203.208.43.101 dl.google.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Andorid-Studio-安装报错-解决&quot;&gt;&lt;a href=&quot;#Andorid-Studio-安装报错-解决&quot; class=&quot;headerlink&quot; title=&quot;Andorid Studio 安装报错 解决&quot;&gt;&lt;/a&gt;Andorid Studio 安装报错 
      
    
    </summary>
    
    
      <category term="Reverse" scheme="http://yoursite.com/categories/Reverse/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>python第一课 数据结构和算法</title>
    <link href="http://yoursite.com/2020/02/27/%E7%BC%96%E7%A8%8B/python/python%E7%AC%AC%E4%B8%80%E8%AF%BE%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/02/27/编程/python/python第一课 数据结构和算法/</id>
    <published>2020-02-27T03:23:31.000Z</published>
    <updated>2020-02-27T03:23:35.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python第一课-数据结构和算法"><a href="#python第一课-数据结构和算法" class="headerlink" title="python第一课 数据结构和算法"></a>python第一课 数据结构和算法</h1><blockquote><p>注： 本文是对照<a href="https://python3-cookbook.readthedocs.io/" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/</a> 学习 总结笔记 </p></blockquote><h2 id="1-1-解压序列复制给多个变量"><a href="#1-1-解压序列复制给多个变量" class="headerlink" title="1.1  解压序列复制给多个变量"></a>1.1  解压序列复制给多个变量</h2><p><strong>问题</strong></p><p>现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？</p><p><strong>解决方案</strong></p><p><strong>元组</strong>：元组使用小括号与列表非常相似，创建元组只需要 <code>tup = (1,2,3,4,5,6)</code>,通过逗隔开即可；查看当前变量是否属于元组可以通过<code>type(tup)</code> 来获取变量类型；并且 元组也可以通过 tup = “a”,”b”,”c” 这样来实现；元组只包含一个元素，需要在元素后面添加逗号，否则会被当做运算符使用。</p><p><strong>序列</strong>：python中的序列一般指 字符串，列表，元组。python在序列中可以进行索引、切片、加、乘、检查成员、确定最大最小元素，</p><p><strong>字符串</strong>： python的字符串我在介绍中也说了， 通过 变量 等于 用引号包括的值即可，例如：</p><p>var = “St0n5”</p><p><strong>列表</strong>： 和元组类似，千万不要混淆了， 通过 list = [‘ceshi1’,’ceshi2’] 来创建</p><p>接下来开始解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 将p赋值给变量，注意变量的数量要和序列的数量相同</span><br><span class="line"># python 可以通过多变量赋值实现 同时对多个变量的赋值</span><br><span class="line">&gt;&gt;&gt; p =(4,5)</span><br><span class="line">&gt;&gt;&gt; x,y=p</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">5</span><br><span class="line"># 接下来 放一个列表试试</span><br><span class="line">&gt;&gt;&gt; data = [&apos;python&apos;,&apos;C&apos;,&apos;中国加油&apos;,52.0,(2020,2,26)]    </span><br><span class="line">&gt;&gt;&gt; code1,code2,num1,num2,data1=data    </span><br><span class="line">&gt;&gt;&gt; code1    </span><br><span class="line">&apos;python&apos;</span><br><span class="line">&gt;&gt;&gt; code2    </span><br><span class="line">&apos;C&apos;</span><br><span class="line">&gt;&gt;&gt; num1    </span><br><span class="line">&apos;中国加油&apos;</span><br><span class="line">&gt;&gt;&gt; num2    </span><br><span class="line">52.0</span><br><span class="line">&gt;&gt;&gt; data1    </span><br><span class="line">(2020, 2, 26)</span><br></pre></td></tr></table></figure><p><strong>讨论</strong></p><p>上面展示了都是序列元素和元素一样的情况，那如果只需要其中的一部分元素 应该怎么去做，</p><p>文章中提供了一种方法是使用任意变量名占位，之后丢掉就好，</p><p>还可以通过下标来输入某个元素 也可以达到解压一部分的目的。</p><h2 id="1-2-解压可迭代对象赋值给多个变量"><a href="#1-2-解压可迭代对象赋值给多个变量" class="headerlink" title="1.2 解压可迭代对象赋值给多个变量"></a>1.2 解压可迭代对象赋值给多个变量</h2><p><strong>问题</strong></p><p>如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 <code>ValueError</code> 。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？</p><p><strong>解决方案</strong></p><p><strong>容器</strong>: 把多个元素组织在一起的数据结构，当它可以用来询问某个元素是否包含在其中时，就可以理解为这是一个容器</p><p><strong>迭代对象</strong>：很多容器都是可迭代对象，但凡是可以返回一个迭代器的对象都可称之为可迭代对象</p><p><strong>迭代器</strong>： 它是一种带状态的对象，通过<code>next()</code>方法调用返回容器的下一个值，迭代器就是工厂模式的对象。</p><p><strong>生成器</strong>： 生成器是一种特殊的迭代器，生成器可以用更少的中间变量些流式代码，此外，相比于其他容器，它能更节省内存和<code>cpu</code>，没有返回值，通过<code>yield</code>来返回</p><p>解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 解决可迭代对象的元素超过变量个数 ，可以用 * 来解决问题</span><br><span class="line">&gt;&gt;&gt; record = (&apos;xss&apos;,&apos;sql&apos;,&apos;upload&apos;,&apos;xxe&apos;,&apos;download&apos;)      </span><br><span class="line">&gt;&gt;&gt; first,*middle,last = record      </span><br><span class="line">&gt;&gt;&gt; first      </span><br><span class="line">&apos;xss&apos;</span><br><span class="line">&gt;&gt;&gt; middle      </span><br><span class="line">[&apos;sql&apos;, &apos;upload&apos;, &apos;xxe&apos;]</span><br><span class="line">&gt;&gt;&gt; last      </span><br><span class="line">&apos;download&apos;</span><br><span class="line"># middle 永远都是列表类型，元素为空也是如此， 并且 * 表达式 可以用在任何位置。</span><br></pre></td></tr></table></figure><p>扩展的迭代语法是为了解压不确定个数或者任意个数的元素的可迭代对象设计的，通常可迭代对象都是有一定规律的， 有时 <code>*</code>表达式也可以用来做字符串的分割，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; line = &apos;nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false&apos;</span><br><span class="line">&gt;&gt;&gt; uname, *fields, homedir, sh = line.split(&apos;:&apos;)</span><br><span class="line">&gt;&gt;&gt; uname</span><br><span class="line">&apos;nobody&apos;</span><br><span class="line">&gt;&gt;&gt; homedir</span><br><span class="line">&apos;/var/empty&apos;</span><br><span class="line">&gt;&gt;&gt; sh</span><br><span class="line">&apos;/usr/bin/false&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当然，如果你想要的解压一些元素并丢弃他们，你可以用<code>*_</code>这样来表示废弃</p><p>未完待续 …</p><hr><p>参考链接：</p><p><a href="https://foofish.net/iterators-vs-generators.html" target="_blank" rel="noopener">https://foofish.net/iterators-vs-generators.html</a></p><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python第一课-数据结构和算法&quot;&gt;&lt;a href=&quot;#python第一课-数据结构和算法&quot; class=&quot;headerlink&quot; title=&quot;python第一课 数据结构和算法&quot;&gt;&lt;/a&gt;python第一课 数据结构和算法&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python 入门简介</title>
    <link href="http://yoursite.com/2020/02/26/%E7%BC%96%E7%A8%8B/python/python%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2020/02/26/编程/python/python介绍/</id>
    <published>2020-02-26T11:21:55.000Z</published>
    <updated>2020-02-26T11:21:57.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-简介"><a href="#python-简介" class="headerlink" title="python 简介"></a>python 简介</h1><p>为了完成毕设 努力学习python</p><ul><li>python 是一种解释型语言</li><li>pyhton 是交互式语言</li><li>python是面向对象语言</li><li>python是初学者语言 很简单</li></ul><h2 id="0x01-python区分"><a href="#0x01-python区分" class="headerlink" title="0x01 python区分"></a>0x01 python区分</h2><p>只要有python2 和python3 之分</p><h2 id="0x02-python的特点"><a href="#0x02-python的特点" class="headerlink" title="0x02 python的特点"></a>0x02 python的特点</h2><p>这就不提了 全是优点</p><p>python大法好</p><h2 id="0x03-python-变量类型"><a href="#0x03-python-变量类型" class="headerlink" title="0x03 python 变量类型"></a>0x03 python 变量类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>一般由数字、字母、下划线组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = &apos;xxxx&apos;</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>支持字符、数字、字符串 甚至可以包含列表（嵌套）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [ &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 ]</span><br><span class="line">tinylist = [123, &apos;john&apos;]</span><br></pre></td></tr></table></figure><p>python中支持数据类型和类型的<code>连接</code>和<code>重复</code>操作</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组用<code>()</code>标识，内部元素用逗号隔开。但是元组不能二次赋值，</p><p>元组不能通过修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple = ( &apos;runoob&apos;, 786 , 2.23, &apos;john&apos;, 70.2 )</span><br><span class="line">tinytuple = (123, &apos;john&apos;)</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典也是经常要使用的数据类型之一，和列表相比，列表是有序的对象集合，字典是无需的对象集合，列表是通过偏移存取，而字典是通过键来存取的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[&apos;one&apos;] = &quot;This is one&quot;</span><br><span class="line">dict[2] = &quot;This is two&quot;</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&apos;name&apos;: &apos;john&apos;,&apos;code&apos;:6734, &apos;dept&apos;: &apos;sales&apos;&#125;</span><br></pre></td></tr></table></figure><h1 id="PythonTip"><a href="#PythonTip" class="headerlink" title="PythonTip"></a>PythonTip</h1><h2 id="每日一练"><a href="#每日一练" class="headerlink" title="每日一练"></a>每日一练</h2><p><strong>结尾为0的个数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个正整数列表 L, 输出L内所有数字的乘积末尾0的个数。(提示:不要直接相乘,数字很多,相乘得到的结果可能会很大)。例如： L=[2,8,3,50],则输出：2</span><br></pre></td></tr></table></figure><p>我拿到题第以想法就是乘，但无疑会增加算法的时间复杂度，所以，接下来就是分析如何更加简洁的利用</p><p>需要的是末尾0的个数，而数字中任何可以得到末尾为0的个数的值都可以化为2x5x某个值</p><p>所以接下来只要对每一位数字化一下是否可以通过2或者 5 得到</p><p>最后求一下2和5分别有多少个，取最小的那个就可以了 因为2和5都是素数，所以不存在取得的数重复现象</p><p>总结一下：求每一个数可以得到几个2和几个5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">L =[2,8,3,50]</span><br><span class="line"></span><br><span class="line">count_2 ,count_5= 0,0</span><br><span class="line"></span><br><span class="line">def count_2_5(i,n):</span><br><span class="line">    num = 0</span><br><span class="line">    while i % n == 0:</span><br><span class="line">        i  = i / 2</span><br><span class="line">        num += 1</span><br><span class="line">    return num</span><br><span class="line"></span><br><span class="line">for i in L:</span><br><span class="line">    count_2 += count_2_5(i,2)</span><br><span class="line">    count_5 += count_2_5(i,5)</span><br><span class="line"></span><br><span class="line">print(min(count_2,count_5))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-简介&quot;&gt;&lt;a href=&quot;#python-简介&quot; class=&quot;headerlink&quot; title=&quot;python 简介&quot;&gt;&lt;/a&gt;python 简介&lt;/h1&gt;&lt;p&gt;为了完成毕设 努力学习python&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;python 是一种解
      
    
    </summary>
    
    
      <category term="Code" scheme="http://yoursite.com/categories/Code/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>android 安全之环境搭建（一）</title>
    <link href="http://yoursite.com/2020/02/05/%E9%80%86%E5%90%91/android%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/02/05/逆向/android学习之环境搭建/</id>
    <published>2020-02-05T12:49:39.000Z</published>
    <updated>2020-03-31T06:32:02.562Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5c880b6e3b36c33eaf8222caa7467ca243ae542265b52bad0164bab916791f9a">2180d006303213985e487fd1170d435e54fb73b1db7948858c7fc5e204c5737ce8d9ad2c2a5ae0e03acdf5ddf027fc70a53b784e0dc027fab7e0870a08580a986ed21d9637624ca6b8e82fa9be90bc4de71f2ace73c117650ebbf0a2eb0aae19362fd1fb0bb702bf2ea69ddb8520fa13a2dc9eaa2299c7b7e33d6e308255a1e873ec2d2443477b05f20c40880416abcc5947913a44d56f2fdd2cbd68876e4b89ff883039b681df793c7a3f17521ddb259d7bafd83c7271a014a43bdd844016183d12013bc1e17fbc14e016fcf9345eaaf317111f53434cd306654e7fe21396fafcad93f051837cd7aa52ccc146aea72453c58178f98e967d8cdff6a773e0d19c5694ced7d63c95277d54ed619d25b60c589a57605aa5116f17ea789573a9a4c3fb46a9019bf23645db043fea5360a0f1fd88adb9ed315ed97c9fbe36b100ac72fa56c67f18ba28575c1dcdaa7d79821a4ff5bb77884747039883660db59963f50afc8747bc311027514d0b1b7e5fe1263608a30976708d0d305944d91fb7780ccf804a25c9324816c986210b60c06fddbd24fa7c491198c6b51c908f337727fb9cf3a7618cc10d4d5c8138aceb0e38b559b87acabfbc5419e018312c96281806f61f55adebc6cd70a434b786d90832d298583ac539febbcaefaad48e9e7bd85611cd2282a83cd69d601d796afd32649426097d6515ef133e2eabd9695e0c74e461d2124995d124fd9c8a7825b95f2ed96c74bb7edf9d1cf867c6db891c439c274295b060ce45ce5ec325398f37475959c309e8e20cc64c96230e7b4d8a8e16f3d5187abfcd5e3d7946b8e58f948c1b6e06267fccf1693f4b9fe0a7d6954519d41a5a1c327dc34963d0b1f343d3ca45881c943aeed6191fa7bcd7d717d614a1f601c81ae109ca6d4e6bd1915dab04e4e00e3372dfe9ce2cf3e932628fbcc5c6e08b331841ed48a4a00988db9e4e84daca00b948ebf964c17979d389c1654307ea15dc7851efd332501f38599f9a684accf7d9e4404fae3fe1072857a568c0913e389b2e60e37c0b36534271d3774007e1c6a47a32af05dfa3fa22decb043c354db24b0fb9c86b4f87e2134d59ee926e6b77bce7f0e264eee280ad9164c7159f781ad4d169b218cabc0ac9e0d94f77e923a21de4a37214cfbfcd4be15dc0e94dd8ff3eeaa3cd41cbaca6f05e3cb0bf92493dc67aec20c87e2a09bc0edaabe7ab998589a76e0593171d46e52413eed76e6e754b76fb5e1267eff319816782b7d4f93ad8109763522bd8751c82248e8fa559cb4b8110539e2cf718f32982a301ee046c331f3373b4f5661d8a165c2944217a9d2535a1ff6b858cf18fbf1777b818326361bba8ddd17a0f2ad6e2d296156ba6eba39261fa6f0338401dd2dfccc3b8d5afd65153087cb0a6d5a6d40796ea2430fdd44f87a0a287d082094f1fb6591ac433ad8e1a247f3cc289c8ff403cc5fefcb667b95f8329c82e12d46eadc53ed7a2831735b8efcc7a192199294c9565c221deb645348abd411bf7735fc57c16ffdc7b3bf827b87935703d2f3776c7765deabf53ef783f266116cf63ed7ba1b05c45b6721a90e130632828bc157cae8250ce448c21598abc5a0cbe7cf5f8b5c0776751b4d3d84e52b1aea8076fb14dcf64c5a16e13f34fdf5f9b628a37f27aec017d1b6d267bfc39f3c9d71480e2b296ff982244a46d19ba75d7aeadd3fb411fbafd86c8a57a024503a12b0d87683ef650214c083b34e988f6fe551d03fd08ff1dc280313f819efc8168d4123c01711350926fc1e1442c85de07ca15a36c29109eb4d2b020993ddde25dfce7090d717e468df372073d7e9bc8c901b7463048fdc30ca7bcd4b6f02b0463ff6e7442ce4bb286ae3f1a202368dec8f8f81d7c9cec8cbeaf6d767a4c7d1ae8ac5bf0432b1f6647092a3f596232dbfc70aff158389d2a1139d765e87862fd10bbf4c92b58d5815edc3154aa559cacba98a79c3b938af1b173dea905d5b4dcb3d1b42b2ca63206894cdbbc0ae79b68e1d7fb54685c916988c957be38f3fc5875639cf72bb7e99fe96919b0833b43b3c9d244ad6c05821bf1c89d223a6207951afdc574cc7e4583965467310be2f7a7c3826dadbc137e7957775d205a4a90779ad0c172ab4feca6a4c8d21c022122fc950e4ec5115d89d4175c20688a375f635232cd531bb7db5efac0e43636c7abfac680f3fc86ee486348973bf39cf9963dc360b1d2c16d6380aaa92c2d5ffc69f42da8bf9cf00d5e3234c230feb235f86401e11969d092ea8b54059a22a8d9292dd452eaacef45187ff1f6c1f7f15fb8e28a387ab2432fc8f4e2b0acaea1edbf19e1feb41f878e96e22bc74a9a7d69765b1887e828e1eb4e35c896bc2f56fa4062bb6115fdf39017907b0c96a1292285bf3678be09b09a564b04ff4d79ba6fe437b8238a597a42232e8d32213772d90572ec293f4c1df400fbc6eebe02fc7e8ce7f434d877e0afad69512ef5bc9263e74629d3427aec970ee288e119fc0fd9de72d122fcae1746e89181b1908bff2aafa796476690deeccdcf071c539328da7e75ae3e7228bb0f8be07f37b10a6d4f84715530abd87a4232d190244dab1b09d6b387309a254c0b1bea030fcda71cb950823a9b1150bc755f7ac00c2cb1682381af0ed416036950f5faf1f642da78e9836b6aa1fd90942fffe4e35ddc0363f7d6466bc7634b7669d44e863190caa06c6c9b5031f2db0ba60ca6a90a28a6f615766c5f7bffd24b25646959077cd4d747f7b7846fdec6d8e9233d98a395b75c49464dad830fd07f13196c18535926eb7d74e5286eb6020a6fa66a8b24d4e7f3ee826f0c73d52d2b460e4e357ff646ce8ada32f7a83ed2b472b0df0f2923f70034308b960e176863ec23d7ee12487ee5a59fa92e1c411a480499590562953fc08ffe9fb2edb431350bd8c8ad3c8d8556e684ada52bd35a86baaf27e838919980b76d9234615b0104cd82cd502ceab8735fc56da159ad3b6e0c3d343c7227b83f572540e073d5af1f7e6ffe2c132ed1afd46c991fbfc8ae6e74f99f49b3d6325b8970f7ac0dc325c1886808045070375a29177b8398945bd1736b93136dc9f6f776bf5bf5d9a8913c394a4c0544bd649815743c7895aa54534f9f6bcacec0d0c8414fc12f843169fc19b189ebb8048784e6c6811be77a994484b1d57eb3893bddac210399b0ae0032d294f83bcbff0e75f529e167a7b226c12fd68b8e60ddcbcee8ae2adb49732d7e5a12daa9c7d09169c990f4e97e03169b5489daea142c0184713bbfbb445b88eea26764ec6f56fd1fc7d95275c88f635954c48e0898ba10529942dfe0b9927b2c236cb50db8a021df65343d22a58279aaa9b4ac9f0819c310e34322ff2ba4b24326a107c89dfc0bb4f3e3d00a7366147872255a79a8b0a6f5012185d6339c866802a705e7ad458edf6cd90a310b6ad2c22d6323f2866ae893649bd6f548dba3e0af6367e25ddd10ebd29affebb57f5304ff3b9730c9a1edac41c874acda52b02d61744984582b373a476e09534b42495336c2dedaae310b49c890fe76cb6298b9108aeb3a776a5c2b89fdec56d0f58993c54d4f80a483f0663f1f81c493a103c27bdfde75c602db2e582988a97a7ed17a9a7b2a9b796f62719b45a5aa613d9d9fc3177482cdc4e03326d83844d887aa46d66ca19c09ff62e7f26f77bcf0b37c21975a9ca359aef6505efb20193de377a7465d37a0df8917c0a1c112c8d7073b5b5d6ce81971198f3ec62ea843232766c9865e488a910236ccbd2324416110da72f496162569c38e9340b2ef5fd990f81ddb3b9cb7783148d66d197f587530e9dbd79297b6e088ba1c018f516e28e3e34983d0ebf5bd598a19994a5afce21935baf0b39f49b28797554691ddcc0ec185dcb47f5878bfb2d293440cc243e133a746fd174ef9b64c3903977a9c13367f3604405b7cf3ea5fcf894ac354b01db4bce9f1b41b7d072a2f7e06b2fe29f38d737dde55bf1d83c6c299acf85901ba7a9f5ddf016a5e591e5200e633f1bb404a8181cc8574551a40763a661f7f0a4726facd0b49b73a18bbc1eac124ee953cf61e284ef042ad5de480ce7077e432436aa310a46c79dbf5b702149d95fd165e446cf43363c9b1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Reverse" scheme="http://yoursite.com/categories/Reverse/"/>
    
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
